# 스킬과 슬래시 커맨드(Skills and Slash Commands)

**이전**: [05. 훅과 이벤트 기반 자동화](./05_Hooks.md) | **다음**: [07. 서브에이전트와 작업 위임](./07_Subagents.md)

---

스킬(Skill)은 특정 작업에 대해 Claude Code의 기능을 확장하는 재사용 가능한 명령 집합입니다. CLAUDE.md가 일반적인 프로젝트 컨텍스트를 제공하고, 훅(Hook)이 결정론적 자동화를 제공하는 반면, 스킬은 그 두 가지 사이의 간극을 채웁니다 — 스킬은 호출 시 Claude가 따르는, 구조화되고 이름이 붙은 명령 묶음입니다. `/commit` 스킬은 모든 커밋이 팀의 형식을 따르도록 보장합니다. `/review` 스킬은 일관된 코드 리뷰 체크리스트를 실행합니다. `/deploy` 스킬은 배포 워크플로를 단계별로 실행합니다. 이 레슨에서는 스킬을 효과적으로 생성, 설정, 사용하는 방법을 다룹니다.

**난이도**: ⭐⭐

**사전 지식**:
- [03. CLAUDE.md와 프로젝트 설정](./03_CLAUDE_md_and_Project_Setup.md)
- [05. 훅과 이벤트 기반 자동화](./05_Hooks.md)
- Markdown 및 YAML 프론트매터(frontmatter)에 대한 이해

## 학습 목표(Learning Objectives)

이 레슨을 완료하면 다음을 할 수 있습니다:

1. 스킬, 훅, CLAUDE.md 명령의 차이점 이해
2. SKILL.md 형식을 사용하여 커스텀 스킬 생성
3. 스킬 저장 위치 설정 (전역 및 프로젝트 수준)
4. 세션 관리를 위한 내장 슬래시 커맨드 사용
5. 일반적인 개발 워크플로를 위한 스킬 설계
6. 스킬 vs 훅 vs CLAUDE.md 중 언제 무엇을 사용할지 결정

---

## 목차

1. [스킬이란 무엇인가?](#1-스킬이란-무엇인가)
2. [스킬 vs 훅 vs CLAUDE.md](#2-스킬-vs-훅-vs-claudemd)
3. [SKILL.md 파일 구조](#3-skillmd-파일-구조)
4. [스킬 저장 위치](#4-스킬-저장-위치)
5. [첫 번째 스킬 만들기](#5-첫-번째-스킬-만들기)
6. [내장 슬래시 커맨드](#6-내장-슬래시-커맨드)
7. [실용적인 스킬 예제](#7-실용적인-스킬-예제)
8. [자동 호출 트리거](#8-자동-호출-트리거)
9. [스킬 호출 방법](#9-스킬-호출-방법)
10. [스킬 모범 사례](#10-스킬-모범-사례)
11. [연습 문제](#11-연습-문제)
12. [다음 단계](#12-다음-단계)

---

## 1. 스킬이란 무엇인가?

**스킬(Skill)**은 Claude Code에 대한 구조화된 명령을 담고 있는 YAML 프론트매터가 포함된 Markdown 파일입니다. 스킬이 호출되면 — 사용자가 직접 호출하거나 트리거에 의해 자동으로 호출될 때 — 그 내용이 대화 컨텍스트에 로드되고, Claude는 응답의 일부로 해당 명령을 따릅니다.

스킬이 유용한 이유:

- **워크플로 표준화**: 모든 팀원이 동일한 리뷰 프로세스를 따름
- **전문성 인코딩**: 기억하기 어려운 복잡한 절차를 캡처
- **반복 감소**: 매 세션마다 동일한 명령을 입력할 필요 없음
- **버전 관리 가능**: 파일로 저장되고, git에 커밋되며, PR에서 검토됨

```
스킬 없이:
  사용자: "이 코드를 리뷰해줘. 보안 문제, 성능 문제,
           에러 처리, 테스트 커버리지를 확인하고,
           우리 스타일 가이드를 따르고 있는지 봐줘.
           SQL 쿼리도 인젝션 취약점이 있는지 확인하고..."

스킬 사용:
  사용자: /review
  (Claude가 완전한 리뷰 체크리스트를 자동으로 로드)
```

---

## 2. 스킬 vs 훅 vs CLAUDE.md

이 세 가지 설정 메커니즘은 서로 다른 목적을 가집니다. 각각을 언제 사용할지 이해하는 것이 효과적인 Claude Code 설정의 핵심입니다.

### 비교표

| 측면 | CLAUDE.md | 훅(Hooks) | 스킬(Skills) |
|------|-----------|-----------|------------|
| **형식** | Markdown (자유 형식) | JSON (구조화됨) | Markdown + YAML 프론트매터 |
| **활성화 시점** | 항상 (모든 세션) | 도구 이벤트 발생 시 | 호출될 때 |
| **성격** | 컨텍스트/제안 | 결정론적 명령 | 구조화된 명령 |
| **강제성** | 모델 재량 | 항상 실행 | 로드될 때 모델이 따름 |
| **호출 방식** | 자동 | 이벤트 트리거 | 수동 또는 자동 트리거 |
| **범위** | 프로젝트 전체 컨텍스트 | 특정 도구 동작 | 특정 작업/워크플로 |

### 결정 가이드

```
"프로젝트에 대해 Claude가 항상 알아야 하는 것"
  → CLAUDE.md

"파일이 편집될 때마다 이것이 실행되어야 함"
  → 훅 (PostToolUse)

"코드 리뷰를 요청할 때 이 체크리스트를 따라야 함"
  → 스킬

"rm -rf는 절대 허용하지 않음"
  → 설정 (deny rule)

"모든 편집 후 코드를 포맷"
  → 훅 (PostToolUse)

"배포 시 이 10단계를 순서대로 따라야 함"
  → 스킬
```

### 구체적인 예시

| 요구사항 | 구현 방법 |
|---------|---------|
| "4칸 들여쓰기를 사용한다" | CLAUDE.md |
| "모든 편집 후 Prettier 실행" | 훅 |
| "코드 리뷰는 8개 특정 영역을 확인해야 함" | 스킬 |
| "항상 컨벤셔널 커밋(conventional commit) 사용" | 스킬 (커밋 시 자동 호출) |
| "모든 sudo 커맨드 차단" | 설정 (deny rule) |
| "우리 API는 REST 컨벤션을 따른다" | CLAUDE.md |
| "배포는 5단계를 순서대로 요구한다" | 스킬 |

---

## 3. SKILL.md 파일 구조

스킬 파일은 YAML 프론트매터가 포함된 Markdown 파일입니다. 프론트매터는 메타데이터와 트리거 조건을 정의합니다. 본문에는 스킬이 활성화될 때 Claude가 따르는 명령이 포함됩니다.

### 전체 구조

```markdown
---
name: skill-name
description: 이 스킬이 하는 일에 대한 간단한 설명
auto_invoke:
  - when: "패턴 또는 조건"
---

# 스킬 제목

이 스킬이 호출될 때 Claude가 따르는 명령.

## 1단계: ...

상세 명령...

## 2단계: ...

추가 명령...
```

### 프론트매터 필드

| 필드 | 필수 여부 | 설명 |
|-----|---------|-----|
| `name` | 필수 | 스킬의 고유 식별자 (`/skill-name` 호출에 사용) |
| `description` | 필수 | 스킬 목록에 표시되는 간단한 설명 |
| `auto_invoke` | 선택 | 스킬이 자동으로 활성화되는 조건 |

### 예시: 완전한 SKILL.md

```markdown
---
name: commit
description: 잘 형식화된 컨벤셔널 커밋 생성
---

# 커밋 스킬

사용자가 변경사항을 커밋하도록 요청할 때 이 프로세스를 따르세요:

## 1. 변경사항 검토

`git status`와 `git diff --staged`를 실행하여 무엇이 커밋될지 파악하세요. 스테이징된 항목이 없다면 `git diff`를 실행하여 스테이징되지 않은 변경사항을 확인하고, 무엇을 스테이징할지 사용자에게 물어보세요.

## 2. 변경사항 분석

변경사항을 분류하세요:
- **feat**: 새 기능
- **fix**: 버그 수정
- **refactor**: 동작 변경 없는 코드 재구조화
- **docs**: 문서만 수정
- **test**: 테스트 추가 또는 수정
- **chore**: 빌드, CI, 의존성 업데이트
- **style**: 포맷, 공백, 세미콜론
- **perf**: 성능 개선

## 3. 커밋 메시지 작성

형식:
```
<type>(<scope>): <subject>

<body>

<footer>
```

규칙:
- 제목 줄: 명령형 어조, 소문자, 마침표 없음, 50자 이하
- 본문: 무엇을, 왜 했는지 설명 (어떻게는 X), 72자 줄 바꿈
- 푸터: 이슈 참조 (Fixes #123, Closes #456)

## 4. 스테이징 및 커밋

- 관련 파일만 스테이징 (모든 변경사항이 관련된 경우가 아니면 `git add .` 사용 금지)
- 형식화된 메시지로 커밋 생성
- 커밋 해시 및 요약 표시

## 5. 확인

`git log -1 --oneline`을 실행하여 커밋이 올바르게 생성되었는지 확인하세요.
```

---

## 4. 스킬 저장 위치

스킬은 설정 파일과 마찬가지로 두 가지 수준에서 저장할 수 있습니다.

### 전역 스킬 (~/.claude/skills/)

여기에 저장된 스킬은 머신의 모든 프로젝트에서 사용 가능합니다.

```
~/.claude/
├── settings.json
└── skills/
    ├── commit.md       # 어디서든 사용 가능
    ├── review.md       # 어디서든 사용 가능
    └── daily.md        # 어디서든 사용 가능
```

### 프로젝트 스킬 (.claude/skills/)

여기에 저장된 스킬은 현재 프로젝트에만 적용되며, 버전 관리에 커밋할 수 있습니다.

```
my-project/
├── .claude/
│   ├── settings.json
│   └── skills/
│       ├── deploy.md       # 프로젝트 전용 배포
│       ├── test.md         # 프로젝트 전용 테스트 워크플로
│       └── release.md      # 프로젝트 전용 릴리스 프로세스
├── CLAUDE.md
└── src/
```

### 우선순위

전역 스킬과 프로젝트 스킬의 이름이 같으면, 프로젝트 스킬이 우선합니다:

```
~/.claude/skills/commit.md          ← 전역 기본값
my-project/.claude/skills/commit.md ← 프로젝트 오버라이드 (우선 적용)
```

### 사용 가능한 스킬 목록 보기

```
> /help

사용 가능한 스킬:
  /commit   - 잘 형식화된 컨벤셔널 커밋 생성
  /review   - 코드 리뷰 체크리스트 실행
  /deploy   - 스테이징 또는 프로덕션에 배포
  /test     - 커버리지와 함께 테스트 스위트 실행
```

---

## 5. 첫 번째 스킬 만들기

처음부터 스킬을 만드는 과정을 살펴보겠습니다.

### 1단계: 스킬이 할 일 결정

프로젝트의 테스트 스위트를 실행하고, 실패를 분석하고, 수정을 도와주는 `/test` 스킬을 만들겠습니다.

### 2단계: 디렉토리 생성

```bash
# 프로젝트 스킬 디렉토리 생성
mkdir -p .claude/skills
```

### 3단계: SKILL.md 작성

`.claude/skills/test.md` 생성:

```markdown
---
name: test
description: 테스트 실행, 실패 분석, 수정 제안
---

# 테스트 스킬

프로젝트의 테스트 스위트를 실행하고 실패 해결을 도와줍니다.

## 프로세스

### 1. 전체 테스트 스위트 실행

프로젝트의 테스트 커맨드를 실행합니다:
- `package.json`이 있으면: `npm test`
- `pyproject.toml` 또는 `setup.py`가 있으면: `python -m pytest -v`
- `Cargo.toml`이 있으면: `cargo test`
- `go.mod`가 있으면: `go test ./...`
- `Makefile`에 `test` 타겟이 있으면: `make test`

### 2. 결과 보고

명확한 요약을 제공합니다:
- 전체 테스트: 통과 / 실패 / 건너뜀
- 실행 시간
- 모두 통과하면 그렇게 알리고 중지

### 3. 실패 분석

각 실패한 테스트에 대해:
1. 테스트 파일을 읽어 무엇을 기대하는지 파악
2. 테스트 대상 소스 코드 읽기
3. 실패의 근본 원인 파악
4. 명확한 설명과 함께 수정 제안

### 4. 수정 (승인 후)

사용자에게 묻습니다: "이 실패들을 수정할까요?"
- 예인 경우: 수정을 적용하고 테스트를 다시 실행
- 아니오인 경우: 분석을 보고서로 제공

### 5. 커버리지 (선택 사항)

사용자가 커버리지를 요청하면:
- 커버리지와 함께 실행: `pytest --cov=src` 또는 `npm test -- --coverage`
- 낮은 커버리지 파일 파악
- 커버되지 않은 코드 경로에 대한 테스트 케이스 제안
```

### 4단계: 스킬 테스트

```bash
claude
```

```
> /test

Claude가 스킬 명령을 로드하고 프로세스를 따릅니다:
1. 프로젝트 유형 감지
2. 적절한 테스트 커맨드 실행
3. 결과 보고
4. 실패 분석
```

---

## 6. 내장 슬래시 커맨드

Claude Code에는 스킬 설정과 무관하게 항상 사용 가능한 내장 슬래시 커맨드가 포함되어 있습니다. 이것들은 스킬이 아니라 Claude Code 세션을 제어하는 네이티브 커맨드입니다.

### 커맨드 참조

| 커맨드 | 설명 | 상세 |
|-------|-----|------|
| `/help` | 도움말 표시 | 모든 커맨드, 스킬, 사용법 팁 목록 표시 |
| `/exit` | 세션 종료 | 현재 Claude Code 세션을 종료 |
| `/clear` | 대화 초기화 | 대화 기록을 완전히 재설정 |
| `/compact` | 대화 압축 | 대화를 요약하여 컨텍스트 공간을 확보 |
| `/cost` | 세션 비용 표시 | 토큰 사용량 및 예상 비용 표시 |
| `/doctor` | 진단 실행 | 설정, 인증, 모델 접근, 훅 확인 |
| `/init` | 프로젝트 초기화 | 프로젝트 분석을 기반으로 CLAUDE.md 생성 |
| `/model` | 모델 보기/변경 | 현재 모델 표시 또는 다른 모델로 전환 |
| `/config` | 설정 보기/편집 | 모든 수준에서 병합된 설정 표시 |
| `/mode` | 권한 모드 보기/변경 | 기본, 자동 승인, 플랜 등 모드 간 전환 |

### /compact: 컨텍스트 관리

세션이 길어지면 컨텍스트 윈도가 채워집니다. `/compact`는 대화를 요약하여 핵심 정보를 보존하면서 토큰을 확보합니다.

```
> /compact

대화 압축 중...
  이전: 87,432 토큰
  이후: 12,847 토큰
  확보: 74,585 토큰 (85%)

보존된 요약:
  - 사용자 인증 모듈 작업 중
  - 로그인 속도 제한 버그 수정 완료
  - 회원가입에 입력 유효성 검사 추가 완료
  - 테스트 통과 (47/47)
```

**/compact 사용 시점**:
- Claude가 이전 컨텍스트를 잊어버리는 것을 발견할 때
- `/cost` 커맨드에서 높은 토큰 사용량이 표시될 때
- 같은 세션 내에서 다른 작업으로 전환할 때
- 세션이 30분 이상 실행된 경우

### /init: 프로젝트 부트스트래핑

```
> /init

Claude가 프로젝트를 분석하고 CLAUDE.md를 생성합니다:

감지됨:
  - 언어: TypeScript
  - 프레임워크: Next.js 14
  - 패키지 매니저: pnpm
  - 테스트 프레임워크: Jest + Playwright
  - 린터: ESLint + Prettier
  - 데이터베이스: PostgreSQL (Prisma ORM)

생성된 CLAUDE.md:
  - 프로젝트 구조 개요
  - 기술 스택 세부 사항
  - 개발 커맨드
  - 코딩 표준 (설정 파일에서 추론)
  - 테스트 안내

생성된 파일을 검토하시겠습니까? (y/n)
```

### /doctor: 문제 해결

```
> /doctor

진단 실행 중...

인증:
  ✓ API 키: 유효 (sk-ant-...7x2m)
  ✓ 계정: 활성, Claude for Work 플랜

모델 접근:
  ✓ claude-opus-4-20250514: 사용 가능
  ✓ claude-sonnet-4-20250514: 사용 가능
  ✓ claude-haiku-3-20241022: 사용 가능

설정:
  ✓ 전역 설정: ~/.claude/settings.json (유효)
  ✓ 프로젝트 설정: .claude/settings.json (유효)
  ✓ CLAUDE.md: 발견됨 (1,247 토큰)

훅:
  ✓ PostToolUse: 훅 2개 설정됨
  ✗ 훅 "prettier" 테스트: npx prettier를 찾을 수 없음
    제안: `npm install --save-dev prettier` 실행

스킬:
  ✓ 프로젝트 스킬 3개: commit, review, test
  ✓ 전역 스킬 1개: daily

네트워크:
  ✓ API 연결: 142ms 지연시간

1개의 문제 발견됨.
```

---

## 7. 실용적인 스킬 예제

### 스킬: 코드 리뷰 (/review)

```markdown
---
name: review
description: 팀 표준을 따르는 종합적인 코드 리뷰
---

# 코드 리뷰 스킬

지정된 파일 또는 최근 변경사항에 대해 철저한 코드 리뷰를 수행합니다.

## 범위

사용자가 파일을 지정하면 해당 파일을 리뷰합니다. 그렇지 않으면:
1. `git diff --name-only HEAD~1`을 실행하여 최근 변경된 파일 찾기
2. `git diff HEAD~1`을 실행하여 실제 변경사항 확인
3. 변경된 코드만 리뷰 (전체 파일이 아님)

## 리뷰 체크리스트

### 1. 정확성
- 코드가 의도한 대로 작동하는가?
- 오프바이원(off-by-one) 오류, 널 포인터 위험, 경쟁 조건이 있는가?
- 에러 케이스가 처리되는가?
- 엣지 케이스가 고려되었는가?

### 2. 보안
- SQL 인젝션(SQL injection), XSS, CSRF 취약점이 있는가?
- 입력이 유효성 검사되고 정제되는가?
- 비밀 정보가 하드코딩되어 있는가?
- 필요한 곳에 인증/권한 검사가 있는가?

### 3. 성능
- N+1 쿼리 문제가 있는가?
- 불필요한 루프나 계산이 있는가?
- 적절한 곳에 캐싱이 사용되는가?
- 대용량 데이터셋이 페이지네이션되는가?

### 4. 가독성
- 변수와 함수 이름이 설명적인가?
- 코드가 자기 문서화되어 있는가?
- 복잡한 부분에 주석이 있는가?
- 코드가 DRY(Don't Repeat Yourself) 원칙을 따르는가?

### 5. 테스트
- 새로운/변경된 코드에 대한 테스트가 있는가?
- 엣지 케이스가 테스트되는가?
- 테스트 이름이 설명적인가?

### 6. 아키텍처
- 코드가 프로젝트의 아키텍처 패턴을 따르는가?
- 의존성이 올바른 방향으로 흐르는가?
- 코드가 올바른 모듈/레이어에 있는가?

## 출력 형식

각 발견 사항에 대해 다음을 제공합니다:
- **심각도**: Critical(치명적) / Warning(경고) / Suggestion(제안) / Nitpick(사소한 지적)
- **위치**: 파일 및 라인 참조
- **문제**: 문제에 대한 명확한 설명
- **제안**: 코드 예제가 포함된 구체적인 권장 사항

심각도별 총 발견 건수 및 전반적인 평가로 요약을 마무리합니다.
```

### 스킬: 배포 (/deploy)

```markdown
---
name: deploy
description: 스테이징 또는 프로덕션에 애플리케이션 배포
---

# 배포 스킬

배포 프로세스를 단계별로 안내합니다.

## 배포 전 검사

배포 전에 다음을 확인합니다:

1. **브랜치**: `main` (프로덕션) 또는 `develop` (스테이징)이어야 함
   - `git branch --show-current` 실행
   - 잘못된 브랜치인 경우 경고하고 중지

2. **클린 상태**: 커밋되지 않은 변경사항이 없어야 함
   - `git status` 실행
   - 더티(dirty) 상태이면 경고하고 중지

3. **테스트**: 모든 테스트를 통과해야 함
   - `npm test` 실행
   - 실패가 있으면 경고하고 중지

4. **빌드**: 프로젝트가 성공적으로 빌드되어야 함
   - `npm run build` 실행
   - 빌드 실패 시 경고하고 중지

## 배포 단계

### 스테이징 (develop 브랜치)

```bash
# 1. 최신 풀
git pull origin develop

# 2. 빌드
npm run build

# 3. 스테이징에 배포
npm run deploy:staging

# 4. 스모크 테스트 실행
npm run test:smoke -- --env=staging

# 5. 보고
echo "스테이징 배포 완료"
```

### 프로덕션 (main 브랜치)

```bash
# 1. 릴리스 태그 생성
VERSION=$(node -p "require('./package.json').version")
git tag -a "v$VERSION" -m "Release v$VERSION"

# 2. 빌드
NODE_ENV=production npm run build

# 3. 배포
npm run deploy:production

# 4. 스모크 테스트 실행
npm run test:smoke -- --env=production

# 5. 태그 푸시
git push origin "v$VERSION"

# 6. 보고
echo "프로덕션 배포 v$VERSION 완료"
```

## 배포 후

1. 배포 URL이 응답하는지 확인
2. 에러 모니터링 확인 (설정된 경우)
3. 사용자에게 성공 또는 실패 보고
```

### 스킬: 문서화 (/docs)

```markdown
---
name: docs
description: 코드 변경사항에 대한 문서 생성 또는 업데이트
---

# 문서화 스킬

최근 코드 변경사항을 기반으로 문서를 생성하거나 업데이트합니다.

## 프로세스

### 1. 변경사항 파악

`git diff --name-only HEAD~1`을 실행하여 변경된 파일을 확인합니다.

### 2. JSDoc/독스트링(Docstring) 업데이트

변경된 각 함수에 대해:
- 독스트링/JSDoc 주석이 있는지 확인
- 시그니처가 변경된 경우 파라미터 설명 업데이트
- 반환 타입 설명 업데이트
- 새 에러 조건에 대한 @throws/@raises 추가
- 공개 API 함수에 사용 예제 추가

### 3. README 업데이트

변경사항이 다음에 영향을 미치는 경우:
- 설치 단계 → README 설치 섹션 업데이트
- API 엔드포인트 → API 문서 업데이트
- 설정 → 설정 섹션 업데이트
- 의존성 → 사전 요구사항 업데이트

### 4. CHANGELOG 업데이트

"Unreleased" 섹션 아래에 항목을 추가합니다:
```markdown
## [Unreleased]

### Added
- 새 기능 설명

### Changed
- 변경사항 설명

### Fixed
- 버그 수정 설명
```

### 5. 링크 확인

문서의 모든 내부 링크가 유효한지 확인합니다:
- 상대 파일 링크가 존재하는지
- 앵커 링크가 헤딩과 일치하는지
- 외부 URL에 접근 가능한지
```

---

## 8. 자동 호출 트리거

스킬은 특정 조건이 충족될 때 사용자가 명시적으로 슬래시 커맨드를 입력하지 않아도 자동으로 활성화되도록 설정할 수 있습니다.

### 자동 호출 설정

```markdown
---
name: commit
description: 표준화된 커밋 메시지
auto_invoke:
  - when: "사용자가 커밋을 요청함"
  - when: "사용자가 git commit을 언급함"
---
```

`when` 필드에는 트리거 조건에 대한 자연어 설명이 포함됩니다. Claude는 사용자의 메시지가 조건과 일치하는지 평가하고 일치하면 스킬을 로드합니다.

### 자동 호출 트리거 예시

**커밋 스킬**:

```yaml
auto_invoke:
  - when: "사용자가 변경사항을 커밋하도록 요청함"
  - when: "사용자가 git 커밋을 생성하려 함"
```

**리뷰 스킬**:

```yaml
auto_invoke:
  - when: "사용자가 코드 리뷰를 요청함"
  - when: "사용자가 변경사항 또는 PR을 리뷰하려 함"
```

**테스트 스킬**:

```yaml
auto_invoke:
  - when: "사용자가 테스트 실행을 요청함"
  - when: "사용자가 테스트 실패를 언급함"
```

### 자동 호출 사용 시점

자동 호출은 사용자가 자연어로 자주 요청하는 일반적인 작업에 해당하는 스킬에 가장 적합합니다:

```
자동 호출에 적합한 후보:
  ✓ 커밋 컨벤션 ("이것 커밋해줘", "변경사항 저장해줘" 트리거)
  ✓ 코드 리뷰 ("이것 리뷰해줘", "코드 확인해줘" 트리거)
  ✓ 테스트 실행기 ("테스트 실행해줘", "테스트 통과하는지 확인해줘" 트리거)

자동 호출에 적합하지 않은 후보:
  ✗ 배포 (명시적이고 의도적으로 이루어져야 함)
  ✗ 데이터베이스 마이그레이션 (실수로 트리거되기에는 너무 위험)
  ✗ 릴리스 프로세스 (신중하게 시작해야 함)
```

---

## 9. 스킬 호출 방법

### 수동 호출

스킬 이름을 슬래시 커맨드로 입력합니다:

```
> /commit

Claude가 커밋 스킬을 로드하고 명령을 따릅니다.
```

```
> /review src/auth/login.ts

Claude가 리뷰 스킬을 로드하고 지정된 파일에 적용합니다.
```

```
> /deploy staging

Claude가 "staging"을 인수로 배포 스킬을 로드합니다.
```

### 스킬 인수

슬래시 커맨드 뒤에 텍스트를 입력하면 Claude에게 추가 컨텍스트로 전달됩니다. 스킬 명령과 인수가 함께 Claude의 동작을 안내합니다.

```
> /review --focus security

Claude가 리뷰 스킬을 로드하고 보안 검사를 강조합니다.
```

```
> /test tests/unit/auth/

Claude가 테스트 스킬을 로드하고 지정된 테스트 디렉토리에 집중합니다.
```

### 스킬 목록 보기

```
> /help

내장 커맨드:
  /help     - 이 도움말 메시지 표시
  /exit     - 세션 종료
  /clear    - 대화 초기화
  /compact  - 대화 압축
  /cost     - 비용 표시
  /doctor   - 진단 실행
  /init     - CLAUDE.md 초기화
  /model    - 모델 보기/변경
  /config   - 설정 보기/편집
  /mode     - 모드 보기/변경

프로젝트 스킬:
  /commit   - 잘 형식화된 컨벤셔널 커밋 생성
  /review   - 팀 표준을 따르는 종합적인 코드 리뷰
  /deploy   - 스테이징 또는 프로덕션에 애플리케이션 배포
  /test     - 테스트 실행, 실패 분석, 수정 제안

전역 스킬:
  /daily    - 아침 스탠드업 요약
```

---

## 10. 스킬 모범 사례

### 스킬을 집중적으로 유지

각 스킬은 하나의 일을 잘 해야 합니다. 스킬이 너무 많은 것을 하려고 한다면 여러 스킬로 분리하세요.

```
# 나쁜 예: 모든 것을 하는 하나의 거대한 "dev" 스킬
/dev → 테스트 실행, 코드 리뷰, 배포, 문서 작성

# 좋은 예: 집중된 스킬
/test    → 테스트 실행 및 실패 분석
/review  → 코드 변경사항 리뷰
/deploy  → 환경에 배포
/docs    → 문서 생성
```

### 명확한 단계별 명령 사용

명령이 명확한 행동을 가진 번호가 매겨진 단계로 구조화될 때 Claude가 스킬을 더 안정적으로 따릅니다.

```markdown
# 좋은 예: 명확하고 실행 가능한 단계
## 프로세스

1. `git status`를 실행하여 작업 트리 확인
2. 스테이징되지 않은 변경사항이 있으면 무엇을 스테이징할지 사용자에게 물어봄
3. `git diff --staged`를 실행하여 스테이징된 변경사항 검토
4. 아래 형식에 따라 커밋 메시지 생성
5. 커밋 생성
6. `git log -1`로 확인

# 나쁜 예: 모호한 명령
## 프로세스

좋은 커밋을 만드세요. 모범 사례를 따르세요. 제대로 보이게 하세요.
```

### 스킬에 예제 포함

스킬이 특정 형식으로 출력을 생성하는 경우, 예제를 포함하세요:

```markdown
## 커밋 메시지 형식

```
feat(auth): 로그인 엔드포인트에 속도 제한 추가

브루트 포스 공격을 방지하기 위해 15분 윈도우당 로그인
시도를 5회로 제한합니다. express-rate-limit 미들웨어 사용.

Closes #142
```

```
fix(api): 사용자 등록에서 null 이메일 처리

이메일이 null인 경우 등록 엔드포인트가 크래시됨.
400 응답과 함께 명시적인 null 검사 추가.

Fixes #256
```
```

### 스킬을 버전 관리에 포함

```bash
# 스킬을 버전 관리에 추가
git add .claude/skills/
git commit -m "팀 스킬 추가: commit, review, test, deploy"

# 팀원들이 풀할 때 자동으로 스킬 획득
git pull
# 스킬이 그들의 Claude Code 세션에서 즉시 사용 가능
```

### 스킬 기대사항 문서화

각 스킬 상단에 언제 사용할지 설명하는 간단한 주석을 추가하세요:

```markdown
---
name: release
description: 새 릴리스 생성 및 게시
---

# 릴리스 스킬

> 새 버전을 게시할 준비가 되었을 때 이 스킬을 사용하세요.
> git 태그를 생성하고, 패키지를 빌드하고, npm에 게시합니다.
> **경고**: 리모트에 푸시하고 공개적으로 게시합니다.

## 사전 릴리스 검사
...
```

### 스킬 테스트

스킬을 생성한 후 몇 가지 다른 시나리오에서 테스트하세요:

```
# 명시적 호출로 테스트
> /commit

# 인수와 함께 테스트
> /commit --amend

# 자동 호출 테스트 (설정된 경우)
> 이 변경사항 커밋해줄 수 있어?

# 엣지 케이스 테스트
> /review  (리뷰할 변경사항이 없는 경우)
> /deploy  (테스트 실패 상태인 경우)
```

---

## 11. 연습 문제

### 연습 1: 커밋 스킬 만들기

다음을 수행하는 `.claude/skills/commit.md`를 생성하세요:

1. 스테이징된 변경사항을 위해 `git status` 확인
2. diff를 분석하여 커밋 유형 결정 (feat, fix, refactor 등)
3. 컨벤셔널 커밋 메시지 생성
4. 영향받는 주요 디렉토리에 기반한 스코프(scope) 포함
5. 중요하지 않은 변경사항의 경우 본문 추가
6. 대화에서 언급된 경우 관련 이슈 참조

작은 변경사항을 만들고 `/commit`을 실행하여 테스트하세요.

### 연습 2: 리뷰 스킬 만들기

다음을 수행하는 `.claude/skills/review.md`를 생성하세요:

1. 파일 경로를 받거나 최근 git 변경사항으로 기본 설정
2. 최소 5개의 특정 코드 품질 영역 확인
3. 각 발견 사항을 심각도별로 평가 (Critical, Warning, Suggestion)
4. 구조화된 보고서 출력
5. 선택적으로 Critical 및 Warning 문제 수정 제안

### 연습 3: 리팩토링 스킬 만들기

다음을 수행하는 `.claude/skills/refactor.md`를 생성하세요:

1. 함수 또는 모듈 이름을 인수로 받음
2. 현재 구현 읽기
3. 코드 스멜(code smell) 파악 (긴 함수, 깊은 중첩, 중복)
4. 리팩토링 단계 제안
5. 각 단계 후 테스트를 실행하며 한 번에 하나씩 변경 적용
6. 변경된 내용과 이유 보고

### 연습 4: 스킬 감사

프로젝트 설정을 검토하고 다음을 파악하세요:

1. 스킬이 될 수 있는 반복적으로 수행하는 작업 세 가지
2. 스킬로 더 잘 작동할 CLAUDE.md의 현재 명령들
3. 스킬로 대체하거나 결합할 수 있는 훅
4. 전역 스킬 vs 프로젝트 전용 스킬로 만들어야 할 것들

---

## 12. 다음 단계

스킬은 일반적인 워크플로를 위한 재사용 가능한 명령 묶음을 제공합니다. 하지만 일부 작업은 단일 Claude Code 인스턴스가 효율적으로 처리하기에 너무 크거나 복잡합니다. 다음 레슨에서는 **서브에이전트(Subagents)** — Claude Code가 병렬로 하위 작업을 수행하는 자식 에이전트를 생성하는 기능 — 을 다루며, 이를 통해 복잡한 다중 파일 작업, 대규모 리팩토링, 조율된 개발 워크플로를 가능하게 합니다.

**다음**: [07. 서브에이전트와 작업 위임](./07_Subagents.md)

# 에이전트 팀(Agent Teams)

**이전**: [07. 서브에이전트와 작업 위임](./07_Subagents.md) | **다음**: [09. IDE 통합](./09_IDE_Integration.md)

---

서브에이전트가 독립적인 작업을 위임하는 데 강력하지만, 많은 실제 프로젝트는 여러 에이전트 간의 **조율된 협업**을 필요로 합니다. 에이전트 팀은 멀티에이전트 워크플로를 한 단계 더 발전시킵니다: 부모에게 보고하는 독립적인 서브에이전트 대신, 팀원들이 컨텍스트를 공유하고, 공유 작업 목록을 통해 조율하며, 실시간으로 진행 상황을 소통합니다. 이 레슨에서는 에이전트 팀의 아키텍처, 설정, 실제 적용을 다룹니다.

**난이도**: ⭐⭐⭐

**사전 지식**:
- 레슨 07: 서브에이전트와 작업 위임
- 병렬 작업 실행에 대한 이해
- 프로젝트 관리 개념에 대한 이해 (작업 목록, 업무 조율)

## 학습 목표(Learning Objectives)

이 레슨을 완료하면 다음을 할 수 있습니다:

1. 에이전트 팀과 독립적인 서브에이전트의 차이 이해
2. 팀 아키텍처 설명: 팀 리더(오케스트레이터) + 특화된 에이전트
3. 공유 작업 목록을 통해 에이전트가 작업을 조율하는 방법 설명
4. 복잡한 작업을 위한 에이전트 팀 설정 및 구성
5. 팀원 역할과 기능을 적절하게 정의
6. 실제 시나리오에 에이전트 팀 적용 (마이그레이션, 리뷰, 문서화)
7. 멀티에이전트 워크플로의 제한사항 및 비용 영향 파악
8. 에이전트 팀이 가치를 더하는 경우와 더 간단한 접근 방식으로 충분한 경우 결정

---

## 목차

1. [에이전트 팀이란?](#1-에이전트-팀이란)
2. [에이전트 팀 vs. 서브에이전트](#2-에이전트-팀-vs-서브에이전트)
3. [팀 아키텍처](#3-팀-아키텍처)
4. [공유 작업 목록](#4-공유-작업-목록)
5. [에이전트 간 소통](#5-에이전트-간-소통)
6. [에이전트 팀 설정](#6-에이전트-팀-설정)
7. [팀원 역할 정의](#7-팀원-역할-정의)
8. [실용적인 예시](#8-실용적인-예시)
9. [제한사항과 제약](#9-제한사항과-제약)
10. [비용 고려사항](#10-비용-고려사항)
11. [팀을 사용하지 말아야 할 때](#11-팀을-사용하지-말아야-할-때)
12. [연습 문제](#12-연습-문제)
13. [참고 자료](#13-참고-자료)

---

## 1. 에이전트 팀이란?

**에이전트 팀(Agent Team)**은 팀 리더(오케스트레이터)가 조율하는, 공유 작업에 협력하는 특화된 AI 에이전트 그룹입니다. 고립된 상태에서 작업하는 독립적인 서브에이전트와 달리, 팀원들은 서로의 진행 상황을 인지하고 그에 맞게 작업을 조정할 수 있습니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                        에이전트 팀                              │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    팀 리더 (Opus)                         │   │
│  │           조율, 위임, 종합                                │   │
│  └──────────┬──────────────┬──────────────┬─────────────────┘   │
│             │              │              │                      │
│             ▼              ▼              ▼                      │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐            │
│  │  특화 에이전트│ │  특화 에이전트│ │  특화 에이전트│            │
│  │     A        │ │     B        │ │     C        │            │
│  │  (보안)      │ │  (성능)      │ │  (스타일)    │            │
│  └──────┬───────┘ └──────┬───────┘ └──────┬───────┘            │
│         │                │                │                     │
│         └────────────────┴────────────────┘                     │
│                          │                                      │
│                ┌─────────▼─────────┐                            │
│                │  공유 작업 목록   │                            │
│                │  ☑ 작업 1 (완료) │                            │
│                │  ▶ 작업 2 (진행) │                            │
│                │  ☐ 작업 3        │                            │
│                │  ☐ 작업 4        │                            │
│                └───────────────────┘                            │
└─────────────────────────────────────────────────────────────────┘
```

핵심 통찰은 에이전트 팀이 인간 팀이 작동하는 방식을 모델링한다는 것입니다: 테크 리더가 프로젝트를 분해하고, 전문가에게 작업을 할당하고, 진행 상황을 모니터링하고, 결과를 통합합니다. "팀 리더" 에이전트도 동일하게 — 문제를 분해하고, 작업을 파견하고, 완료를 추적하고, 통합을 처리합니다.

---

## 2. 에이전트 팀 vs. 서브에이전트

에이전트 팀과 서브에이전트의 차이를 이해하는 것은 올바른 접근 방식을 선택하는 데 중요합니다.

### 서브에이전트: 독립적인 작업자

```
메인 세션 ──┬──▶ 서브에이전트 A (혼자 작업, 결과 보고)
            ├──▶ 서브에이전트 B (혼자 작업, 결과 보고)
            └──▶ 서브에이전트 C (혼자 작업, 결과 보고)
```

- 각 서브에이전트는 **완전히 고립된** 상태에서 작업
- 다른 서브에이전트가 무엇을 하는지 인지 불가
- 공유 작업 목록이나 조율 메커니즘 없음
- 메인 세션이 수동으로 결과를 통합해야 함
- 설정이 간단하고 경량

### 에이전트 팀: 조율된 협력자

```
팀 리더 ──┬──▶ 에이전트 A ──┐
          ├──▶ 에이전트 B ──┤──▶ 공유 작업 목록 + 소통
          └──▶ 에이전트 C ──┘
```

- 에이전트가 팀의 전체 작업을 **인지**
- **공유 작업 목록**으로 조율 가능
- 팀 리더가 **조율**하고 충돌 해결
- 에이전트가 다른 에이전트의 진행에 따라 **적응** 가능
- 설정이 더 복잡하고 오버헤드가 높음

### 비교표

| 차원 | 서브에이전트 | 에이전트 팀 |
|-----|-----------|----------|
| 컨텍스트 공유 | 없음 (격리됨) | 작업 목록 및 팀 리더를 통해 공유 |
| 조율 | 수동 (부모에 의해) | 자동 (팀 리더에 의해) |
| 소통 | 부모에게만 보고 | 진행 업데이트가 팀에 표시 |
| 충돌 해결 | 부모가 처리 | 팀 리더가 처리 |
| 설정 복잡도 | 낮음 | 높음 |
| 토큰 비용 | 낮음 | 높음 (조율 오버헤드) |
| 적합한 작업 | 독립적, 병렬화 가능한 작업 | 상호 연결된, 협력적인 작업 |
| 실패 처리 | 부모가 개별 에이전트 재시도 | 팀 리더가 재할당 또는 적응 |

### 각 접근 방식이 유리한 경우

**서브에이전트가 유리한 경우** — 작업이 진정으로 독립적일 때:
- 10개 파일을 병렬로 번역 (각 파일이 자기 완결적)
- 코드베이스 전체에서 다른 패턴 검색
- 별도 모듈에서 테스트 실행

**에이전트 팀이 유리한 경우** — 작업이 상호 연결될 때:
- 한 모듈의 변경이 다른 모듈에 영향을 미치는 코드베이스 마이그레이션
- 여러 관점이 필요한 종합적인 코드 리뷰
- 프론트엔드, 백엔드, 데이터베이스에 걸쳐 있는 기능 구축

---

## 3. 팀 아키텍처

### 팀 리더 (오케스트레이터)

팀 리더는 일반적으로 Opus 수준의 에이전트로, 다음을 담당합니다:

1. **작업 분해(Task Decomposition)**: 전체 목표를 구체적인 작업 항목으로 분해
2. **에이전트 할당**: 어떤 전문가가 어떤 작업을 처리할지 결정
3. **진행 모니터링**: 완료 추적 및 블로커 파악
4. **통합**: 전문가의 출력을 일관된 결과로 결합
5. **충돌 해결**: 겹치는 편집이나 상충하는 출력 처리
6. **품질 보증**: 작업이 요구사항을 충족하는지 확인

```python
# 팀 리더 에이전트는 전체 컨텍스트 인식으로 작동
# 공유 작업 목록을 유지하고 작업을 조율

# 팀 리더의 mental model:
"""
전체 목표: REST API에서 GraphQL로 마이그레이션

작업 분해:
1. 스키마 설계 에이전트 → 기존 모델에서 GraphQL 타입 정의
2. 리졸버 에이전트 → 라우트 핸들러에서 리졸버 구현
3. 테스트 에이전트 → GraphQL 엔드포인트용 통합 테스트 생성
4. 문서화 에이전트 → GraphQL용 API 문서 업데이트

의존성:
- 리졸버 에이전트는 스키마 설계 에이전트의 출력이 필요
- 테스트 에이전트는 스키마와 리졸버 출력이 모두 필요
- 문서화 에이전트는 스키마로 시작하고 리졸버 후 업데이트 가능
"""
```

### 특화 에이전트

특화 에이전트는 도메인별 기능을 가진 집중화된 작업자입니다. 각 전문가는:

- 명확한 **역할 정의**를 가짐 (무엇을 하고 무엇을 하지 않는지)
- 공유 작업 목록에서 **할당된 작업**을 수행
- **진행 상황과 발견사항**을 팀 리더에게 보고
- 팀 리더 개입이 필요한 **문제를 표시** 가능

### 소통 흐름

```
┌──────────────────────────────────────────────────────────────┐
│                         소통 흐름                            │
│                                                              │
│  팀 리더                                                     │
│  │                                                           │
│  ├──▶ "에이전트 A: 사용자, 제품, 주문에 대한                 │
│  │     데이터베이스 스키마를 설계하세요.                     │
│  │     작업이 완료되면 표시하세요."                          │
│  │                                                           │
│  │  에이전트 A:                                              │
│  │  └──▶ "스키마 설계 완료. 마이그레이션 파일 3개 생성.      │
│  │        참고: 'orders' 테이블에 다형적인                   │
│  │        'payment_type' 컬럼이 필요함 — 에이전트 B에        │
│  │        표시합니다."                                       │
│  │                                                           │
│  ├──▶ "에이전트 B: 결제 모듈을 구현하세요. 에이전트 A의      │
│  │     참고사항: orders 테이블에 다형적인 payment_type 있음"  │
│  │                                                           │
│  │  에이전트 B:                                              │
│  │  └──▶ "결제 모듈 구현 완료. 테스트 통과.                 │
│  │        발견됨: 비동기 결제 알림을 위한                    │
│  │        웹훅 핸들러가 필요합니다."                         │
│  │                                                           │
│  ├──▶ "에이전트 C: 결제 알림을 위한 웹훅 핸들러              │
│  │     구현하세요..." (에이전트 B의 발견에 기반한 새 작업)   │
│  │                                                           │
└──────────────────────────────────────────────────────────────┘
```

---

## 4. 공유 작업 목록

공유 작업 목록은 에이전트 팀을 단순한 병렬 서브에이전트 이상으로 만드는 조율 메커니즘입니다. 어떤 작업이 보류 중이고, 진행 중이고, 완료되었는지에 대한 가시성을 제공합니다.

### 작업 목록 구조

```
┌────────────────────────────────────────────────────────────────┐
│  공유 작업 목록: "REST API에서 GraphQL로 마이그레이션"          │
│                                                                │
│  ☑ 1. 기존 REST 엔드포인트 감사          [스키마 에이전트]      │
│  ☑ 2. GraphQL 타입 정의 설계            [스키마 에이전트]      │
│  ▶ 3. 사용자 리졸버 구현                [리졸버 에이전트]      │
│  ▶ 4. 제품 리졸버 구현                  [리졸버 에이전트]      │
│  ☐ 5. 주문 리졸버 구현                  [리졸버 에이전트]      │
│  ☐ 6. 통합 테스트 작성                  [테스트 에이전트]      │
│  ☐ 7. API 문서 업데이트                 [문서 에이전트]        │
│  ☐ 8. GraphQL 플레이그라운드 설정       [리졸버 에이전트]      │
│  ☑ 9. Apollo Server 설정               [스키마 에이전트]      │
│                                                                │
│  범례: ☑ = 완료, ▶ = 진행 중, ☐ = 보류                        │
└────────────────────────────────────────────────────────────────┘
```

### 에이전트가 작업 목록을 업데이트하는 방법

팀 리더는 `TodoWrite` 도구를 사용하여 작업 목록을 생성하고 관리합니다. 에이전트가 작업을 완료하면, 팀 리더가 작업 상태를 업데이트합니다:

```python
# 팀 리더가 초기 작업 목록 생성
TodoWrite(todos=[
    {"content": "기존 REST 엔드포인트 감사",
     "status": "pending",
     "activeForm": "기존 REST 엔드포인트 감사 중"},
    {"content": "GraphQL 타입 정의 설계",
     "status": "pending",
     "activeForm": "GraphQL 타입 정의 설계 중"},
    {"content": "사용자 리졸버 구현",
     "status": "pending",
     "activeForm": "사용자 리졸버 구현 중"},
    # ... 더 많은 작업
])
```

### 작업 의존성

팀 리더는 작업 할당 순서를 제어하여 의존성을 관리합니다:

```
작업 1 (스키마) ──┐
                   ├──▶ 작업 3 (리졸버) ──▶ 작업 6 (테스트)
작업 2 (설정) ──┘                              │
                                               ▼
                                         작업 7 (문서)
```

팀 리더는 사전 요구사항이 완료될 때까지 의존 작업이 시작되지 않도록 보장합니다:

```python
# 팀 리더 로직 (개념적):
# 1. 작업 1-2를 위해 스키마 에이전트 실행
# 2. 작업 1-2가 완료될 때까지 대기
# 3. 스키마 에이전트 출력을 사용하여 작업 3-5를 위해 리졸버 에이전트 실행
# 4. 작업 3-5가 완료될 때까지 대기
# 5. 작업 6을 위해 테스트 에이전트와 작업 7을 위해 문서 에이전트 실행 (병렬)
```

---

## 5. 에이전트 간 소통

에이전트가 직접 서로 통신할 수 없으므로 (별도의 컨텍스트 윈도우이기 때문에), 모든 소통은 팀 리더를 통해 이루어집니다.

### 소통 패턴

**1. 팀 리더가 라우터 역할**

팀 리더는 에이전트로부터 출력을 받아 관련 정보를 다른 에이전트에게 전달합니다:

```
에이전트 A 출력: "모델에서 순환 의존성 3개 발견"
     │
     ▼
팀 리더: 이 발견사항을 에이전트 B의 프롬프트에 포함
     │
     ▼
에이전트 B 프롬프트: "...참고: 에이전트 A가 다음에서 순환 의존성을 발견했습니다:
                 User→Order→User, Product→Category→Product,
                 Payment→Order→Payment. 리팩토링 계획에 이를 반영하세요."
```

**2. 진행 상황 방송**

팀 리더는 새 에이전트 작업을 시작할 때 전반적인 진행 상황을 요약합니다:

```python
Task(
    subagent_type="general-purpose",
    prompt="""팀 진행 상황 업데이트:
    - 스키마 설계: 완료 (3가지 타입 정의: User, Product, Order)
    - 사용자 리졸버: 완료 (CRUD + 인증)
    - 제품 리졸버: 진행 중 (다른 에이전트가 처리 중)

    작업: src/graphql/resolvers/orders.js에 주문 리졸버 구현
    Order 타입은 User 및 Product 타입을 참조합니다.
    타입 정의는 src/graphql/schema/order.graphql을 참조하세요.
    사용자 리졸버에서 사용된 동일한 패턴을 따르세요."""
)
```

**3. 문제 에스컬레이션**

전문가가 해결할 수 없는 문제를 만나면, 팀 리더에게 보고합니다:

```
에이전트 B: "결제 리졸버를 구현할 수 없습니다 — Stripe API
          키가 환경 변수에 없습니다. 이것이 블로커입니다.
          필요사항: .env 파일의 STRIPE_SECRET_KEY와 STRIPE_WEBHOOK_SECRET"

팀 리더: 다음 중 결정:
  - 다른 에이전트가 Stripe 설정을 담당하는 새 작업 생성
  - 직접 처리
  - 사용자에게 누락된 자격증명 요청
```

---

## 6. 에이전트 팀 설정

### 1단계: 전체 목표 정의

명확하고 잘 범위가 정해진 목표로 시작하세요:

```python
team_goal = """
/opt/projects/myapp/의 웹 애플리케이션에 대한 종합적인 보안 감사를 수행합니다.
감사는 다음을 포함해야 합니다:
1. 일반적인 취약점에 대한 정적 코드 분석
2. 의존성 취약점 스캐닝
3. 인증 및 권한 부여 검토
4. API 엔드포인트 보안 평가
5. 설정 및 비밀 관리 검토

결과물: 심각도(Critical/High/Medium/Low)별로 분류된 발견사항과
수정 단계가 포함된 보안 보고서.
"""
```

### 2단계: 팀 구조 설계

필요한 전문가를 결정하세요:

```python
team_structure = {
    "team_lead": {
        "model": "opus",
        "role": "보안 감사 조율, 발견사항 종합"
    },
    "specialists": [
        {
            "name": "코드 분석가",
            "model": "sonnet",
            "focus": "취약점에 대한 소스 코드 정적 분석"
        },
        {
            "name": "의존성 감사자",
            "model": "sonnet",
            "focus": "알려진 CVE에 대한 모든 의존성 확인"
        },
        {
            "name": "인증 검토자",
            "model": "sonnet",
            "focus": "인증 및 권한 부여 로직 검토"
        },
        {
            "name": "API 테스터",
            "model": "sonnet",
            "focus": "API 엔드포인트 보안 평가 (헤더, CORS, 속도 제한)"
        }
    ]
}
```

### 3단계: 작업 목록 생성

팀 리더가 목표를 구체적인 작업으로 분해합니다:

```python
TodoWrite(todos=[
    {"content": "인젝션 취약점 소스 코드 스캔 (SQL, XSS, 커맨드)",
     "status": "pending",
     "activeForm": "인젝션 취약점 스캔 중"},
    {"content": "알려진 CVE에 대한 npm/pip 의존성 감사",
     "status": "pending",
     "activeForm": "CVE에 대한 의존성 감사 중"},
    {"content": "JWT 구현 및 세션 관리 검토",
     "status": "pending",
     "activeForm": "JWT 및 세션 관리 검토 중"},
    {"content": "누락된 인증, 속도 제한, CORS에 대한 API 엔드포인트 확인",
     "status": "pending",
     "activeForm": "API 엔드포인트 보안 확인 중"},
    {"content": "하드코딩된 비밀 및 잘못 설정된 환경 변수 스캔",
     "status": "pending",
     "activeForm": "하드코딩된 비밀 스캔 중"},
    {"content": "경로 탐색 및 타입 유효성 검사를 위한 파일 업로드 처리 검토",
     "status": "pending",
     "activeForm": "파일 업로드 보안 검토 중"},
    {"content": "심각도 등급과 함께 발견사항을 보안 보고서로 컴파일",
     "status": "pending",
     "activeForm": "보안 보고서 컴파일 중"}
])
```

### 4단계: 실행 및 조율

```python
# 1단계: 독립적인 분석 작업 (병렬)
code_analysis = Task(
    subagent_type="general-purpose",
    model="sonnet",
    prompt="""당신은 보안 감사 팀의 코드 분석가입니다.
    /opt/projects/myapp/src/의 모든 소스 파일을 다음에 대해 스캔하세요:
    1. SQL 인젝션 (raw 쿼리, SQL의 문자열 연결)
    2. XSS (이스케이프되지 않은 출력, innerHTML 사용)
    3. 커맨드 인젝션 (exec, system, eval)
    4. 경로 탐색 (파일 경로의 사용자 입력)
    5. 안전하지 않은 역직렬화 (pickle, yaml.load)

    각 발견 사항에 대해 다음을 보고하세요:
    - 파일 경로 및 줄 번호
    - 취약점 유형 (알려진 경우 CWE ID)
    - 심각도 (Critical/High/Medium/Low)
    - 취약점을 보여주는 코드 스니펫
    - 권장 수정사항

    철저하게 검색하세요 — 모든 소스 파일을 확인하세요."""
)

dependency_audit = Task(
    subagent_type="general-purpose",
    model="sonnet",
    prompt="""당신은 보안 감사 팀의 의존성 감사자입니다.
    알려진 취약점에 대해 모든 프로젝트 의존성을 확인하세요:
    1. package.json / requirements.txt / Pipfile 읽기
    2. 가능한 경우 'npm audit' 또는 'pip-audit' 실행
    3. 알려진 CVE가 있는 오래된 패키지 확인
    4. 유지 관리되지 않거나 더 이상 사용되지 않는 패키지 파악

    보고 형식: 패키지 이름, 버전, CVE ID, 심각도, 수정 버전."""
)

auth_review = Task(
    subagent_type="general-purpose",
    model="sonnet",
    prompt="""당신은 보안 감사 팀의 인증 검토자입니다.
    인증 및 권한 부여 시스템을 검토하세요:
    1. 비밀번호가 어떻게 저장되는가? (bcrypt/argon2/평문?)
    2. JWT: 알고리즘, 만료, 리프레시 토큰 로테이션
    3. 세션 관리: 저장, 고정 방지
    4. 권한 부여: RBAC/ABAC 구현, 권한 상승 위험
    5. 비밀번호 재설정 흐름: 토큰 생성, 만료, 재사용 방지

    src/auth/, src/middleware/ 및 관련 설정의 모든 파일을 확인하세요."""
)

# 2단계: 팀 리더가 결과를 종합 (1단계 완료 후)
# 팀 리더가 모든 출력을 읽고 최종 보고서를 컴파일
```

---

## 7. 팀원 역할 정의

효과적인 에이전트 팀은 명확한 역할 정의가 필요합니다. 각 팀원은 다음을 가져야 합니다:

### 역할 정의 템플릿

```yaml
# 팀원 역할 정의 템플릿
name: "역할 이름"
responsibilities:
  - 특정 작업 영역 1
  - 특정 작업 영역 2
boundaries:
  - 이 에이전트가 해서는 안 될 것
  - 범위 외 파일/모듈
input:
  - 에이전트에게 필요한 컨텍스트
output:
  - 에이전트가 생성해야 하는 것
  - 예상 형식
```

### 예시: 코드 리뷰 팀

```yaml
# 팀원 1: 보안 검토자
name: "보안 검토자"
responsibilities:
  - 코드 변경사항의 보안 취약점 파악
  - OWASP Top 10 문제 확인
  - 입력 유효성 검사 및 출력 인코딩 검증
  - 인증/권한 부여 변경사항 검토
boundaries:
  - 코드 스타일이나 포맷팅을 검토하지 않음
  - 성능 최적화를 제안하지 않음
  - 어떤 코드도 수정하지 않음
output:
  - 심각도 등급이 있는 보안 발견사항 목록
  - 각 발견사항: 파일, 줄, 문제, 수정사항 포함
```

```yaml
# 팀원 2: 성능 검토자
name: "성능 검토자"
responsibilities:
  - 성능 병목 파악
  - N+1 쿼리, 불필요한 할당 확인
  - 알고리즘 복잡도 검토
  - 캐싱 전략 검증
boundaries:
  - 보안 측면을 검토하지 않음
  - 코드 스타일을 검토하지 않음
  - 어떤 코드도 수정하지 않음
output:
  - 영향 등급이 있는 성능 발견사항 목록
  - 해당되는 경우 벤치마크 제안 포함
```

```yaml
# 팀원 3: 스타일 검토자
name: "스타일 검토자"
responsibilities:
  - 프로젝트 코딩 표준 준수 확인
  - 명명 규칙 검증
  - 문서화 및 주석 검토
  - DRY 위반 및 코드 스멜 확인
boundaries:
  - 보안 또는 성능을 검토하지 않음
  - 어떤 코드도 수정하지 않음
output:
  - 스타일 문제 목록
  - 위반된 코딩 표준 참조
```

```yaml
# 팀 리더: 리뷰 코디네이터
name: "리뷰 코디네이터"
responsibilities:
  - 전문가에게 리뷰 작업 할당
  - 모든 검토자의 발견사항 컴파일
  - 발견사항 우선순위 지정 및 중복 제거
  - 최종 리뷰 보고서 생성
  - 상충하는 권고사항 파악
output:
  - 통합된 코드 리뷰 보고서
  - 필요한 변경사항의 우선순위 목록
```

---

## 8. 실용적인 예시

### 예시 1: 대규모 코드베이스 마이그레이션

**시나리오**: 50,000줄의 Python 2 코드베이스를 Python 3으로 마이그레이션.

```
팀 구조:
├── 팀 리더 (Opus): 마이그레이션 순서 계획, 진행 추적
├── 구문 에이전트 (Sonnet): print 문, 유니코드, 나눗셈
├── 라이브러리 에이전트 (Sonnet): 더 이상 사용되지 않는 라이브러리 교체
├── 테스트 에이전트 (Sonnet): Python 3용 테스트 스위트 수정
└── 호환성 에이전트 (Sonnet): __future__ 임포트, six 래퍼 추가

워크플로:
1. 팀 리더가 코드베이스를 스캔하고 모듈 의존성 그래프 생성
2. 팀 리더가 마이그레이션 순서 결정 (리프 모듈 먼저)
3. 구문 + 라이브러리 에이전트가 독립적인 모듈을 병렬로 작업
4. 테스트 에이전트가 뒤따르며 테스트를 실행하고 수정
5. 호환성 에이전트가 이중 호환성이 필요한 공유 코드 처리
6. 팀 리더가 결과를 통합하고 회귀(regression)가 없는지 확인
```

```python
# 1단계: 분석 (Explore 서브에이전트, 병렬)
module_map = Task(
    subagent_type="explore",
    prompt="src/의 모든 Python 모듈을 임포트 의존성과 함께 매핑해줘. "
           "리프 모듈 (내부 임포트 없음) vs 핵심 모듈 파악."
)

py2_patterns = Task(
    subagent_type="explore",
    prompt="src/에서 모든 Python 2 전용 패턴 찾기: "
           "print 문, 유니코드 리터럴, 구식 클래스, "
           "dict.has_key(), 리스트를 반환하는 map/filter 등. "
           "파일별 발생 횟수 계산."
)

# 2단계: 마이그레이션 (General-Purpose 서브에이전트, 조율됨)
# 팀 리더가 1단계 결과를 사용하여 마이그레이션 순서 계획
# 그런 다음 각 모듈 그룹에 대해 에이전트 실행
```

### 예시 2: 종합적인 코드 리뷰

**시나리오**: 인증, API, 데이터베이스 레이어를 건드리는 30개 파일의 풀 리퀘스트 리뷰.

```python
# 세 가지 전문 검토자를 병렬로 실행
security_review = Task(
    subagent_type="explore",
    model="sonnet",
    prompt="""PR 파일 보안 리뷰:
    src/auth/login.py, src/auth/jwt.py, src/auth/permissions.py,
    src/api/users.py, src/api/admin.py, src/middleware/rate_limit.py

    다음 확인:
    - 인증 우회
    - 권한 부여 결함 (권한 상승)
    - 입력 유효성 검사 격차
    - 토큰 처리 문제
    - 속도 제한 효과성

    심각도 등급과 함께 발견사항 보고."""
)

performance_review = Task(
    subagent_type="explore",
    model="sonnet",
    prompt="""PR 파일 성능 리뷰:
    src/models/user.py, src/models/order.py, src/api/search.py,
    src/utils/cache.py, src/middleware/logging.py

    다음 확인:
    - N+1 쿼리 패턴
    - 누락된 데이터베이스 인덱스
    - 불필요한 데이터 로딩
    - 캐시 무효화 문제
    - 핫 경로에서의 로깅 오버헤드

    영향 추정과 함께 발견사항 보고."""
)

style_review = Task(
    subagent_type="explore",
    model="sonnet",
    prompt="""30개 PR 파일 전체 스타일 리뷰.
    프로젝트 표준: PEP 8, 타입 힌트 필수, 공개 함수에 독스트링,
    최대 줄 길이 100.

    다음 확인:
    - PEP 8 위반
    - 누락된 타입 힌트
    - 누락되거나 불충분한 독스트링
    - DRY 위반
    - 일관성 없는 명명

    중요한 문제만 보고 (사소한 지적 제외)."""
)

# 팀 리더가 세 가지 리뷰를 통합된 PR 리뷰로 컴파일
```

### 예시 3: 다국어 문서 생성

**시나리오**: 영어, 한국어, 일본어로 API 문서 생성.

```python
# 1단계: 영어 문서 생성 (권위 있는 소스)
english_docs = Task(
    subagent_type="general-purpose",
    model="opus",
    prompt="""src/api/의 모든 엔드포인트에 대한 포괄적인 API 문서를 생성해줘.
    각 라우트 핸들러를 읽고 다음이 포함된 문서를 생성:
    - 엔드포인트 URL 및 HTTP 메서드
    - 요청 파라미터 (경로, 쿼리, 본문)와 타입
    - 예제 JSON이 있는 응답 형식
    - 인증 요구사항
    - 속도 제한 세부 사항
    - 에러 응답

    리소스별 개별 Markdown 파일로 docs/api/en/에 저장."""
)

# 2단계: 병렬 번역 (영어 문서 완료 후)
korean_docs = Task(
    subagent_type="general-purpose",
    model="sonnet",
    prompt="""docs/api/en/의 모든 API 문서 파일을 한국어로 번역해줘.
    docs/api/ko/에 저장.
    규칙:
    - 코드 블록, URL, HTTP 메서드는 번역하지 않음
    - 괄호 안에 영어를 포함한 한국어 기술 용어 사용
    - 모든 포맷 및 구조 보존"""
)

japanese_docs = Task(
    subagent_type="general-purpose",
    model="sonnet",
    prompt="""docs/api/en/의 모든 API 문서 파일을 일본어로 번역해줘.
    docs/api/ja/에 저장.
    규칙:
    - 코드 블록, URL, HTTP 메서드는 번역하지 않음
    - 표준 일본어 기술 용어 사용
    - 모든 포맷 및 구조 보존"""
)
```

### 예시 4: 연구 + 구현 파이프라인

**시나리오**: 기존 HTTP API에 WebSocket 지원 추가.

```python
# 1단계: 연구 (Plan 에이전트)
research = Task(
    subagent_type="plan",
    model="opus",
    prompt="""Express.js 애플리케이션에 WebSocket 지원을 추가하는
    최적의 방법을 연구해줘.

    현재 스택: Express.js 4.x, Node.js 20, PostgreSQL, Redis
    요구사항: 실시간 알림, 라이브 데이터 피드, 채팅

    연구:
    1. ws vs socket.io vs uWebSockets — 성능, 기능, 생태계
    2. WebSocket 연결을 위한 인증 전략
    3. 여러 서버 인스턴스 간 WebSocket 확장 (Redis pub/sub?)
    4. 재연결 및 하트비트 전략
    5. 메시지 형식 표준 (JSON-RPC? 커스텀 프로토콜?)

    파일별 변경사항이 포함된 상세한 구현 계획을 제시해줘."""
)

# 2단계: 구현 (병렬 General-Purpose 에이전트)
# 연구 출력을 사용하여 구현 안내
server_impl = Task(
    subagent_type="general-purpose",
    model="sonnet",
    prompt=f"""이 구현 계획을 바탕으로:
    {research}

    WebSocket 서버 모듈 구현:
    1. 선택한 라이브러리 설치
    2. src/websocket/server.js 생성
    3. Express HTTP 서버와 통합
    4. WS 연결을 위한 인증 미들웨어 구현
    5. 멀티 인스턴스 지원을 위한 Redis pub/sub 설정"""
)

client_impl = Task(
    subagent_type="general-purpose",
    model="sonnet",
    prompt=f"""이 구현 계획을 바탕으로:
    {research}

    WebSocket 클라이언트 라이브러리 구현:
    1. src/client/websocket.js 생성
    2. 지수 백오프(exponential backoff)를 사용한 자동 재연결 구현
    3. 하트비트/핑퐁 메커니즘 추가
    4. 이벤트 구독 API 생성
    5. 사용 예제 및 문서 작성"""
)
```

---

## 9. 제한사항과 제약

### 컨텍스트 윈도우 한계

팀의 각 에이전트는 여전히 유한한 컨텍스트 윈도우를 가집니다. 매우 큰 코드베이스의 경우, 단일 에이전트조차 모든 관련 파일을 컨텍스트에 담지 못할 수 있습니다:

```
문제: 에이전트가 200개 파일을 검토해야 함
         200파일 × ~500줄 × ~4 토큰/줄 = 400K 토큰
         컨텍스트 윈도우 초과

해결책: 팀 리더가 관련 파일 그룹을 다른 에이전트에게 할당
          에이전트 A: src/api/ (50개 파일)
          에이전트 B: src/models/ (30개 파일)
          에이전트 C: src/services/ (40개 파일)
          에이전트 D: src/utils/ + src/middleware/ (80개 파일)
```

### 에이전트 간 직접 소통 불가

에이전트는 서로 직접 통신할 수 없습니다. 모든 소통은 팀 리더를 통해 이루어져야 합니다:

```
에이전트 A ──X──▶ 에이전트 B    (불가능)
에이전트 A ──▶ 팀 리더 ──▶ 에이전트 B    (실제 작동 방식)
```

이것은 다음을 의미합니다:
- 팀 리더가 정보 흐름의 병목 지점
- 팀 리더가 에이전트 간에 어떤 정보를 전달할지 결정해야 함
- 번역 과정에서 일부 컨텍스트가 불가피하게 손실됨

### 출력 충돌

여러 에이전트가 같은 파일을 수정하면 충돌이 발생할 수 있습니다:

```
에이전트 A가 src/config.js 편집: 데이터베이스 풀 설정 추가
에이전트 B가 src/config.js 편집: Redis 캐시 설정 추가
결과: 마지막 에이전트 버전이 우선; 에이전트 A의 변경사항이 손실될 수 있음
```

**완화 전략**:
- 에이전트에게 겹치지 않는 파일 소유권 할당
- 에이전트가 직접 편집하는 대신 변경사항을 제안 (diff 형태로)
- 팀 리더가 충돌하는 변경사항을 검토하고 병합
- 공유 파일에 순차적 접근 방식 사용

### 속도 제한

여러 에이전트를 동시에 실행하면 API 속도 제한에 도달할 수 있습니다:

```
10개 Sonnet 에이전트 × 빠른 도구 호출 = 잠재적인 속도 제한 에러

완화:
- 병렬 에이전트를 5-7개로 제한
- 엇갈린 실행 사용
- 팀 리더가 속도 제한 에러를 모니터링하고 필요 시 일시 중지
```

### 에이전트 신뢰성

에이전트는 잘못된 출력을 생성하거나, 엣지 케이스를 놓치거나, 명령을 잘못 이해할 수 있습니다:

```
위험: 에이전트가 코드를 잘못 수정하여 기능 손상
완화:
- 각 에이전트 작업 후 테스트 실행
- Explore 에이전트를 사용하여 General-Purpose 에이전트의 출력 검증
- 팀 리더가 최종 검토 수행
- Git 커밋을 세분화하여 쉽게 롤백 가능하게 유지
```

---

## 10. 비용 고려사항

멀티에이전트 워크플로는 단일 에이전트 작업보다 더 많은 토큰을 소비합니다. 비용 구조를 이해하면 정보에 근거한 결정을 내릴 수 있습니다.

### 토큰 비용 분류

```
단일 에이전트 워크플로:
  입력 토큰:  ~50K  (시스템 프롬프트 + 대화 + 파일 읽기)
  출력 토큰: ~10K  (응답 + 도구 호출)
  합계: ~60K 토큰

에이전트 팀 (전문가 4명 + 리더 1명):
  팀 리더:      ~30K 입력 + ~8K 출력 = ~38K
  전문가 1:     ~40K 입력 + ~10K 출력 = ~50K
  전문가 2:     ~40K 입력 + ~10K 출력 = ~50K
  전문가 3:     ~40K 입력 + ~10K 출력 = ~50K
  전문가 4:     ~40K 입력 + ~10K 출력 = ~50K
  합계: ~238K 토큰 (단일 에이전트의 약 4배)
```

### 비용 최적화 전략

**1. 작동하는 가장 저렴한 모델 사용**:

```python
# 팀 리더에는 Opus (복잡한 추론 필요)
# 전문가에는 Sonnet (집중된 작업에 충분)
# 단순하고 기계적인 작업에는 Haiku (검색, 포맷팅)

team_lead:  model="opus"      # $15/M 입력, $75/M 출력
specialist: model="sonnet"    # $3/M 입력, $15/M 출력
formatter:  model="haiku"     # $0.25/M 입력, $1.25/M 출력
```

**2. 중복 파일 읽기 최소화**:

```python
# 나쁜 예: 모든 에이전트가 같은 설정 파일 읽기
에이전트 A: src/config.js 읽기 (중복 토큰)
에이전트 B: src/config.js 읽기 (중복 토큰)
에이전트 C: src/config.js 읽기 (중복 토큰)

# 좋은 예: 팀 리더가 한 번 읽고 관련 정보를 프롬프트에 포함
팀 리더: src/config.js 읽기
에이전트 A 프롬프트: "데이터베이스는 포트 5432의 PostgreSQL, 풀 크기 20..."
에이전트 B 프롬프트: "Redis 캐시는 포트 6379, TTL 300s..."
```

**3. 에이전트 범위 엄격히 제한**:

```python
# 나쁜 예: 모호한 범위로 불필요한 탐색 발생
Task(prompt="프로젝트의 모든 것을 리뷰해줘...")

# 좋은 예: 엄격한 범위로 낭비되는 토큰 최소화
Task(prompt="SQL 인젝션에 대해서만 src/api/payments.py를 리뷰해줘. "
           "직접 가져오는 경우가 아니면 다른 파일은 읽지 마세요.")
```

**4. General-Purpose 전에 Explore 사용**:

```python
# Explore 에이전트가 더 저렴 (도구 적음, 빠른 완료)
# General-Purpose 에이전트가 해야 할 일을 좁히기 위해 사용

analysis = Task(subagent_type="explore",
                prompt="기능 X를 위해 어떤 파일이 변경되어야 하는가?")
# 파악된 특정 파일에 대해서만 General-Purpose 실행
```

---

## 11. 팀을 사용하지 말아야 할 때

에이전트 팀은 강력하지만 항상 적절한 것은 아닙니다. 다음의 경우 팀을 사용하지 마세요:

### 작업이 단순한 경우

단일 에이전트가 몇 번의 턴으로 작업을 처리할 수 있다면, 팀의 조율 오버헤드는 낭비입니다:

```
# 다음의 경우 팀을 사용하지 마세요:
- 단일 버그 수정
- 테스트 케이스 추가
- 설정 값 업데이트
- 5개 파일에서 함수 이름 변경
```

### 작업이 고도로 순차적인 경우

모든 단계가 이전 단계의 출력에 의존한다면, 활용할 병렬성이 없습니다:

```
1단계: 스키마 설계    → 2단계: 마이그레이션 생성
→ 3단계: 모델 업데이트  → 4단계: API 업데이트
→ 5단계: 테스트 업데이트 → 6단계: 문서 업데이트

이것은 서브에이전트 체인이나 단일 에이전트로 더 잘 처리됩니다.
```

### 컨텍스트 공유가 중요한 경우

에이전트가 미묘한 설계 결정에 대한 깊은 이해를 공유해야 하는 경우:

```
# 모든 결정에 걸쳐 전체 컨텍스트를 유지하는 단일 에이전트가
# 각 에이전트가 부분적인 컨텍스트를 가진 팀보다 나음
```

### 예산이 제한된 경우

에이전트 팀은 단일 에이전트보다 3-5배 더 많은 비용이 듭니다. 토큰 예산이 중요하다면, 순차적인 서브에이전트 호출을 사용하는 단일 에이전트를 대신 사용하세요.

### 빠른 결정 프레임워크

```
에이전트 팀을 사용해야 할까?

1. 조율 오버헤드를 정당화할 만큼 작업이 크가? (단일 에이전트 작업 >1시간)
   └── 아니오 → 단일 에이전트 또는 서브에이전트 사용

2. 작업을 의미 있게 병렬화할 수 있는가?
   └── 아니오 → 순차적 서브에이전트 체인 사용

3. 에이전트가 서로의 진행 상황을 인지해야 하는가?
   └── 아니오 → 독립적인 서브에이전트 사용

4. 3-5배 토큰 비용을 감당할 예산이 있는가?
   └── 아니오 → 신중한 컨텍스트 관리와 함께 단일 에이전트 사용

5. 모두 예? → 에이전트 팀 사용
```

---

## 12. 연습 문제

### 연습 1: 팀 설계

Python 프로젝트를 `unittest`에서 `pytest`로 마이그레이션하기 위한 에이전트 팀을 설계하세요. 다음을 정의하세요:
1. 팀 구조 (리더 + 전문가)
2. 공유 작업 목록 (최소 8개 작업)
3. 작업 의존성
4. 단일 에이전트 접근 방식과 비교한 예상 토큰 비용

### 연습 2: 역할 정의

새로운 REST API 엔드포인트를 추가하는 풀 리퀘스트에 대해 다음을 수행하는 3에이전트 팀의 완전한 역할 정의를 작성하세요 (7장의 템플릿 참조):
1. 코드 리뷰
2. 문서화 업데이트
3. 테스트 생성

### 연습 3: 충돌 해결

팀의 두 에이전트가 모두 `src/config.py`를 수정합니다:
- 에이전트 A가 `DATABASE_POOL_SIZE = 20` 설정을 추가
- 에이전트 B가 `CACHE_TTL = 300` 설정을 추가

두 변경사항이 모두 올바르고 필요합니다. 팀 리더가 이 충돌을 처리하기 위한 전략을 설계하세요. 다음을 고려하세요:
- 충돌 감지 방법
- 두 변경사항 병합 방법
- 향후 팀 설정에서 이를 방지하는 방법

### 연습 4: 비용 분석

다음 팀 설정을 고려하세요:
- Opus 팀 리더 1명 (예상 40K 입력 + 15K 출력 토큰)
- Sonnet 전문가 3명 (각 예상 50K 입력 + 12K 출력 토큰)
- Haiku 포맷터 1명 (예상 20K 입력 + 8K 출력 토큰)

다음을 계산하세요:
1. 총 토큰 소비
2. 총 비용 (현재 Anthropic 가격 사용)
3. 동일한 작업에 대한 단일 Sonnet 에이전트 비용 (추정)
4. "조율 프리미엄" (팀 비용 / 단일 에이전트 비용)

---

## 13. 참고 자료

- [Claude Code 문서: 멀티에이전트 워크플로](https://docs.anthropic.com/en/docs/claude-code)
- [Anthropic 연구: 멀티에이전트 조율](https://www.anthropic.com/research)
- [Anthropic 블로그: 에이전트 팀](https://www.anthropic.com/engineering)
- [멀티에이전트 시스템: 서베이](https://arxiv.org/abs/2402.01680)
- [Claude Code GitHub 저장소](https://github.com/anthropics/claude-code)

---

## 다음 단계

다음 레슨인 [IDE 통합](./09_IDE_Integration.md)에서는 멀티에이전트 오케스트레이션에서 개발자 경험으로 이동합니다. VS Code 및 JetBrains IDE 내에서 Claude Code를 사용하는 방법을 배우게 되며, 인라인 diff 리뷰와 @-멘션을 통해 에이전트 상호작용이 개발 환경의 네이티브 부분처럼 느껴지게 됩니다.

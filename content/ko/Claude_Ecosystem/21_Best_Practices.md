# 모범 사례와 패턴

**이전**: [20. 고급 개발 워크플로우](./20_Advanced_Workflows.md) | **다음**: [22. 문제 해결 및 디버깅](./22_Troubleshooting.md)

---

Claude Code를 최대한 활용하려면 기능을 아는 것 이상이 필요합니다 -- 프롬프팅(Prompting), 컨텍스트(Context) 관리, 보안, 팀 협업에 관한 효과적인 습관을 개발해야 합니다. 이 레슨은 실제 사용 경험에서 가장 영향력 있는 사례들을 즉시 적용할 수 있는 패턴으로 정리합니다.

**난이도**: ⭐⭐

**사전 요구 사항**:
- Claude Code 실무 경험 ([레슨 2-7](./02_Claude_Code_Getting_Started.md))
- CLAUDE.md 및 프로젝트 설정 이해 ([레슨 3](./03_CLAUDE_md_and_Project_Setup.md))
- 권한 모드(Permission Modes) 숙지 ([레슨 4](./04_Permission_Modes.md))
- 훅(Hooks)과 스킬(Skills) 경험 ([레슨 5-6](./05_Hooks.md))

## 학습 목표(Learning Objectives)

이 레슨을 완료하면 다음을 할 수 있습니다:

1. 정확하고 유용한 결과를 얻는 효과적인 프롬프트 작성
2. 긴 세션에서 컨텍스트를 효율적으로 관리
3. Claude Code 작업 시 보안 모범 사례 적용
4. 공유 설정을 통한 팀 협업 패턴 수립
5. 더 빠르고 집중된 세션을 위한 성능 최적화
6. 시간과 토큰을 낭비하는 일반적인 안티패턴(Anti-Pattern) 인식 및 회피

---

## 목차

1. [효과적인 프롬프트 작성](#1-효과적인-프롬프트-작성)
2. [컨텍스트 관리](#2-컨텍스트-관리)
3. [보안 모범 사례](#3-보안-모범-사례)
4. [팀 협업 패턴](#4-팀-협업-패턴)
5. [성능 최적화](#5-성능-최적화)
6. [일반적인 안티패턴](#6-일반적인-안티패턴)
7. [치트 시트: 빠른 참조](#7-치트-시트-빠른-참조)
8. [연습 문제](#8-연습-문제)

---

## 1. 효과적인 프롬프트 작성

프롬프트의 품질이 Claude Code 출력의 품질을 직접적으로 결정합니다. 잘 만들어진 프롬프트는 몇 시간의 반복 작업을 줄여줄 수 있고, 모호한 프롬프트는 토큰과 시간을 낭비합니다.

### 1.1 SCFO 프레임워크

프롬프트를 네 가지 요소로 구성하세요: **상황(Situation), 제약(Constraints), 형식(Format), 출력(Output)**.

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SCFO 프롬프트 프레임워크                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  S - 상황 (무엇을, 왜)                                               │
│  ├── 달성하려는 것                                                   │
│  ├── 필요한 이유 (더 나은 의사 결정을 위한 컨텍스트)                  │
│  └── 관련 배경 정보                                                  │
│                                                                     │
│  C - 제약 (경계)                                                     │
│  ├── 기술적 제약 (언어, 프레임워크, 버전)                             │
│  ├── 스타일 제약 (따라야 할 패턴, 관례)                               │
│  ├── 하지 말아야 할 것 (동등하게 중요)                               │
│  └── 성능/크기 요구사항                                              │
│                                                                     │
│  F - 형식 (어떻게 응답할지)                                          │
│  ├── 예상 출력 구조 (JSON, 마크다운, 코드만)                         │
│  ├── 필요한 설명 수준                                                │
│  └── 테스트, 문서 등의 포함 여부                                     │
│                                                                     │
│  O - 출력 (무엇을 생성할지)                                          │
│  ├── 생성하거나 수정할 특정 파일                                      │
│  ├── 검증 단계 (테스트 실행, 타입 검사)                              │
│  └── 성공 기준                                                      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 예시: 나쁜 프롬프트 vs 좋은 프롬프트

```
나쁜 예 (모호하고 컨텍스트 없음):
> "로그인 버그 수정해줘"

좋은 예 (구체적이고 컨텍스트 있음):
> "src/routes/auth.py의 로그인 엔드포인트가 사용자가 '+' 문자가
>  포함된 이메일(예: user+tag@gmail.com)을 입력할 때 500 오류를
>  반환합니다. 오류는 45번째 줄의 이메일 유효성 검사 정규식에 있습니다.
>  RFC 5321 호환 이메일 주소를 수용하도록 정규식을 수정하세요.
>  기존 테스트를 실행하여 다른 것이 깨지지 않는지 확인하세요."
```

```
나쁜 예 (너무 광범위):
> "코드를 더 좋게 만들어줘"

좋은 예 (구체적인 범위):
> "OrderService 클래스 (src/services/order.py) 리팩터링:
>  1. 세금 계산 로직을 별도의 TaxCalculator 클래스로 추출
>  2. 배송 규칙에 대한 중첩 if/else를 전략 패턴으로 교체
>  3. 모든 공개 메서드에 타입 힌트 추가
>  기존 테스트를 모두 통과해야 합니다."
```

```
나쁜 예 (제약 없음):
> "캐싱 레이어 추가해줘"

좋은 예 (명확한 제약):
> "GET /api/products 엔드포인트에 Redis 캐싱 추가:
>  - 캐시 키: products:{category}:{page}:{sort}
>  - TTL: 5분
>  - /api/products에 POST/PUT/DELETE 시 무효화
>  - config.redis_client의 기존 Redis 연결 사용
>  - src/services/user_service.py에서 사용된 캐싱 패턴을 따름
>  - fakeredis를 사용한 테스트 추가"
```

### 1.3 대형 작업을 단계로 분해

복잡한 작업의 경우 명시적인 단계로 분해하세요:

```
> WebSocket 알림 시스템 구현. 단계별로 진행합시다:
>
> 1단계: WebSocket 서버 설정
> - package.json에 ws 의존성 추가
> - 연결 처리가 포함된 src/websocket/server.ts 생성
> - src/app.ts의 기존 Express 서버와 통합
> - 테스트: 클라이언트가 연결하고 환영 메시지를 받을 수 있음
>
> 2단계: 인증
> - WebSocket 업그레이드 시 JWT 토큰 검증
> - 연결을 사용자 ID와 연결
> - 테스트: 인증되지 않은 연결 거부
>
> 3단계: 알림 디스패치
> - 연결된 사용자에게 이벤트를 전송하는 NotificationDispatcher 생성
> - 기존 NotificationService와 통합
> - 테스트: 주문 생성 시 구매자에게 WebSocket 이벤트 전송
>
> 1단계부터 시작하세요. 1단계 테스트가 통과할 때까지 2단계로 진행하지 마세요.
```

### 1.4 플랜 모드(Plan Mode) 효과적으로 사용

플랜 모드는 탐색과 전략을 위한 가장 강력한 도구입니다. 구현에 착수하기 전에 사용하세요:

```
> /plan 세션 기반 인증에서 JWT로 마이그레이션해야 합니다.
>       어떤 파일이 영향을 받나요? 가장 안전한 마이그레이션 순서는 무엇인가요?
>       걱정해야 할 엣지 케이스가 있나요?
```

플랜 모드가 수행하는 작업:
- 인증 관련 코드를 위해 전체 코드베이스 검색
- 의존성 및 변경 순서 파악
- 잠재적 문제 표시 (예: 마이그레이션 중 활성 세션)
- 단계별 구현 계획 제안

**플랜 모드 사용 시기:**
- 3개 이상의 파일을 건드리는 리팩터링 전
- 익숙하지 않은 코드베이스 부분을 탐색할 때
- 최선의 접근 방법을 확신할 수 없을 때
- 되돌릴 수 없는 변경 전 (데이터베이스 마이그레이션, API 호환성 파괴 변경)

**플랜 모드 생략 시기:**
- 단순하고 잘 알려진 변경 (오타 수정, 필드 추가)
- 변경해야 할 것이 정확히 알려진 작업
- 컨텍스트가 확립된 진행 중인 세션의 후속 변경

---

## 2. 컨텍스트 관리

Claude Code의 효과는 적시에 올바른 컨텍스트를 갖는 것에 크게 의존합니다. 컨텍스트를 잘 관리하면 Claude가 검색에 시간을 덜 소비하고 유용한 출력을 생성하는 데 더 많은 시간을 쓸 수 있습니다.

### 2.1 CLAUDE.md 최적화

CLAUDE.md 파일은 가장 중요한 단일 컨텍스트 문서입니다. 집중적이고 잘 구조화된 상태로 유지하세요:

```markdown
# CLAUDE.md — 모범 사례 템플릿

## 프로젝트 개요
한 단락: 프로젝트가 하는 일, 사용하는 스택.

## 아키텍처
주요 모듈과 연결 방식에 대한 간략한 설명.
구조가 명확하지 않은 경우 ASCII 다이어그램 사용.

## 주요 명령어
```bash
# 개발
npm run dev          # 개발 서버 시작 (포트 3000)
npm run test         # 모든 테스트 실행
npm run test:watch   # 감시 모드

# 데이터베이스
npm run db:migrate   # 마이그레이션 실행
npm run db:seed      # 테스트 데이터 시딩
```

## 관례
- 훅이 있는 함수형 컴포넌트 사용 (클래스 컴포넌트 사용 금지)
- API 라우트는 RESTful 명명을 따름: /api/v1/{resource}
- 소스와 함께 위치하는 테스트: Component.tsx → Component.test.tsx
- 오류 처리: src/utils/errors.ts의 AppError 클래스 사용

## 중요 파일
- src/config/index.ts — 모든 환경 설정
- src/middleware/auth.ts — JWT 검증 미들웨어
- src/types/index.ts — 공유 TypeScript 타입

## 하지 말 것
- src/generated/ 파일 수정 (OpenAPI에서 자동 생성됨)
- console.log 사용 (src/utils/logger.ts의 로거 사용)
- 번들 크기 영향을 확인하지 않고 의존성 추가
```

**포함해야 할 것:**
- Claude가 실행해야 할 명령어 (테스트, 빌드, 린트)
- 코드에서 명확하지 않은 관례
- Claude가 알아야 할 중요 파일
- 피해야 할 것 (일반적인 실수, 생성된 파일)

**포함하지 말아야 할 것:**
- 전체 API 문서 (너무 길어짐, 대신 파일 참조 사용)
- 상세한 커밋 내역이나 변경 로그
- 자주 변경되는 정보 (라이브 URL, 현재 스프린트 목표)
- 표준 설정 파일에서 사용 가능한 모든 것 (package.json, tsconfig.json)

### 2.2 파일 참조

전체 코드베이스를 검색하는 대신 Claude가 올바른 파일을 찾도록 도와주세요:

```
> 결제 처리 로직은 다음에 있습니다:
> - src/services/payment.ts (메인 서비스)
> - src/providers/stripe.ts (Stripe 통합)
> - src/providers/paypal.ts (PayPal 통합)
> 동일한 공급자 패턴을 따라 Apple Pay 지원을 추가하세요.
```

이것은 Claude에게 "결제 코드를 찾아줘"라고 요청하는 것보다 훨씬 빠릅니다 -- 검색 단계를 완전히 제거합니다.

### 2.3 세션 길이 관리

Claude Code 세션에는 컨텍스트 창(Context Window) 한계가 있습니다. 대화가 길어질수록 이전 컨텍스트가 압축되거나 손실될 수 있습니다. 이를 사전에 관리하세요:

```
┌─────────────────────────────────────────────────────────────────────┐
│                    세션 관리 전략                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  짧은 세션 (30개 메시지 미만)                                         │
│  ├── 집중된 작업에 이상적                                            │
│  ├── 전체 컨텍스트 유지                                              │
│  └── 특별한 관리 불필요                                              │
│                                                                     │
│  중간 세션 (30-80개 메시지)                                           │
│  ├── 컨텍스트를 요약하기 위해 주기적으로 /compact 사용              │
│  ├── 주제 전환 시 핵심 컨텍스트 재언급                              │
│  └── Claude가 초기 결정을 상기시켜야 할 수 있음                     │
│                                                                     │
│  긴 세션 (80개 이상 메시지)                                          │
│  ├── 새 세션 시작 고려                                               │
│  ├── 중요한 결정을 CLAUDE.md에 저장                                  │
│  ├── 독립적인 연구를 위해 서브에이전트 사용                          │
│  └── /compact 필수                                                   │
│                                                                     │
│  새 세션을 시작해야 할 징조:                                          │
│  ├── Claude가 이전에 내린 결정을 잊음                                │
│  ├── 응답이 덜 정확하거나 반복적이 됨                                │
│  ├── Claude가 이미 읽은 파일을 다시 읽음                            │
│  └── 완전히 다른 작업으로 전환하는 경우                             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.4 /compact 명령어

주요 결정을 보존하면서 대화 내역을 압축하려면 `/compact`를 사용하세요:

```
> /compact

# Claude가 지금까지의 세션을 요약합니다:
# "세션 요약: 알림 기본 설정 기능을 구현하고 있습니다.
#  완료: 데이터베이스 마이그레이션, API 엔드포인트 (GET/PUT/PATCH),
#  캐싱을 통한 서비스 통합. 남은 작업: 프론트엔드 컴포넌트,
#  엣지 케이스 테스트."
```

다음의 경우 `/compact`를 사용하세요:
- 컨텍스트 창의 약 절반 정도 지점
- 동일한 세션 내에서 포커스를 전환할 때
- Claude가 이전 컨텍스트를 잊기 시작하는 징조를 보일 때
- 복잡한 다음 단계 전에 진행 상황을 "체크포인트"하고 싶을 때

---

## 3. 보안 모범 사례

### 3.1 권한 모드 선택

신뢰 수준에 맞는 적절한 권한 모드를 선택하세요:

```
┌─────────────────────────────────────────────────────────────────────┐
│                    권한 모드 결정 트리                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  자신이 소유하거나 유지 관리하는 신뢰할 수 있는 저장소인가요?         │
│  ├── 예: 작업이 잘 정의되어 있고 위험이 낮은가요?                   │
│  │   ├── 예 → 자동 수락 모드 (허용 규칙 포함)                      │
│  │   └── 아니오 → 기본 모드 (각 도구 사용 승인)                    │
│  │                                                                  │
│  └── 아니오: Claude가 무엇을 할지 이해하고 있나요?                  │
│      ├── 예 → 기본 모드 (승인 전 검토)                             │
│      └── 아니오 → 플랜 전용 모드 (코드 실행 없음)                  │
│                                                                     │
│  CI/CD에서 실행 중인가요 (사람이 없음)?                              │
│  ├── 예: 환경이 격리되어 있나요 (컨테이너)?                         │
│  │   ├── 예 → 우회 모드 (모두 자동 수락)                           │
│  │   └── 아니오 → 공유 인프라에서 우회 모드 절대 사용 금지          │
│  └── 아니오 → 적절하게 기본 또는 자동 수락 사용                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 비밀 정보 관리

Claude가 읽거나 노출할 수 있는 곳에 비밀 정보를 절대 넣지 마세요:

```
# 나쁜 예: CLAUDE.md에 비밀 정보
## API 키
- Stripe: sk_live_abc123...
- 데이터베이스: postgresql://admin:password@db.example.com

# 나쁜 예: 프롬프트에 비밀 정보
> "postgresql://admin:password@db.example.com 데이터베이스에
>  연결하고 마이그레이션을 실행하세요"

# 좋은 예: 환경 변수 사용
> "DATABASE_URL 환경 변수를 사용하여 데이터베이스에 연결하고
>  마이그레이션을 실행하세요"

# 좋은 예: 값이 아닌 이름으로 비밀 정보 참조
> "Stripe API 키는 STRIPE_SECRET_KEY 환경 변수에 저장되어 있습니다.
>  이를 사용하여 Stripe 클라이언트를 초기화하세요."
```

CLAUDE.md에서:

```markdown
## 환경 변수
필요한 환경 변수 (구조는 .env.example 참조):
- DATABASE_URL — PostgreSQL 연결 문자열
- REDIS_URL — Redis 연결 문자열
- STRIPE_SECRET_KEY — Stripe API 키
- JWT_SECRET — JWT 서명 키

이 값들을 절대 하드코딩하지 마세요. 항상 os.environ에서 읽으세요.
```

### 3.3 생성된 코드 검토

Claude가 생성하는 코드를 항상 검토하세요. 특히 다음에 주의하세요:

```
┌─────────────────────────────────────────────────────────────────────┐
│                생성된 코드의 보안 검토 체크리스트                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  □ SQL 쿼리가 매개변수화된 쿼리를 사용하는가 (문자열 연결 없음)      │
│  □ 사용자 입력이 유효성 검사 및 정제되어 있는가                      │
│  □ 보호된 엔드포인트에 인증 검사가 있는가                           │
│  □ 권한 부여가 사용자의 리소스 접근을 확인하는가                    │
│  □ 오류 메시지가 내부 세부 정보를 누출하지 않는가                   │
│  □ 민감한 데이터가 로깅되지 않는가                                  │
│  □ 파일 작업이 경로를 검증하는가 (경로 순회 없음)                   │
│  □ 외부 URL이 사용 전에 검증되는가                                  │
│  □ 암호화 작업이 표준 라이브러리를 사용하는가                       │
│  □ 의존성이 신뢰할 수 있는 출처에서 가져오는가                      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.4 민감한 작업을 위한 안전한 패턴

```python
# 좋은 예: Claude에게 환경 변수를 사용하도록 지시
# 프롬프트에서:
# "API 키를 환경에서 읽고 절대 하드코딩하지 마세요"

import os

def get_api_client():
    """환경 설정을 사용하여 API 클라이언트를 생성합니다."""
    api_key = os.environ.get("API_KEY")
    if not api_key:
        raise EnvironmentError(
            "API_KEY 환경 변수가 필요합니다. "
            "설정 방법은 .env.example을 참조하세요."
        )
    return APIClient(api_key=api_key)


# 좋은 예: 매개변수화된 쿼리 (Claude가 항상 이렇게 생성해야 함)
def get_user(db, user_id: int):
    """매개변수화된 쿼리를 사용하여 ID로 사용자를 가져옵니다."""
    return db.execute(
        "SELECT * FROM users WHERE id = %s",  # 매개변수화됨
        (user_id,)
    ).fetchone()


# 나쁜 예: SQL의 문자열 보간 (검토 시 이를 표시해야 함)
def get_user_UNSAFE(db, user_id):
    """절대 이렇게 하지 마세요 — SQL 인젝션 취약점."""
    return db.execute(
        f"SELECT * FROM users WHERE id = {user_id}"  # 취약함
    ).fetchone()
```

---

## 4. 팀 협업 패턴

### 4.1 팀 문서로서의 공유 CLAUDE.md

CLAUDE.md는 이중 목적을 수행합니다: Claude Code를 구성하고 팀 관례를 문서화합니다. 이것을 최대한 활용하세요:

```markdown
# CLAUDE.md

## 팀 관례 (Claude Code + 인간 개발자)

### Git 워크플로우
- 기능 브랜치: feature/JIRA-123-짧은-설명
- 커밋 메시지: 관례적 커밋 (feat:, fix:, refactor: 등)
- 모든 PR은 병합 전 1회 검토 필요
- 스쿼시 병합(Squash Merge)으로 main에 합치기

### 코드 검토 기준
코드를 검토할 때 (또는 검토를 위해 코드를 생성할 때):
- 30줄 이상의 함수는 분해해야 함
- 공개 함수에는 독스트링(Docstring) 필수
- 새 엔드포인트에는 통합 테스트가 있어야 함
- 데이터베이스 쿼리는 ORM을 사용해야 함 (마이그레이션 제외 원시 SQL 없음)

### 테스트 요구사항
- 비즈니스 로직의 단위 테스트 (pytest)
- API 엔드포인트의 통합 테스트 (pytest + httpx)
- 중요 사용자 흐름의 E2E 테스트 (Playwright)
- 새 코드의 최소 80% 커버리지
```

이 파일이 버전 관리에 체크인되므로 전체 팀이 동일한 Claude Code 구성의 혜택을 누릴 수 있습니다.

### 4.2 일반적인 워크플로우를 위한 표준화된 스킬

팀별 워크플로우를 인코딩하는 공유 스킬을 만드세요:

```markdown
# .claude/skills/create-api-endpoint.md

## 스킬: API 엔드포인트 생성

새 API 엔드포인트를 생성하도록 요청받으면 이 체크리스트를 따르세요:

1. `src/routes/{resource}.py`에 라우트 핸들러 생성
2. `src/schemas/{resource}.py`에 Pydantic 요청/응답 스키마 추가
3. `src/services/{resource}_service.py`에 비즈니스 로직 구현
4. `src/routes/__init__.py` 라우터 등록에 라우트 추가
5. `tests/api/test_{resource}.py`에 통합 테스트 작성
6. 새 엔드포인트로 `docs/API.md` 업데이트
7. `pytest tests/`를 실행하여 모든 테스트 통과 확인
8. `mypy src/`를 실행하여 타입 안전성 확인

### 라우트 핸들러 템플릿:

```python
from fastapi import APIRouter, Depends, HTTPException, status
from src.auth import get_current_user
from src.schemas.{resource} import {Resource}Create, {Resource}Response
from src.services.{resource}_service import {Resource}Service

router = APIRouter(prefix="/api/v1/{resources}", tags=["{resources}"])

@router.post("/", response_model={Resource}Response, status_code=status.HTTP_201_CREATED)
async def create_{resource}(
    data: {Resource}Create,
    user = Depends(get_current_user),
    service: {Resource}Service = Depends(),
):
    return await service.create(data, user)
```
```

### 4.3 Claude 지원을 통한 코드 검토

Claude Code가 인간 코드 검토를 대체하는 것이 아닌 보조하는 패턴을 수립하세요:

```
# 팀원을 위한 검토 워크플로우:

1. 작성자가 PR 제출
2. CI가 Claude Code 검토 실행 (자동화, 명백한 문제 포착)
3. 인간 검토자는 다음에 집중:
   - 비즈니스 로직 정확성
   - 설계 결정과 트레이드오프
   - 도메인 지식에 특정한 엣지 케이스
   - 성능 영향
4. 작성자가 Claude와 인간 피드백을 모두 처리
```

### 4.4 새 팀원 온보딩

온보딩 친화적인 CLAUDE.md 섹션 만들기:

```markdown
## 신규 개발자 온보딩

이 프로젝트가 처음이라면 Claude Code에게 다음 질문을 하세요:

1. "이 프로젝트의 높은 수준의 아키텍처를 설명해주세요"
2. "API에서 데이터베이스까지 요청이 어떻게 흐르는지 안내해주세요"
3. "주요 모듈은 무엇이고 각각 무엇을 하나요?"
4. "이 프로젝트에서 사용된 테스트 패턴을 보여주세요"
5. "내가 해야 할 가장 일반적인 작업은 무엇인가요?"

### 빠른 시작
```bash
# 설정
cp .env.example .env  # 로컬 설정으로 편집
docker-compose up -d   # PostgreSQL과 Redis 시작
npm install
npm run db:migrate
npm run db:seed

# 개발
npm run dev            # http://localhost:3000
npm run test:watch     # 감시 모드에서 테스트 실행
```
```

---

## 5. 성능 최적화

### 5.1 명확한 컨텍스트로 세션 시작

첫 번째 메시지가 전체 세션의 톤을 설정합니다. 중요한 컨텍스트를 앞에 배치하세요:

```
# 좋은 예: 명확한 시작 메시지
> 결제 서비스 (src/services/payment/)에서 작업하고 있습니다.
> 문제는 Stripe API가 402 오류를 반환할 때 환불 처리가
> 자동으로 실패한다는 것입니다. 다음이 필요합니다:
> 1. 402 응답에 대한 적절한 오류 처리 추가
> 2. 일시적 오류에 대한 지수적 백오프(Exponential Backoff)로 재시도
> 3. 오류 추적 시스템(Sentry)에 실패 로깅
> 관련 파일은 payment_service.py와 stripe_provider.py입니다.

# 나쁜 예: 많은 후속 질문이 필요한 모호한 시작
> 결제에 문제가 있어요. 도와줄 수 있나요?
```

### 5.2 독립적인 연구를 위한 서브에이전트 사용

코드베이스의 여러 관련 없는 부분에서 정보가 필요할 때 서브에이전트가 병렬로 검색할 수 있습니다:

```
> 새 기능을 구현하기 전에 세 가지를 이해해야 합니다:
> 1. 현재 알림 시스템이 어떻게 작동하는지 (src/services/notifications/)
> 2. 이미 설치된 WebSocket 라이브러리
> 3. 테스트 픽스처(Fixture)가 어떻게 구성되어 있는지 (tests/conftest.py)
> 이것들은 독립적입니다 — 세 가지를 모두 조사하세요.
```

Claude Code는 각 주제를 동시에 연구하기 위해 서브에이전트를 생성하여 순차적 조사보다 더 빠른 결과를 반환할 수 있습니다.

### 5.3 관련 변경 사항 일괄 처리

한 번에 파일 하나씩 변경하는 대신 관련 변경 사항을 일괄 처리하세요:

```
# 느린 방법: 한 번에 하나씩 변경
> "새 필드를 모델에 추가해줘"
> (완료 대기)
> "이제 스키마를 업데이트해줘"
> (완료 대기)
> "이제 API 엔드포인트를 업데이트해줘"
> (완료 대기)

# 빠른 방법: 관련 변경 사항 일괄 처리
> "'phone_number' 필드를 User 모델에 추가하고,
>  Pydantic 스키마를 업데이트하고, 등록 엔드포인트가
>  전화번호를 수락하고 유효성을 검사하도록 업데이트하세요.
>  세 파일을 함께 업데이트한 다음 테스트를 실행하세요."
```

### 5.4 불필요한 파일 재읽기 방지

Claude Code는 세션 내에서 파일 내용을 캐시합니다. Claude Code 외부(편집기에서)에서 파일을 수정한 경우 이를 알려주세요:

```
> 새 설정을 추가하기 위해 편집기에서 src/config.py를 방금 수정했습니다.
> 계속하기 전에 업데이트된 파일을 읽으세요.
```

이 힌트 없이는 Claude Code가 파일의 캐시된 (오래된) 버전으로 작업할 수 있습니다.

---

## 6. 일반적인 안티패턴

### 6.1 너무 광범위한 프롬프트

```
# 안티패턴: Claude에게 전체 코드베이스를 검토하도록 요청
> "이 프로젝트의 모든 코드를 검토하고 개선 사항을 제안해주세요"
# 이것은 토큰을 낭비하고, 피상적인 결과를 생성하며, 종종
# 컨텍스트 창을 초과합니다.

# 더 좋은 방법: 특정 영역에 집중
> "src/services/의 오류 처리를 검토하고 예외가 자동으로
>  무시되는 곳을 파악해주세요"
```

### 6.2 복잡한 작업에서 플랜 모드 무시

```
# 안티패턴: 곧바로 구현으로 뛰어들기
> "PostgreSQL 대신 MongoDB를 사용하도록 데이터베이스 레이어를 다시 작성해줘"
# 이것은 Claude가 필요한 변경의 전체 범위를 이해하지 못하기 때문에
# 불완전한 결과를 생성합니다.

# 더 좋은 방법: 먼저 계획하고 나서 구현
> /plan "PostgreSQL에서 MongoDB로 마이그레이션하려면 어떻게 해야 하나요?
>        영향받는 모든 파일, 데이터 마이그레이션 필요, 위험을 나열하세요."
# 그런 다음 계획을 사용하여 단계별로 실행합니다.
```

### 6.3 생성된 코드를 검토하지 않음

```
# 안티패턴: 모든 것을 자동 수락
# 로컬 개발을 위해 권한 모드를 우회로 설정하고
# Claude가 생성하는 것을 절대 검토하지 않음.

# 더 좋은 방법: 보안에 민감한 코드 검토
# 기본 권한 모드를 사용하세요. Claude가 인증 코드,
# 데이터베이스 쿼리, 파일 작업을 생성할 때 주의 깊게 검토하세요.
```

### 6.4 CLAUDE.md에 속하는 것에 훅 사용

```json
// 안티패턴: 스타일을 적용하는 복잡한 훅
{
  "hooks": {
    "PreToolUse": [{
      "matcher": "Edit|Write",
      "command": "echo 'PEP 8 스타일을 사용하고 타입 힌트를 추가하세요'"
    }]
  }
}

// 더 좋은 방법: CLAUDE.md에 스타일 지침 넣기
// CLAUDE.md:
// ## 스타일: PEP 8, 모든 함수에 타입 힌트, Google 스타일 독스트링
```

훅은 자동화된 검사 (린터 실행, 테스트)를 위한 것이지, CLAUDE.md에 속하는 지침을 위한 것이 아닙니다.

### 6.5 너무 많은 병렬 에이전트 실행

```
# 안티패턴: 20개의 서브에이전트를 동시에 생성
# 이것은 속도 제한에 걸리고 모든 것을 느리게 만듭니다.

# 더 좋은 방법: 3-5개의 병렬 에이전트 그룹으로 배치
# 처리할 파일이 20개라면 한 번에 20개가 아니라
# 5개씩 4배치로 처리하세요.
```

### 6.6 Claude를 파트너가 아닌 신탁(Oracle)으로 취급

```
# 안티패턴: 컨텍스트 없이 확정적인 답변 요청
> "내 프로젝트에 가장 좋은 데이터베이스는 무엇인가요?"

# 더 좋은 방법: 합리적인 추천을 위한 컨텍스트와 제약 제공
> "초당 10K 이벤트를 수집하고, 서브초 쿼리 지연 시간이 필요하며,
>  팀이 PostgreSQL을 알고 있는 실시간 분석 대시보드를 만들고 있습니다.
>  TimescaleDB를 사용한 PostgreSQL, ClickHouse, 또는 다른 것을
>  사용해야 할까요? 트레이드오프는 무엇인가요?"
```

---

## 7. 치트 시트: 빠른 참조

```
┌─────────────────────────────────────────────────────────────────────┐
│              Claude Code 모범 사례 치트 시트                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  프롬프팅                                                            │
│  ✓ 구체적으로: 무엇을, 어디서, 왜, 제약                              │
│  ✓ 대형 작업을 단계로 분해                                           │
│  ✓ 복잡한 변경 전에 /plan 사용                                       │
│  ✓ 알고 있을 때 특정 파일 참조                                       │
│  ✗ "더 좋게 만들어줘" 같은 모호한 프롬프트                           │
│  ✗ "모든 것"을 검토하도록 요청                                       │
│                                                                     │
│  컨텍스트                                                            │
│  ✓ CLAUDE.md를 집중적이고 최신으로 유지                             │
│  ✓ 긴 세션에서 /compact 사용                                         │
│  ✓ 관련 없는 작업을 위해 새 세션 시작                               │
│  ✓ 첫 번째 메시지에 컨텍스트 앞에 배치                              │
│  ✗ CLAUDE.md에 모든 것을 채워 넣기                                  │
│  ✗ 압축 없이 200개 이상의 메시지 세션                               │
│                                                                     │
│  보안                                                                │
│  ✓ 비밀 정보에 환경 변수 사용                                        │
│  ✓ 생성된 인증/보안 코드 주의 깊게 검토                              │
│  ✓ 신뢰 수준에 맞는 권한 모드 설정                                  │
│  ✓ SQL 인젝션, 경로 순회 확인                                        │
│  ✗ CLAUDE.md나 프롬프트에 비밀 정보 하드코딩                        │
│  ✗ 신뢰할 수 없는 저장소에서 우회 모드 사용                         │
│                                                                     │
│  성능                                                                │
│  ✓ 하나의 프롬프트에 관련 변경 사항 일괄 처리                        │
│  ✓ 독립적인 연구를 위해 서브에이전트 사용                            │
│  ✓ 작업 복잡도에 맞는 모델 선택                                      │
│  ✓ 반복되는 컨텍스트에 프롬프트 캐싱 사용                           │
│  ✗ 메시지당 작은 변경 하나                                           │
│  ✗ 단순한 작업에 Opus 사용                                           │
│                                                                     │
│  팀                                                                  │
│  ✓ 팀 전체에서 CLAUDE.md 공유 (git에 체크인)                        │
│  ✓ 일반적인 워크플로우를 위한 스킬 표준화                           │
│  ✓ 코드 검토 대체가 아닌 보조로 Claude 사용                         │
│  ✓ CLAUDE.md에 온보딩 지침 포함                                      │
│  ✗ 각 개발자가 호환되지 않는 설정 사용                              │
│  ✗ 코드 검토를 전적으로 Claude에 의존                               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 8. 연습 문제

### 연습 1: CLAUDE.md 감사 (초급)

작업하는 프로젝트의 CLAUDE.md 파일을 검토하거나 (또는 새로 만드세요). 다음 기준에 대해 평가하세요:
1. Claude에 필요한 필수 명령어가 포함되어 있나요 (테스트, 빌드, 린트)?
2. 200줄 미만인가요? (더 길다면 무엇을 다듬을지 파악하세요.)
3. 명확하지 않은 관례를 문서화하고 있나요?
4. Claude가 알아야 할 중요 파일이 나열되어 있나요?
5. 제거해야 할 민감한 정보가 포함되어 있나요?

2.1절의 템플릿에 따라 다시 작성하세요.

### 연습 2: 프롬프트 개선 (중급)

이 모호한 프롬프트를 가져다가 SCFO 프레임워크를 사용하여 다시 작성하세요:

1. "앱에 오류 처리를 추가해줘"
2. "테스트가 느려, 수정해줘"
3. "사용자 관리 시스템을 만들어줘"
4. "API를 더 안전하게 만들어줘"
5. "데이터베이스 코드를 리팩터링해줘"

각 다시 작성된 프롬프트에 대해 추가한 컨텍스트와 이유를 설명하세요.

### 연습 3: 보안 검토 (중급)

Claude Code에게 인증이 있는 간단한 REST API를 생성하도록 요청하세요. 그런 다음 3.3절의 보안 체크리스트에 따라 생성된 코드를 검토하세요. 다음을 문서화하세요:
1. Claude가 기본적으로 올바르게 처리한 체크리스트 항목 수
2. 발견한 보안 문제
3. 문제를 수정하기 위해 필요한 추가 프롬프팅

### 연습 4: 팀 설정 (고급)

Python/FastAPI 프로젝트에서 작업하는 5명의 개발자 팀을 위한 완전한 Claude Code 설정을 설계하세요. 다음을 만드세요:
1. CLAUDE.md 파일
2. 두 개의 커스텀 스킬 (하나는 엔드포인트 생성, 하나는 데이터베이스 모델 추가)
3. 팀에 적합한 권한 설정
4. 모든 파일 편집에서 린팅을 실행하는 훅
5. 새 팀원을 위한 온보딩 지침

### 연습 5: 세션 최적화 (중급)

두 가지 다른 접근 방식을 사용하여 동일한 코딩 작업(예: 기능 구현)을 수행하세요:

**세션 A**: 모호한 프롬프트로 시작하고 점진적으로 세부 사항 추가
**세션 B**: 완전한 SCFO 프롬프트로 시작하고, 플랜 모드 사용, 변경 사항 일괄 처리

비교:
- 필요한 총 메시지 수
- 완료까지 걸린 시간
- 최종 결과의 품질
- Claude를 수정하거나 방향을 바꿔야 했던 횟수

결과를 문서화하고 어떤 사례가 가장 큰 차이를 만들었는지 파악하세요.

---

## 참고 자료

- Claude Code 문서 - https://docs.anthropic.com/en/docs/claude-code
- Anthropic 프롬프트 엔지니어링 가이드 - https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering
- OWASP 보안 코딩 사례 - https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/

---

## 다음 단계

[22. 문제 해결 및 디버깅](./22_Troubleshooting.md)은 Claude Code에서 발생할 수 있는 일반적인 문제들 -- 권한 오류, 훅 실패, 컨텍스트 한계, MCP 문제, API 오류, 성능 문제 -- 과 이를 진단하고 해결하는 체계적인 접근 방법을 다룹니다.

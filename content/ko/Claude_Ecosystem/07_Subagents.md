# 서브에이전트와 작업 위임(Subagents and Task Delegation)

**이전**: [06. 스킬과 슬래시 커맨드](./06_Skills_and_Slash_Commands.md) | **다음**: [08. 에이전트 팀](./08_Agent_Teams.md)

---

Claude Code의 가장 강력한 기능 중 하나는 **서브에이전트(Subagent)** — 각자의 컨텍스트 윈도우 내에서 독립적으로 작동하는 특화된 AI 에이전트 — 를 실행하는 것입니다. 단일 대화에서 복잡한 작업 전체를 처리하려는 대신, 병렬로 탐색, 계획, 실행하는 집중화된 서브에이전트에 작업을 위임할 수 있습니다. 이 레슨에서는 서브에이전트 기반 워크플로의 메커니즘, 유형, 모범 사례를 다룹니다.

**난이도**: ⭐⭐

**사전 지식**:
- 레슨 02: Claude Code 시작하기
- 레슨 03: CLAUDE.md와 프로젝트 설정
- 컨텍스트 윈도우 및 토큰 한계에 대한 기본 이해

**학습 목표**:
- 서브에이전트가 무엇인지, 메인 Claude Code 세션과 어떻게 다른지 이해
- 컨텍스트 격리(context isolation)와 복잡한 작업에서 왜 중요한지 설명
- 세 가지 내장 서브에이전트 유형 (Explore, Plan, General-Purpose) 구별
- Task 도구를 사용하여 적절한 파라미터로 서브에이전트 실행
- 독립적인 작업에 대해 여러 서브에이전트를 병렬로 실행
- 백그라운드 에이전트 사용 및 출력 조회
- /agents 커맨드를 사용하여 커스텀 에이전트 정의 생성
- 커스텀 에이전트를 위한 효과적인 YAML 설정 작성
- 서브에이전트 사용 vs. 메인 세션에서 직접 작업 중 결정

---

## 목차

1. [서브에이전트란?](#1-서브에이전트란)
2. [컨텍스트 격리](#2-컨텍스트-격리)
3. [내장 서브에이전트 유형](#3-내장-서브에이전트-유형)
4. [Task 도구](#4-task-도구)
5. [서브에이전트 병렬 실행](#5-서브에이전트-병렬-실행)
6. [백그라운드 에이전트](#6-백그라운드-에이전트)
7. [커스텀 에이전트 정의](#7-커스텀-에이전트-정의)
8. [서브에이전트 사용 vs. 직접 작업](#8-서브에이전트-사용-vs-직접-작업)
9. [모범 사례](#9-모범-사례)
10. [일반적인 패턴과 레시피](#10-일반적인-패턴과-레시피)
11. [연습 문제](#11-연습-문제)
12. [참고 자료](#12-참고-자료)

---

## 1. 서브에이전트란?

**서브에이전트(Subagent)**는 특정 작업을 수행하기 위해 메인 Claude Code 세션에서 실행되는 별도의 Claude 인스턴스입니다. 동료에게 업무를 위임하는 것처럼 생각할 수 있습니다: 명확한 브리핑을 제공하면, 그들이 독립적으로 작업하고, 결과를 보고합니다.

```
┌─────────────────────────────────────────────────────┐
│                  메인 Claude Code 세션               │
│                                                     │
│   "이 코드베이스를 의존성 주입(dependency           │
│    injection)을 사용하도록 리팩토링해줘"             │
│                                                     │
│   ┌──────────┐  ┌──────────┐  ┌──────────┐         │
│   │서브에이전│  │서브에이전│  │서브에이전│         │
│   │   트 #1  │  │   트 #2  │  │   트 #3  │         │
│   │ Explore  │  │ General  │  │ General  │         │
│   │코드베이스│  │모듈 A    │  │모듈 B    │         │
│   │구조 탐색 │  │리팩토링  │  │리팩토링  │         │
│   └──────────┘  └──────────┘  └──────────┘         │
│        │              │              │              │
│        ▼              ▼              ▼              │
│   [분석 결과]    [수정된 A]    [수정된 B]            │
└─────────────────────────────────────────────────────┘
```

서브에이전트의 주요 특성:

- **독립적인 컨텍스트**: 각 서브에이전트는 메인 세션과 분리된 자체 컨텍스트 윈도우를 가짐
- **집중된 범위**: 서브에이전트는 하나의 잘 정의된 작업을 수행
- **도구 접근**: 서브에이전트 유형마다 다른 도구 세트에 접근 가능
- **병렬 실행**: 여러 서브에이전트가 동시에 실행될 수 있음
- **결과 보고**: 서브에이전트는 결과를 메인 세션에 반환

### 서브에이전트가 존재하는 이유

주요 동기는 **컨텍스트 윈도우 관리**입니다. Claude Code는 유한한 컨텍스트 윈도우(일반적으로 200K 토큰)를 가집니다. 대규모 코드베이스에서 작업할 때, 단일 세션은 파일 내용, 검색 결과, 대화 기록으로 컨텍스트가 빠르게 채워질 수 있습니다. 서브에이전트는 다음을 통해 이를 해결합니다:

1. **탐색 오프로딩**: 서브에이전트가 수십 개의 파일을 읽고, 발견사항을 종합하고, 간결한 요약을 반환 — 원시 파일 내용에 메인 세션 토큰을 소비하지 않음
2. **작업 병렬화**: 독립적인 작업이 순차적이 아닌 동시에 실행
3. **복잡성 격리**: 각 서브에이전트가 하나의 것에 집중하여 메인 세션의 인지 부하를 줄임

---

## 2. 컨텍스트 격리

컨텍스트 격리(Context Isolation)는 서브에이전트의 정의적인 아키텍처 특성입니다. 각 서브에이전트는 부모 세션이나 형제 서브에이전트와 공유 메모리 없이 자체 컨텍스트 윈도우에서 작동합니다.

### 서브에이전트가 받는 것

서브에이전트를 실행할 때, 다음을 받습니다:

1. **프롬프트**: 제공하는 작업 설명
2. **시스템 명령**: 서브에이전트 유형에 따라 (Explore, Plan, General-Purpose)
3. **CLAUDE.md 내용**: 프로젝트의 CLAUDE.md 파일이 자동으로 로드됨
4. **도구 정의**: 해당 서브에이전트 유형에서 사용 가능한 도구 세트

### 서브에이전트가 받지 못하는 것

- 메인 세션의 대화 기록
- 다른 서브에이전트의 결과 (프롬프트에 명시적으로 포함하지 않는 한)
- 메인 세션이 이미 읽은 파일 (서브에이전트가 다시 읽어야 함)
- 메인 세션의 코드베이스에 대한 "이해"

```
┌─────────────────────┐      ┌─────────────────────┐
│   메인 세션          │      │   서브에이전트       │
│                     │      │                     │
│ ✓ 전체 대화 기록     │      │ ✗ 대화 기록 없음     │
│ ✓ 모든 도구 결과     │      │ ✗ 자체 도구 결과만   │
│ ✓ 사용자 설정        │      │ ✓ CLAUDE.md 로드됨  │
│ ✓ 이전 편집 내용     │      │ ✓ 부모의 프롬프트   │
│                     │──────│                     │
│                     │프롬프트                   │
│                     │──────│                     │
│                     │◀─────│                     │
│                     │결과  │                     │
└─────────────────────┘      └─────────────────────┘
```

### 컨텍스트 격리의 의미

**장점**: 서브에이전트가 새로 시작하므로, 작업을 혼란스럽게 할 수 있는 무관한 컨텍스트를 가지지 않습니다.

**과제**: 프롬프트에 충분한 컨텍스트를 제공해야 합니다. 메인 세션이 "인증 모듈은 `src/auth/`에 있고 JWT 토큰을 사용한다"는 것을 발견했다면, 서브에이전트에게 알려주지 않는 한 이를 알지 못합니다.

```
# 나쁜 예: 서브에이전트가 메인 세션의 컨텍스트를 안다고 가정
Task(prompt="우리가 auth 모듈에서 논의했던 버그 수정해줘")

# 좋은 예: 필요한 모든 컨텍스트가 포함된 자기 완결적 프롬프트
Task(prompt="""src/auth/validate.py의 JWT 토큰 유효성 검사 버그를 수정해줘.
문제: 만료된 'nbf' (not before) 클레임이 있는 토큰이 수락되고 있음.
45번째 줄의 validate_token() 함수가 'exp'는 확인하지만 'nbf'는 확인하지 않음.
30초의 클락 스큐(clock skew) 허용 오차를 두고 'nbf' 유효성 검사를 추가해줘.
수정을 확인하기 위해 tests/test_auth.py의 기존 테스트를 실행해줘.""")
```

---

## 3. 내장 서브에이전트 유형

Claude Code는 각각 다른 도구 세트와 목적을 가진 세 가지 내장 서브에이전트 유형을 제공합니다.

### 3.1 Explore 서브에이전트

**Explore** 서브에이전트는 코드베이스 탐색과 분석을 위해 최적화된 빠르고 읽기 전용인 에이전트입니다. 파일을 수정할 수 없습니다.

**사용 가능한 도구**:
- `Glob` — 패턴으로 파일 찾기
- `Grep` — 파일 내용 검색
- `Read` — 파일 내용 읽기

**사용 사례**:
- 코드베이스 구조 이해
- 함수나 클래스의 모든 사용처 찾기
- 모듈 간 의존성 분석
- 테스트 커버리지 매핑
- 코드 영역 요약 생성

```
# 예시: Explore 서브에이전트를 사용하여 모듈 이해
Task(
    subagent_type="explore",
    prompt="""src/database/의 데이터베이스 모듈을 분석해줘.

    다음을 이해하고 싶어:
    1. 어떤 ORM이 사용되고 모델이 어떻게 정의되는지
    2. 데이터베이스 연결이 어떻게 관리되는지 (풀? 싱글톤?)
    3. 어떤 마이그레이션 시스템이 있는지
    4. 쿼리가 어떻게 구성되는지 (raw SQL? 쿼리 빌더? ORM?)
    5. 성능 우려사항 (N+1 쿼리, 누락된 인덱스)

    핵심 컴포넌트의 파일 경로가 포함된 구조화된 요약을 제공해줘."""
)
```

**Explore를 직접 하는 것 대신 사용해야 하는 이유?** Explore 서브에이전트는 코드베이스 전체에서 수십 개의 파일을 읽어 자체 컨텍스트 윈도우에서 토큰을 소비합니다. 그런 다음 메인 세션에 간결한 요약을 반환하여 상당한 컨텍스트 공간을 절약합니다.

### 3.2 Plan 서브에이전트

**Plan** 서브에이전트는 연구 및 아키텍처 계획을 위해 설계되었습니다. 코드베이스에 대한 읽기 전용 접근과 함께 문서 및 모범 사례를 조회하기 위한 웹 접근이 가능합니다.

**사용 가능한 도구**:
- `Glob` — 패턴으로 파일 찾기
- `Grep` — 파일 내용 검색
- `Read` — 파일 내용 읽기
- `WebSearch` — 웹 검색
- `WebFetch` — 웹 페이지 가져오기 및 처리

**사용 사례**:
- 기능에 대한 최적의 접근 방식 연구
- 라이브러리 문서 조회
- 단계별 명령이 포함된 구현 계획 수립
- 아키텍처 옵션 비교
- 에러 메시지 또는 스택 트레이스 조사

```
# 예시: Plan 서브에이전트를 사용하여 마이그레이션 전략 연구
Task(
    subagent_type="plan",
    prompt="""Express.js API를 REST에서 GraphQL로 마이그레이션해야 해.

    현재 설정:
    - src/routes/에 47개의 REST 엔드포인트가 있는 Express.js 4.x
    - src/models/에 Sequelize ORM이 있는 PostgreSQL
    - src/middleware/auth.js의 JWT 미들웨어를 통한 인증

    연구하고 마이그레이션 계획을 수립해줘:
    1. Apollo Server vs Mercurius vs graphql-yoga 평가 (최신 문서 확인)
    2. GraphQL 타입 후보를 파악하기 위해 현재 라우트 핸들러 분석
    3. 단계별 마이그레이션 계획 제안 (REST + GraphQL 공존)
    4. 위험 및 완화 전략 파악
    5. 필요한 변경 범위 추정

    실제 코드를 바탕으로 분석을 진행하기 위해 관련 소스 파일을 읽어줘."""
)
```

### 3.3 General-Purpose 서브에이전트

**General-Purpose** 서브에이전트는 파일 편집, 터미널 커맨드, 웹 접근을 포함한 모든 도구에 완전한 접근이 가능합니다. 코드베이스를 변경할 수 있습니다.

**사용 가능한 도구**:
- 모든 읽기 도구 (Glob, Grep, Read)
- 모든 쓰기 도구 (Edit, Write)
- `Bash` — 터미널 커맨드 실행
- `WebSearch` / `WebFetch` — 웹 접근
- `NotebookEdit` — Jupyter 노트북 편집
- 프로젝트에 설정된 MCP 도구

**사용 사례**:
- 기능 구현 또는 버그 수정
- 테스트 실행 및 실패 수정
- 새 파일 생성
- 코드 리팩토링
- 의존성 설치
- 코드베이스 수정이 필요한 모든 작업

```
# 예시: General-Purpose 서브에이전트를 사용하여 기능 구현
Task(
    subagent_type="general-purpose",
    prompt="""src/routes/의 API 엔드포인트에 속도 제한을 추가해줘.

    요구사항:
    1. 'express-rate-limit' 패키지 사용 (설치 포함)
    2. 15분당 100개 요청의 기본 속도 제한 적용
    3. auth 엔드포인트에 분당 10개 요청의 더 엄격한 제한 적용
    4. Redis에 속도 제한 데이터 저장 (연결 설정은 src/config.js에 있음)
    5. Retry-After 헤더와 함께 표준 429 응답 반환
    6. 모든 응답에 속도 제한 헤더 추가 (X-RateLimit-*)
    7. tests/middleware/test_rate_limit.js에 테스트 작성
    8. 테스트 스위트 실행하고 모든 테스트 통과 확인

    src/middleware/의 기존 미들웨어 패턴을 템플릿으로 사용해줘."""
)
```

### 비교표

| 기능 | Explore | Plan | General-Purpose |
|-----|---------|------|-----------------|
| 파일 읽기 | 예 | 예 | 예 |
| 코드베이스 검색 | 예 | 예 | 예 |
| 웹 검색 | 아니오 | 예 | 예 |
| 파일 편집 | 아니오 | 아니오 | 예 |
| 커맨드 실행 | 아니오 | 아니오 | 예 |
| 새 파일 작성 | 아니오 | 아니오 | 예 |
| 속도 | 가장 빠름 | 빠름 | 보통 |
| 토큰 비용 | 최저 | 중간 | 최고 |
| 기본 모델 | sonnet | sonnet | sonnet |

---

## 4. Task 도구

**Task** 도구는 메인 Claude Code 세션에서 서브에이전트를 실행하는 메커니즘입니다. 파라미터를 자세히 살펴보겠습니다.

### Task 도구 파라미터

```python
Task(
    prompt: str,              # 필수: 작업 설명
    subagent_type: str,       # "explore" | "plan" | "general-purpose"
    model: str,               # "opus" | "sonnet" | "haiku" (기본값: "sonnet")
    max_turns: int,           # 최대 대화 턴 수 (기본값은 유형에 따라 다름)
    run_in_background: bool,  # 비동기 실행 (기본값: false)
)
```

### 파라미터 상세

#### `prompt` (필수)

가장 중요한 파라미터입니다. 잘 작성된 프롬프트는 성공적인 서브에이전트와 낭비된 호출의 차이를 만듭니다. 다음을 포함하세요:

- **명확한 목표**: 서브에이전트가 무엇을 달성해야 하는가?
- **컨텍스트**: 관련 파일 경로, 아키텍처 결정, 제약 사항
- **예상 출력**: 서브에이전트가 무엇을 반환해야 하는가?
- **경계**: 무엇을 하지 말아야 하는가?

```python
# 상세하고 자기 완결적인 프롬프트
Task(
    prompt="""코드베이스에서 더 이상 사용되지 않는
    'request' 라이브러리 (npm 패키지)의 모든 사용처를 검색해줘.
    각 사용처에 대해:
    1. 파일 경로와 줄 번호 기록
    2. 어떤 HTTP 메서드와 URL이 호출되는지 파악
    3. 특별한 옵션 (헤더, 인증, 타임아웃) 기록

    'fetch'로의 마이그레이션 계획을 세우는 데 사용할 수 있는 구조화된 목록을 반환해줘.
    파일을 수정하지 마세요 — 이것은 분석만을 위한 것입니다.""",
    subagent_type="explore"
)
```

#### `subagent_type`

서브에이전트에서 사용 가능한 도구 세트를 결정합니다 (3장 참조). 작업을 수행할 수 있는 가장 제한적인 유형을 선택하세요:

- 코드를 분석해야 하는가? `explore` 사용
- 연구 + 분석이 필요한가? `plan` 사용
- 코드를 변경하거나 커맨드를 실행해야 하는가? `general-purpose` 사용

#### `model`

서브에이전트를 실행하는 모델을 선택합니다:

- **`sonnet`** (기본값): 속도, 비용, 능력의 좋은 균형. 대부분의 작업에 사용.
- **`opus`**: 가장 능력 있는 모델. 복잡한 추론, 아키텍처 결정 또는 탁월한 품질이 필요한 작업에 사용.
- **`haiku`**: 가장 빠르고 저렴. 포맷팅이나 간단한 검색-교체 같은 단순하고 잘 정의된 작업에 사용.

```python
# 복잡한 아키텍처 분석에 opus 사용
Task(
    prompt="멀티테넌트 SaaS를 위한 데이터베이스 스키마 설계...",
    subagent_type="plan",
    model="opus"
)

# 단순하고 기계적인 작업에 haiku 사용
Task(
    prompt="'os.path'를 가져오는 모든 Python 파일 찾기...",
    subagent_type="explore",
    model="haiku"
)
```

#### `max_turns`

서브에이전트가 취할 수 있는 대화 턴 수를 제어합니다. 각 "턴"은 에이전트가 입력을 받고 출력을 생성하는 (도구 호출 포함) 하나의 사이클입니다. 높은 값은 서브에이전트가 더 많은 작업을 할 수 있게 하지만 더 많은 토큰을 소비합니다.

- 기본값은 서브에이전트 유형에 따라 다름
- 단순한 작업은 비용을 줄이기 위해 낮게 설정
- 복잡한 다단계 작업은 높게 설정

```python
# 단순한 검색 작업 — 턴 제한
Task(
    prompt="src/에서 모든 TODO 주석 찾기",
    subagent_type="explore",
    max_turns=3
)

# 복잡한 구현 — 더 많은 턴 허용
Task(
    prompt="결제 처리 모듈 구현...",
    subagent_type="general-purpose",
    max_turns=30
)
```

#### `run_in_background`

`true`로 설정하면, 서브에이전트가 비동기적으로 실행됩니다. 서브에이전트가 백그라운드에서 처리하는 동안 메인 세션은 계속 작업합니다. 자세한 내용은 6장을 참조하세요.

---

## 5. 서브에이전트 병렬 실행

가장 강력한 패턴 중 하나는 독립적인 작업에 대해 여러 서브에이전트를 동시에 실행하는 것입니다. 이것은 총 실행 시간을 크게 줄입니다.

### 병렬화 시점

다음의 경우 서브에이전트를 병렬화해야 합니다:
- 작업이 **독립적**인 경우 (다른 서브에이전트의 출력에 의존하지 않음)
- 작업이 **다른 파일이나 모듈**에서 작동하는 경우
- 여러 영역에서 동시에 **정보를 수집**하려는 경우

### 병렬 실행 패턴

```python
# 메인 세션이 여러 Task 호출을 동시에 실행할 수 있습니다.
# 이것들은 순차적이 아닌 병렬로 실행됩니다.

# 서브에이전트 1: 프론트엔드 분석
Task(
    subagent_type="explore",
    prompt="src/components/의 React 컴포넌트 계층을 분석해줘. "
           "부모-자식 관계를 매핑하고 프롭 드릴링(prop drilling)을 파악해줘."
)

# 서브에이전트 2: 백엔드 분석
Task(
    subagent_type="explore",
    prompt="src/api/의 API 라우트 구조를 분석해줘. "
           "모든 엔드포인트, HTTP 메서드, 미들웨어 체인을 나열해줘."
)

# 서브에이전트 3: 데이터베이스 분석
Task(
    subagent_type="explore",
    prompt="src/models/의 데이터베이스 모델을 분석해줘. "
           "테이블 간 관계를 매핑하고 인덱스를 파악해줘."
)
```

### 실제 예시: 다중 파일 번역

여러분이 읽고 있는 이 학습 프로젝트는 병렬 서브에이전트를 사용하여 영어에서 한국어로 내용을 번역합니다:

```python
# 3단계 콘텐츠 생성 워크플로의 2단계
# 여러 Sonnet 에이전트가 병렬로 파일을 번역

# 에이전트 1: 레슨 1-2 번역
Task(
    subagent_type="general-purpose",
    model="sonnet",
    prompt="""다음 영어 레슨을 한국어로 번역해줘:
    - /content/en/Topic/01_Lesson.md → /content/ko/Topic/01_Lesson.md
    - /content/en/Topic/02_Lesson.md → /content/ko/Topic/02_Lesson.md

    규칙:
    - 코드 블록은 번역하지 않음
    - URL 및 파일 경로 보존
    - 괄호 안에 영어 용어 사용: "경사 하강법(Gradient Descent)"
    - 테이블 구조 유지"""
)

# 에이전트 2: 레슨 3-4 번역 (에이전트 1과 병렬로 실행)
Task(
    subagent_type="general-purpose",
    model="sonnet",
    prompt="""다음 영어 레슨을 한국어로 번역해줘:
    - /content/en/Topic/03_Lesson.md → /content/ko/Topic/03_Lesson.md
    - /content/en/Topic/04_Lesson.md → /content/ko/Topic/04_Lesson.md
    ... (동일한 규칙) ..."""
)

# 에이전트 3-N: 더 많은 병렬 번역 작업...
```

### 안티 패턴: 의존적인 작업 병렬화

서로 의존하는 작업은 병렬화하지 마세요:

```python
# 나쁜 예: 에이전트 2가 에이전트 1의 출력이 필요함
Task(prompt="코드베이스 구조 분석...")     # 에이전트 1
Task(prompt="분석을 바탕으로 리팩토링...")  # 에이전트 2 — 실패할 것!

# 좋은 예: 의존적인 작업에 순차 실행
result = Task(prompt="코드베이스 구조 분석...")  # 에이전트 1
Task(prompt=f"이 분석을 바탕으로 리팩토링: {result}")  # 에이전트 2
```

---

## 6. 백그라운드 에이전트

백그라운드 에이전트는 비동기적으로 실행되어, 서브에이전트가 처리하는 동안 메인 세션이 다른 작업을 계속할 수 있게 합니다.

### 백그라운드 에이전트 실행

```python
Task(
    subagent_type="general-purpose",
    prompt="전체 테스트 스위트를 실행하고 커버리지 보고서를 생성해줘...",
    run_in_background=True
)
```

`run_in_background=True`인 경우:
1. 메인 세션이 서브에이전트를 실행
2. 메인 세션이 기다리지 않고 **즉시 계속**
3. 백그라운드 에이전트가 완료되면, 메인 세션이 **알림**을 받음
4. 메인 세션이 출력을 읽을 수 있음

### 백그라운드 에이전트 사용 사례

- **장시간 실행되는 테스트**: 코딩을 계속하면서 백그라운드에서 테스트 스위트 실행
- **코드 생성**: 백그라운드에서 보일러플레이트 파일 생성
- **연구 작업**: 다른 것을 작업하면서 Plan 서브에이전트가 주제를 연구하게 함
- **빌드 프로세스**: 빌드를 시작하고 편집 계속

### 백그라운드 에이전트 출력 확인

백그라운드 에이전트가 완료되면, 결과가 메인 세션에서 사용 가능해집니다. 알림에는 서브에이전트의 최종 출력이 포함되며, 진행 중인 작업에 사용할 수 있습니다.

```
┌──────────────────────────────────────────────────────────┐
│ 메인 세션 타임라인                                        │
│                                                          │
│ t=0   백그라운드 에이전트 실행 ──────────────┐            │
│ t=1   기능 X 계속 작업                       │            │
│ t=2   src/components/Header.tsx 편집         │ 백그라운드 │
│ t=3   src/styles/header.css 편집             │ 에이전트   │
│ t=4   ...                                   │ 실행 중    │
│ t=5   ◀── 백그라운드 에이전트 완료 ───────────┘            │
│       "47개 테스트 모두 통과. 커버리지: 89%"               │
│ t=6   결과 반영하고 계속                                   │
└──────────────────────────────────────────────────────────┘
```

### 백그라운드 에이전트의 제한사항

- 실행 후 백그라운드 에이전트에 추가 입력을 보낼 수 없음
- 백그라운드 에이전트는 서브에이전트 유형과 동일한 도구 제한이 있음
- 백그라운드 에이전트가 실패하면 종료 시 알림을 받음
- 결과가 클 수 있음 — 메인 세션이 전체 출력을 받음

---

## 7. 커스텀 에이전트 정의

세 가지 내장 유형 외에도, `/agents` 커맨드를 사용하거나 YAML 설정 파일을 생성하여 프로젝트의 특정 요구에 맞게 조정된 **커스텀 에이전트**를 정의할 수 있습니다.

### /agents 커맨드 사용

Claude Code의 `/agents` 커맨드를 사용하면 커스텀 에이전트 정의를 관리할 수 있습니다:

```bash
# Claude Code에서 입력:
/agents
```

이것은 기존 커스텀 에이전트를 표시하고 새 에이전트를 생성할 수 있게 해줍니다.

### 에이전트 YAML 설정

커스텀 에이전트는 프로젝트의 `.claude/agents/` 디렉토리에 저장된 YAML 파일로 정의됩니다:

```yaml
# .claude/agents/code-reviewer.yaml
name: "Code Reviewer"
description: "코드 변경사항의 품질, 보안, 성능 문제를 리뷰합니다"

system_prompt: |
  당신은 시니어 코드 리뷰어입니다. 다음에 집중하여 제공된 코드 변경사항을 분석하세요:
  1. 보안 취약점 (인젝션, 인증 우회, 데이터 노출)
  2. 성능 문제 (N+1 쿼리, 불필요한 할당, 블로킹 I/O)
  3. 코드 품질 (가독성, DRY 위반, 명명 규칙)
  4. 테스트 커버리지 (엣지 케이스가 테스트되었는가? 모킹이 적절한가?)

  발견된 각 문제에 대해 다음을 제공하세요:
  - 심각도: Critical / High / Medium / Low
  - 파일 및 줄 번호
  - 문제 설명
  - 코드 예제가 포함된 수정 제안

  건설적이고 구체적으로 작성하세요. 좋은 패턴을 발견하면 칭찬하세요.

allowed_tools:
  - Glob
  - Grep
  - Read
  - Bash    # 린터/테스트 실행용
```

### YAML 설정 필드

| 필드 | 타입 | 필수 여부 | 설명 |
|-----|-----|---------|-----|
| `name` | 문자열 | 필수 | 에이전트의 표시 이름 |
| `description` | 문자열 | 선택 | 목적에 대한 간단한 설명 |
| `system_prompt` | 문자열 | 필수 | 에이전트의 동작에 대한 명령 |
| `allowed_tools` | 목록 | 선택 | 특정 도구로 제한 (기본값: 전체) |

### 예시: 문서화 에이전트

```yaml
# .claude/agents/doc-writer.yaml
name: "Documentation Writer"
description: "프로젝트 문서를 생성하고 업데이트합니다"

system_prompt: |
  당신은 기술 문서 전문가입니다. 코드베이스에 대한 명확하고 정확한 문서를
  작성하는 것이 당신의 역할입니다.

  가이드라인:
  - 프로젝트의 기존 문서 스타일 사용
  - 실제 코드베이스의 코드 예제 포함 (만들어낸 예제 사용 금지)
  - 대상 독자에게 맞게 작성: 중급 개발자
  - 100줄이 넘는 문서에는 목차 포함
  - 해당되는 경우 시맨틱 버저닝 참조 사용
  - 관련 문서 교차 참조

  출력 형식: 프로젝트 컨벤션을 따르는 Markdown 파일.

allowed_tools:
  - Glob
  - Grep
  - Read
  - Edit
  - Write
```

### 예시: 보안 감사 에이전트

```yaml
# .claude/agents/security-auditor.yaml
name: "Security Auditor"
description: "코드베이스에서 보안 취약점을 스캔합니다"

system_prompt: |
  당신은 웹 애플리케이션 보안 전문 보안 감사자입니다.
  다음을 포함한 취약점에 대해 코드베이스를 체계적으로 스캔하세요:

  - SQL 인젝션 및 NoSQL 인젝션
  - 크로스사이트 스크립팅 (XSS)
  - 인증 및 권한 부여 결함
  - 민감한 데이터 노출 (하드코딩된 비밀, API 키)
  - 안전하지 않은 역직렬화
  - 누락된 보안 헤더
  - 의존성 취약점

  각 발견 사항에 대해 다음을 보고하세요:
  - CWE ID (해당되는 경우)
  - CVSS 점수 추정
  - 파일 경로 및 줄 번호
  - 개념 증명 (안전하게 시연 가능한 경우)
  - 코드가 포함된 수정 권고 사항

  심각도에 따라 발견 사항의 우선순위를 지정하세요. 파일을 수정하지 마세요.

allowed_tools:
  - Glob
  - Grep
  - Read
  - Bash    # 보안 스캐닝 도구 실행용
```

### 커스텀 에이전트 호출

커스텀 에이전트는 Task 도구를 사용하여 서브에이전트로 호출되며, 이름으로 참조됩니다:

```python
# 메인 세션이 커스텀 에이전트를 실행
Task(
    subagent_type="code-reviewer",  # YAML 파일명과 일치
    prompt="""마지막 커밋의 변경사항을 리뷰해줘.
    src/payments/의 새로운 결제 처리 모듈에 특히 집중해줘."""
)
```

---

## 8. 서브에이전트 사용 vs. 직접 작업

모든 작업이 위임을 통해 이점을 얻는 것은 아닙니다. 다음은 결정 프레임워크입니다:

### 서브에이전트를 사용해야 하는 경우

| 시나리오 | 서브에이전트 유형 | 이유 |
|---------|-------------|------|
| 익숙하지 않은 코드베이스 영역 탐색 | Explore | 메인 세션의 컨텍스트 절약 |
| 라이브러리 선택 연구 | Plan | 웹 접근 + 코드 분석 |
| 독립적인 모듈 구현 | General-Purpose | 병렬 실행 |
| 테스트 실행 및 실패 수정 | General-Purpose | 격리된 실패 처리 |
| 문서 번역 | General-Purpose | 병렬화 가능, 기계적 |
| 많은 파일에 걸친 코드 품질 분석 | Explore | 광범위한 읽기 접근 필요 |

### 서브에이전트를 사용하지 말아야 하는 경우

| 시나리오 | 이유 |
|---------|------|
| 빠른 단일 파일 편집 | 서브에이전트 실행 오버헤드가 이점을 초과 |
| 메인 세션의 컨텍스트가 필요한 작업 | 서브에이전트가 대화 기록 없음 |
| 많은 상호의존성이 있는 작업 | 순차적 의존성이 병렬성을 무효화 |
| 대화형, 반복적인 작업 | 서브에이전트가 후속 질문을 할 수 없음 |
| 소규모의 잘 이해된 코드베이스 | 메인 세션이 직접 처리 가능 |

### 결정 흐름도

```
작업이 복잡한가 (10개 이상의 파일 또는 5개 이상의 단계)?
├── 아니오 → 메인 세션에서 직접 처리
└── 예 ↓
    대화 기록이 필요한가?
    ├── 예 → 직접 처리 (또는 프롬프트에 컨텍스트 포함)
    └── 아니오 ↓
        독립적인 부분으로 분할할 수 있는가?
        ├── 예 → 병렬 서브에이전트 사용
        └── 아니오 ↓
            파일 수정이 필요한가?
            ├── 아니오 → Explore 또는 Plan 서브에이전트 사용
            └── 예 → General-Purpose 서브에이전트 사용
```

---

## 9. 모범 사례

### 9.1 자기 완결적인 프롬프트 작성

서브에이전트는 대화에 대한 기억이 없습니다. 모든 프롬프트는 자기 완결적이어야 합니다:

```python
# 필요한 모든 컨텍스트 포함
Task(
    subagent_type="general-purpose",
    prompt="""프로젝트: Flask 웹 애플리케이션
    구조: app.py (메인), models.py (SQLAlchemy), templates/ (Jinja2)
    데이터베이스: 검색을 위한 FTS5가 있는 SQLite
    포트: 5050

    작업: 다음을 수행하는 /api/search 엔드포인트 추가:
    1. ?q=<쿼리> 파라미터가 있는 GET 요청 수락
    2. 기존 FTS5 search_index 테이블 사용
    3. JSON 반환: {"results": [...], "count": N, "query": "..."}
    4. 빈 쿼리를 400 에러로 처리
    5. 요청당 50개로 결과 제한

    app.py의 기존 라우트 패턴을 따라줘.
    구현 후 테스트 실행."""
)
```

### 9.2 올바른 서브에이전트 유형 선택

**최소 권한 원칙**을 사용하세요: 서브에이전트에게 필요한 도구만 제공하세요.

```python
# 분석 작업 → explore 사용 (쓰기 접근 불필요)
Task(subagent_type="explore", prompt="모듈별 코드 줄 수 계산...")

# 연구 작업 → plan 사용 (웹은 필요하지만 파일 편집은 불필요)
Task(subagent_type="plan", prompt="OAuth 2.0 PKCE 흐름 연구...")

# 구현 작업 → general-purpose 사용 (모든 도구 필요)
Task(subagent_type="general-purpose", prompt="OAuth 로그인 구현...")
```

### 9.3 예상 출력 형식 지정

서브에이전트에게 원하는 결과 형식을 정확히 알려주세요:

```python
Task(
    subagent_type="explore",
    prompt="""src/api/의 테스트 커버리지 격차를 분석해줘.

    다음 형식으로 결과를 반환해줘:

    ## 커버리지 분석

    ### 잘 테스트됨 (>80% 커버리지)
    - file.py: 테스트된 내용 설명

    ### 부분적으로 테스트됨 (40-80%)
    - file.py: 누락된 내용

    ### 테스트되지 않음 (<40%)
    - file.py: 테스트가 필요한 내용

    ### 권장 테스트 추가 (우선순위 순)
    1. 테스트 이름: 설명, 예상 노력"""
)
```

### 9.4 중복 작업 피하기

메인 세션에서 이미 한 것을 서브에이전트에게 실행시키지 마세요:

```python
# 나쁜 예: 메인 세션이 이미 이 파일을 읽었음
# (메인 세션이 이미 읽은 파일 내용을 읽는 경우)
Task(prompt="src/config.py를 읽고 데이터베이스 URL을 알려줘...")

# 좋은 예: 정보를 직접 전달
Task(prompt="데이터베이스 URL은 postgres://localhost:5432/mydb입니다. "
           "최대 20개 연결로 연결 풀링을 설정해줘...")
```

### 9.5 서브에이전트 실패를 우아하게 처리

서브에이전트는 실패할 수 있습니다. 대비하세요:

- 에러나 불완전한 결과에 대해 서브에이전트의 출력 확인
- 서브에이전트가 실패하면 수정된 프롬프트로 재시도
- 중요한 작업은 진행하기 전에 서브에이전트의 작업 검증
- 다른 서브에이전트의 출력을 검증하기 위해 리뷰 서브에이전트 사용 고려

---

## 10. 일반적인 패턴과 레시피

### 패턴 1: 탐색 후 구현

```python
# 1단계: 코드베이스 영역 탐색
analysis = Task(
    subagent_type="explore",
    prompt="src/auth/의 인증 시스템을 분석해줘. "
           "모든 파일, 목적, 연결 방식을 매핑해줘."
)

# 2단계: 분석을 사용하여 구현 안내
Task(
    subagent_type="general-purpose",
    prompt=f"""인증 시스템 분석을 바탕으로:
    {analysis}

    이중 인증(TOTP) 지원을 추가해줘.
    위에서 파악된 기존 코드 패턴을 따라줘."""
)
```

### 패턴 2: 병렬 분석 및 병합

```python
# 병렬 탐색 에이전트 실행
frontend_analysis = Task(
    subagent_type="explore",
    prompt="src/components/의 프론트엔드 코드 품질 분석..."
)

backend_analysis = Task(
    subagent_type="explore",
    prompt="src/api/의 백엔드 코드 품질 분석..."
)

database_analysis = Task(
    subagent_type="explore",
    prompt="src/models/의 데이터베이스 스키마 및 쿼리 분석..."
)

# 메인 세션이 세 가지 분석을 종합하고
# 통합된 개선 계획 수립
```

### 패턴 3: 검증을 포함한 구현

```python
# 1단계: 구현
Task(
    subagent_type="general-purpose",
    prompt="src/features/에 기능 X 구현..."
)

# 2단계: 별도의 서브에이전트로 검증
Task(
    subagent_type="explore",
    prompt="src/features/에서 기능 X의 구현을 리뷰해줘. "
           "정확성, 엣지 케이스, 에러 처리, "
           "코드베이스 스타일과의 일관성을 확인해줘."
)
```

### 패턴 4: 팬아웃(Fan-Out) / 팬인(Fan-In)

```python
# 팬아웃: 독립적인 모듈에 대한 병렬 작업
for module in ["users", "products", "orders", "payments"]:
    Task(
        subagent_type="general-purpose",
        prompt=f"src/api/{module}/의 모든 엔드포인트에 입력 유효성 검사 추가. "
               f"zod 스키마 사용. "
               f"각 검증기에 대한 테스트 작성."
    )

# 팬인: 메인 세션이 모든 모듈이 함께 작동하는지 검증
# (모든 서브에이전트 완료 후)
```

---

## 11. 연습 문제

### 연습 1: 코드베이스 탐색

이전에 본 적 없는 대규모 Python 프로젝트가 있습니다. 다음에 대한 포괄적인 이해를 제공할 세 가지 Explore 서브에이전트를 위한 프롬프트를 작성하세요:
1. 프로젝트의 아키텍처와 모듈 구조
2. 테스트 전략 및 커버리지
3. 의존성 그래프 및 외부 서비스 통합

### 연습 2: 병렬 번역 파이프라인

병렬 General-Purpose 서브에이전트를 사용하여 10개의 Markdown 레슨 파일을 영어에서 한국어로 번역하는 워크플로를 설계하세요. 다음을 고려하세요:
- 실행할 서브에이전트 수 (병렬성과 속도 제한 간의 균형)
- 각 서브에이전트에 필요한 컨텍스트
- 번역 품질 검증 방법

### 연습 3: 커스텀 에이전트 정의

다음과 같은 커스텀 에이전트를 위한 YAML 설정을 생성하세요:
- 데이터베이스 스키마 변경을 위한 "마이그레이션 어시스턴트" 역할
- 코드베이스를 읽고 커맨드를 실행할 수 있지만 직접 편집은 불가
- 현재 스키마 분석, 마이그레이션 SQL 제안, 유효성 검사
- 롤백 전략이 포함된 마이그레이션 계획 반환

### 연습 4: 의사 결정

각 시나리오에 대해 서브에이전트를 사용할지 직접 작업할지 결정하세요. 선택에 대한 이유를 설명하세요:
1. 3개 파일에서 사용된 변수 이름 변경
2. 2000줄의 모놀리식 파일을 10개 모듈로 리팩토링
3. 기존 테스트 파일에 단일 테스트 케이스 추가
4. 30개 엔드포인트에 대한 API 문서 생성
5. 특정 테스트가 왜 간헐적으로 실패하는지 조사

---

## 12. 참고 자료

- [Claude Code 문서: 서브에이전트](https://docs.anthropic.com/en/docs/claude-code)
- [Claude Code 문서: Task 도구](https://docs.anthropic.com/en/docs/claude-code)
- [Anthropic 블로그: 멀티에이전트 패턴](https://www.anthropic.com/engineering)
- [Claude Code GitHub: 에이전트 설정](https://github.com/anthropics/claude-code)

---

## 다음 단계

다음 레슨인 [에이전트 팀](./08_Agent_Teams.md)에서는 개별 서브에이전트에서 조율된 에이전트 팀으로 이동합니다. 여러 특화된 에이전트가 작업 목록을 공유하고, 진행 상황을 소통하고, 대규모 프로젝트에서 함께 작업하는 방법을 배우게 됩니다 — 이 레슨의 위임 패턴을 한 단계 더 발전시킵니다.

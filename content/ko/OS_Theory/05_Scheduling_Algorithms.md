# 스케줄링 알고리즘

**이전**: [CPU 스케줄링 기초](./04_CPU_Scheduling_Basics.md) | **다음**: [고급 스케줄링](./06_Advanced_Scheduling.md)

---

## 학습 목표(Learning Objectives)

이 레슨을 완료하면 다음을 할 수 있습니다:

1. FCFS 스케줄링을 구현하고 성능을 저하시키는 호위 효과(Convoy Effect)를 식별할 수 있습니다
2. 간트 차트(Gantt Chart)를 사용하여 SJF 스케줄링의 평균 대기 시간과 총 처리 시간을 계산할 수 있습니다
3. SJF(비선점)와 SRTF(선점)를 비교하고, 선점이 성능을 개선하는 경우를 설명할 수 있습니다
4. 우선순위 스케줄링을 설명하고, 기아(Starvation) 문제와 에이징(Aging)을 통한 해결 방법을 분석할 수 있습니다
5. 타임 퀀텀(Time Quantum) 크기의 함수로 Round Robin 성능을 분석하고, 응답성과 컨텍스트 스위치 오버헤드 간의 트레이드오프를 파악할 수 있습니다
6. 주어진 워크로드 유형(배치, 대화형, 실시간)에 가장 적합한 스케줄링 알고리즘을 평가할 수 있습니다

---

"최선의" 스케줄링 알고리즘은 하나로 정해져 있지 않습니다 -- 각 알고리즘은 공정성, 처리량, 응답 시간 사이에서 서로 다른 트레이드오프를 선택합니다. 이러한 알고리즘을 이해하면 CPU가 완전히 부하되지 않은 상황에서도 프로그램이 느려지는 이유를 추론하는 데 도움이 됩니다. 이 레슨에서는 FCFS, SJF, SRTF, Priority, Round Robin의 동작 원리를 학습하고, 간트 차트를 통해 평균 대기 시간과 총 처리 시간을 계산하는 방법을 배웁니다.

## 목차

1. [FCFS (First-Come, First-Served)](#1-fcfs-first-come-first-served)
2. [SJF (Shortest Job First)](#2-sjf-shortest-job-first)
3. [SRTF (Shortest Remaining Time First)](#3-srtf-shortest-remaining-time-first)
4. [Priority Scheduling](#4-priority-scheduling)
5. [Round Robin](#5-round-robin)
6. [알고리즘 비교](#6-알고리즘-비교)
7. [연습 문제](#7-연습-문제)

---

## 1. FCFS (First-Come, First-Served)

### 개념

```
FCFS = 먼저 도착한 프로세스를 먼저 처리
     = 가장 간단한 스케줄링 알고리즘
     = 비선점 (Non-preemptive)

┌─────────────────────────────────────────────────────────┐
│                      FCFS 동작                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Ready Queue (FIFO):                                   │
│  ┌───┐   ┌───┐   ┌───┐   ┌───┐                         │
│  │P1 │ → │P2 │ → │P3 │ → │P4 │ →  CPU                  │
│  └───┘   └───┘   └───┘   └───┘                         │
│  먼저     두번째   세번째   네번째                       │
│  도착     도착     도착     도착                         │
│                                                         │
│  실행 순서: P1 → P2 → P3 → P4                          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 예제 1: 기본

```
입력:
┌──────────┬───────────┬───────────┐
│ 프로세스  │ 도착 시간  │ 실행 시간  │
├──────────┼───────────┼───────────┤
│    P1    │     0     │    24     │
│    P2    │     0     │     3     │
│    P3    │     0     │     3     │
└──────────┴───────────┴───────────┘

간트 차트 (순서: P1 → P2 → P3):
┌────────────────────────────────────┬──────┬──────┐
│               P1                   │  P2  │  P3  │
└────────────────────────────────────┴──────┴──────┘
0                                   24     27     30

왜 이 순서인가? FCFS는 엄격한 도착 순서입니다. 세 프로세스 모두
시간 0에 도착했으므로 제출 순서대로 P1이 먼저 실행됩니다.
P2와 P3(실행 시간=3)은 P1이 끝날 때까지 24ms를 기다려야 합니다
-- 이것이 호위 효과(Convoy Effect)의 실제 모습입니다. P2와 P3가
먼저 실행되었다면 평균 대기 시간은 17에서 3으로 줄어들었을 것입니다.

계산:
┌──────────┬────────────┬───────────────────────┐
│ 프로세스  │ 대기 시간   │ 총 처리 시간           │
├──────────┼────────────┼───────────────────────┤
│    P1    │ 0          │ 24 - 0 = 24           │
│    P2    │ 24         │ 27 - 0 = 27           │
│    P3    │ 27         │ 30 - 0 = 30           │
├──────────┼────────────┼───────────────────────┤
│   평균    │ (0+24+27)/3 = 17 │ (24+27+30)/3 = 27│
└──────────┴────────────┴───────────────────────┘
```

### Convoy Effect (호위 효과)

```
┌─────────────────────────────────────────────────────────┐
│                    Convoy Effect                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  긴 프로세스가 먼저 도착하면:                            │
│  ┌────────────────────────┬──┬──┬──┐                    │
│  │          P1 (긴 작업)    │P2│P3│P4│                    │
│  └────────────────────────┴──┴──┴──┘                    │
│  0                        100                           │
│                                                         │
│  짧은 프로세스들이 긴 프로세스를 기다림                   │
│  → 평균 대기 시간 크게 증가                              │
│                                                         │
│  만약 순서가 바뀌었다면 (P2, P3, P4, P1):                │
│  ┌──┬──┬──┬────────────────────────┐                    │
│  │P2│P3│P4│          P1 (긴 작업)    │                    │
│  └──┴──┴──┴────────────────────────┘                    │
│  0  3  6  9                       109                   │
│                                                         │
│  짧은 작업들이 빠르게 완료됨                             │
│  → 평균 대기 시간 감소                                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### FCFS 특징

```
┌──────────┬─────────────────────────────────────────────┐
│   장점    │ • 구현이 매우 간단 (FIFO 큐)                 │
│          │ • 기아(Starvation) 없음                     │
│          │ • 공정함 (먼저 온 순서대로)                   │
├──────────┼─────────────────────────────────────────────┤
│   단점    │ • Convoy Effect 발생 가능                   │
│          │ • 평균 대기 시간이 길어질 수 있음             │
│          │ • I/O-bound 프로세스에 불리                  │
├──────────┼─────────────────────────────────────────────┤
│ 적합한 상황│ • 모든 프로세스의 실행 시간이 비슷한 경우    │
│          │ • 배치 시스템                               │
└──────────┴─────────────────────────────────────────────┘
```

**FCFS가 단순하지만 위험한 이유**: FCFS는 FIFO 큐만 있으면 됩니다 -- 비교도, 예측도, 우선순위 관리도 필요 없습니다. 따라서 구현이 매우 쉽고 기아(Starvation)가 발생하지 않습니다. 그러나 이 단순함에는 대가가 있습니다: 실행 시간(Burst Time)을 완전히 무시합니다. 단 하나의 긴 프로세스가 수십 개의 짧은 프로세스를 막아서 호위 효과(Convoy Effect)를 일으킬 수 있습니다. 이것이 FCFS가 모든 프로세스의 실행 시간이 비슷한 경우(순서가 큰 차이를 만들지 않는 경우)나 응답 시간이 중요하지 않은 배치 시스템(Batch System)에서만 허용되는 이유입니다.

---

## 2. SJF (Shortest Job First)

### 개념

```
SJF = 실행 시간이 가장 짧은 프로세스를 먼저 실행
    = 최적의 평균 대기 시간 제공 (비선점 경우)
    = 비선점 (Non-preemptive)

┌─────────────────────────────────────────────────────────┐
│                      SJF 동작                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Ready Queue에서 실행 시간이 가장 짧은 것 선택:          │
│                                                         │
│  ┌───┐   ┌───┐   ┌───┐   ┌───┐                         │
│  │P1 │   │P2 │   │P3 │   │P4 │                         │
│  │24 │   │ 3 │   │ 3 │   │ 5 │  ← 실행 시간            │
│  └───┘   └───┘   └───┘   └───┘                         │
│                                                         │
│  선택 순서: P2(3) → P3(3) → P4(5) → P1(24)             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 예제 2: SJF 비선점

```
입력:
┌──────────┬───────────┬───────────┐
│ 프로세스  │ 도착 시간  │ 실행 시간  │
├──────────┼───────────┼───────────┤
│    P1    │     0     │     6     │
│    P2    │     2     │     8     │
│    P3    │     4     │     7     │
│    P4    │     5     │     3     │
└──────────┴───────────┴───────────┘

간트 차트:
시간 0: P1만 도착 → P1 실행 (선택의 여지 없음 -- 유일한 프로세스)
시간 6: P1 완료. P2(8), P3(7), P4(3) 대기 중.
        SJF가 가장 짧은 실행 시간 선택 → P4(3) 당선.
        왜? P4를 먼저 끝내면 CPU가 가장 빨리 비어서
        P2와 P3의 추가 대기 시간을 최소화합니다.
시간 9: P4 완료. P2(8)와 P3(7) 남음.
        SJF가 P2(8)보다 P3(7) 선택 -- 더 짧은 실행 시간 우선.
시간 16: P3 완료, P2만 남음 → P2 실행
시간 24: P2 완료

┌──────────┬─────┬──────────┬────────────┐
│    P1    │ P4  │    P3    │     P2     │
└──────────┴─────┴──────────┴────────────┘
0          6     9         16          24

계산:
┌──────────┬─────────────────────────┬───────────────────────┐
│ 프로세스  │ 대기 시간                │ 총 처리 시간           │
├──────────┼─────────────────────────┼───────────────────────┤
│    P1    │ 0 - 0 = 0              │ 6 - 0 = 6             │
│    P2    │ 16 - 2 = 14            │ 24 - 2 = 22           │
│    P3    │ 9 - 4 = 5              │ 16 - 4 = 12           │
│    P4    │ 6 - 5 = 1              │ 9 - 5 = 4             │
├──────────┼─────────────────────────┼───────────────────────┤
│   평균    │ (0+14+5+1)/4 = 5       │ (6+22+12+4)/4 = 11    │
└──────────┴─────────────────────────┴───────────────────────┘
```

### 실행 시간 예측 문제

```
┌─────────────────────────────────────────────────────────┐
│              SJF의 실행 시간 예측 문제                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  문제: 프로세스의 다음 CPU burst 길이를 어떻게 알 수 있나?│
│                                                         │
│  해결책: 과거 기록을 기반으로 예측 (지수 평균)           │
│                                                         │
│  τ(n+1) = α * t(n) + (1 - α) * τ(n)                    │
│                                                         │
│  여기서:                                                │
│  τ(n+1) = 다음 CPU burst 예측값                        │
│  t(n)   = 실제 n번째 CPU burst 값                      │
│  τ(n)   = 이전 예측값                                  │
│  α      = 0 ≤ α ≤ 1 (가중치)                          │
│                                                         │
│  α = 0.5 예시:                                         │
│  ┌───────┬────────┬────────┬────────┐                  │
│  │  n    │ t(n)   │ τ(n)   │ τ(n+1) │                  │
│  ├───────┼────────┼────────┼────────┤                  │
│  │  0    │   -    │  10    │   -    │                  │
│  │  1    │   6    │  10    │   8    │                  │
│  │  2    │   4    │   8    │   6    │                  │
│  │  3    │   6    │   6    │   6    │                  │
│  └───────┴────────┴────────┴────────┘                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**SJF가 평균 대기 시간에 최적이지만 비현실적인 이유**: SJF는 모든 비선점(Non-preemptive) 알고리즘 중 평균 대기 시간을 최소화함이 수학적으로 증명되어 있습니다. 직관은 간단합니다: 짧은 작업을 먼저 실행하면 뒤에 있는 모든 작업의 누적 대기 시간이 줄어듭니다(마트의 소량 계산 전용 레인이 평균 대기를 줄이는 것과 같은 원리). 문제는 OS가 프로세스의 실행 시간(Burst Time)을 사전에 알 수 없다는 것입니다 -- 예측해야 합니다. 지수 평균(Exponential Averaging)은 반복적인 워크로드(예: 비슷한 작업을 반복하는 데이터베이스 쿼리)에서는 잘 작동하지만, 예측 불가능한 워크로드에서는 예측이 크게 빗나가 SJF의 이론적 장점이 사라질 수 있습니다. 또한 짧은 프로세스가 계속 도착하면 긴 프로세스가 무기한 기아 상태(Starvation)에 빠질 수 있습니다.

---

## 3. SRTF (Shortest Remaining Time First)

### 개념

```
SRTF = SJF의 선점 버전
     = 남은 실행 시간이 가장 짧은 프로세스 선택
     = 새 프로세스 도착 시 선점 가능

┌─────────────────────────────────────────────────────────┐
│                      SRTF 동작                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  시간 0: P1(6) 실행 중                                  │
│  시간 2: P2(8) 도착                                    │
│     P1 남은 시간 = 4                                   │
│     P2 남은 시간 = 8                                   │
│     → P1(4) < P2(8) → P1 계속 실행                     │
│                                                         │
│  시간 4: P3(7) 도착                                    │
│     P1 남은 시간 = 2                                   │
│     P2 남은 시간 = 8                                   │
│     P3 남은 시간 = 7                                   │
│     → P1(2) 가장 짧음 → P1 계속 실행                   │
│                                                         │
│  시간 5: P4(3) 도착                                    │
│     P1 남은 시간 = 1                                   │
│     → P1(1) 가장 짧음 → P1 계속 실행                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 예제 3: SRTF

```
입력:
┌──────────┬───────────┬───────────┐
│ 프로세스  │ 도착 시간  │ 실행 시간  │
├──────────┼───────────┼───────────┤
│    P1    │     0     │     8     │
│    P2    │     1     │     4     │
│    P3    │     2     │     9     │
│    P4    │     3     │     5     │
└──────────┴───────────┴───────────┘

간트 차트 분석:
시간 0: P1(8) 실행 시작 -- 유일한 프로세스
시간 1: P2(4) 도착. P1 남은=7, P2 남은=4.
        P2(4) < P1(7) → P1을 선점하고 P2로 전환!
        왜 선점하는가? P2가 더 빨리 끝나므로 다른 모든
        프로세스의 총 누적 대기 시간이 줄어듭니다.
시간 2: P3(9) 도착. P2 남은=3이 여전히 가장 짧음
        (3 < 7 < 9) → P2 계속. 전환할 이유가 없음.
시간 3: P4(5) 도착. P2 남은=2가 여전히 가장 짧음
        (2 < 5 < 7 < 9) → P2 계속. 거의 완료 직전.
시간 5: P2 완료. 비교: P4(5) < P1(7) < P3(9)
        → P4 선택. 남은 시간이 짧을수록 총 대기가 줄어듦.
시간 10: P4 완료. P1(7) < P3(9) → P1 선택.
시간 17: P1 완료. P3(9)만 남음 → P3 선택.
         P3는 항상 남은 시간이 가장 길었기에 가장 오래
         대기함 -- 이것이 기아(Starvation) 위험입니다.
시간 26: P3 완료

┌──┬────────┬──────────┬──────────────┬──────────────────┐
│P1│   P2   │    P4    │      P1      │        P3        │
└──┴────────┴──────────┴──────────────┴──────────────────┘
0  1        5         10             17                 26

계산:
┌──────────┬─────────────────────────────────┬─────────────────────┐
│ 프로세스  │ 대기 시간                        │ 총 처리 시간         │
├──────────┼─────────────────────────────────┼─────────────────────┤
│    P1    │ (10-1)-(0) = 9                 │ 17 - 0 = 17         │
│    P2    │ 0 (선점 후 바로 실행)            │ 5 - 1 = 4           │
│    P3    │ 17 - 2 = 15                    │ 26 - 2 = 24         │
│    P4    │ 5 - 3 = 2                      │ 10 - 3 = 7          │
├──────────┼─────────────────────────────────┼─────────────────────┤
│   평균    │ (9+0+15+2)/4 = 6.5             │ (17+4+24+7)/4 = 13  │
└──────────┴─────────────────────────────────┴─────────────────────┘
```

### SRTF 특징

```
┌──────────┬─────────────────────────────────────────────┐
│   장점    │ • 이론적으로 최적의 평균 대기 시간           │
│          │ • 짧은 프로세스에 우선권                     │
├──────────┼─────────────────────────────────────────────┤
│   단점    │ • 실행 시간 예측 필요                       │
│          │ • 긴 프로세스가 기아 상태에 빠질 수 있음      │
│          │ • 컨텍스트 스위치 오버헤드                   │
├──────────┼─────────────────────────────────────────────┤
│  Starvation│ 짧은 프로세스가 계속 도착하면               │
│  (기아)    │ 긴 프로세스는 영원히 실행되지 못할 수 있음   │
└──────────┴─────────────────────────────────────────────┘
```

---

## 4. Priority Scheduling

### 개념

```
Priority Scheduling = 우선순위가 높은 프로세스를 먼저 실행
                    = 선점/비선점 모두 가능
                    = 낮은 숫자 = 높은 우선순위 (일반적)

┌─────────────────────────────────────────────────────────┐
│                  Priority Scheduling                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Ready Queue에서 우선순위 비교:                          │
│                                                         │
│  ┌───┐   ┌───┐   ┌───┐   ┌───┐                         │
│  │P1 │   │P2 │   │P3 │   │P4 │                         │
│  │ 3 │   │ 1 │   │ 4 │   │ 2 │  ← 우선순위             │
│  └───┘   └───┘   └───┘   └───┘                         │
│                                                         │
│  선택 순서: P2(1) → P4(2) → P1(3) → P3(4)              │
│                                                         │
│  우선순위 결정 기준:                                    │
│  • 내부: 시간 제한, 메모리 요구량, I/O 대 CPU 비율      │
│  • 외부: 사용자 중요도, 비용, 정치적 요소               │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 예제 4: Priority (비선점)

```
입력:
┌──────────┬───────────┬───────────┬──────────┐
│ 프로세스  │ 도착 시간  │ 실행 시간  │ 우선순위  │
├──────────┼───────────┼───────────┼──────────┤
│    P1    │     0     │    10     │    3     │
│    P2    │     0     │     1     │    1     │
│    P3    │     0     │     2     │    4     │
│    P4    │     0     │     1     │    5     │
│    P5    │     0     │     5     │    2     │
└──────────┴───────────┴───────────┴──────────┘
(낮은 숫자 = 높은 우선순위)

간트 차트:
우선순위 순서: P2(1) → P5(2) → P1(3) → P3(4) → P4(5)

┌──┬───────┬────────────┬────┬──┐
│P2│  P5   │     P1     │ P3 │P4│
└──┴───────┴────────────┴────┴──┘
0  1       6           16   18 19

계산:
┌──────────┬────────────┬───────────────────────┐
│ 프로세스  │ 대기 시간   │ 총 처리 시간           │
├──────────┼────────────┼───────────────────────┤
│    P1    │ 6          │ 16                    │
│    P2    │ 0          │ 1                     │
│    P3    │ 16         │ 18                    │
│    P4    │ 18         │ 19                    │
│    P5    │ 1          │ 6                     │
├──────────┼────────────┼───────────────────────┤
│   평균    │ 8.2        │ 12                    │
└──────────┴────────────┴───────────────────────┘
```

### Starvation과 Aging

```
┌─────────────────────────────────────────────────────────┐
│              기아(Starvation) 문제                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  문제 상황:                                             │
│  ┌────────────────────────────────────────────────────┐ │
│  │  Ready Queue:                                      │ │
│  │  P(우선순위 낮음) ──────────────────────────────▶   │ │
│  │        ↑ 높은 우선순위 프로세스가 계속 도착        │ │
│  │  P(고), P(고), P(고), P(고), ...                  │ │
│  │                                                    │ │
│  │  낮은 우선순위 프로세스는 영원히 실행 안 됨         │ │
│  └────────────────────────────────────────────────────┘ │
│                                                         │
│  해결책: Aging (에이징)                                 │
│  ┌────────────────────────────────────────────────────┐ │
│  │  대기 시간이 증가하면 우선순위를 점진적으로 높임     │ │
│  │                                                    │ │
│  │  시간 0: P 우선순위 = 100 (낮음)                   │ │
│  │  시간 10: P 우선순위 = 90                         │ │
│  │  시간 20: P 우선순위 = 80                         │ │
│  │  ...                                              │ │
│  │  시간 100: P 우선순위 = 0 (최고) → 결국 실행됨     │ │
│  │                                                    │ │
│  │  → 기아 문제 해결                                  │ │
│  └────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 5. Round Robin

### 개념

```
Round Robin (RR) = 시분할 시스템을 위한 알고리즘
                 = 각 프로세스에 동일한 시간(Time Quantum) 할당
                 = 선점 (Preemptive)
                 = FCFS + 선점

┌─────────────────────────────────────────────────────────┐
│                   Round Robin 동작                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Time Quantum (타임 퀀텀) = 4ms                         │
│                                                         │
│  Ready Queue (순환):                                   │
│  ┌───┐   ┌───┐   ┌───┐                                 │
│  │P1 │ → │P2 │ → │P3 │ ─┐                              │
│  └───┘   └───┘   └───┘   │                             │
│    ↑                     │                              │
│    └─────────────────────┘                              │
│                                                         │
│  동작:                                                  │
│  1. P1이 4ms 동안 실행                                 │
│  2. 타임 퀀텀 만료 → P1은 Ready Queue 끝으로           │
│  3. P2가 4ms 동안 실행                                 │
│  4. 반복...                                            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 예제 5: Round Robin

```
입력:
┌──────────┬───────────┬───────────┐
│ 프로세스  │ 도착 시간  │ 실행 시간  │
├──────────┼───────────┼───────────┤
│    P1    │     0     │    24     │
│    P2    │     0     │     3     │
│    P3    │     0     │     3     │
└──────────┴───────────┴───────────┘

Time Quantum = 4ms

간트 차트:
시간 0: P1 실행 (4ms)
시간 4: P1 중단 (남은=20), P2 실행 (3ms에 완료)
시간 7: P2 완료, P3 실행 (3ms에 완료)
시간 10: P3 완료, P1 실행 (4ms)
시간 14: P1 중단 (남은=16), 다른 프로세스 없음, P1 실행
시간 18: P1 중단 (남은=12), P1 실행
시간 22: P1 중단 (남은=8), P1 실행
시간 26: P1 중단 (남은=4), P1 실행
시간 30: P1 완료

┌────┬───┬───┬────┬────┬────┬────┬────┐
│ P1 │P2 │P3 │ P1 │ P1 │ P1 │ P1 │ P1 │
└────┴───┴───┴────┴────┴────┴────┴────┘
0    4   7  10   14   18   22   26   30

계산:
┌──────────┬────────────┬───────────────────────┐
│ 프로세스  │ 대기 시간   │ 총 처리 시간           │
├──────────┼────────────┼───────────────────────┤
│    P1    │ 30-24 = 6  │ 30 - 0 = 30           │
│    P2    │ 4 - 0 = 4  │ 7 - 0 = 7             │
│    P3    │ 7 - 0 = 7  │ 10 - 0 = 10           │
├──────────┼────────────┼───────────────────────┤
│   평균    │ (6+4+7)/3 = 5.67│ (30+7+10)/3 = 15.67│
└──────────┴────────────┴───────────────────────┘
```

### Time Quantum 영향

```
┌─────────────────────────────────────────────────────────┐
│              Time Quantum의 영향                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Time Quantum이 매우 크면:                              │
│  ┌─────────────────────────────────────────────────┐    │
│  │  → FCFS와 동일해짐                               │    │
│  │  → 응답 시간 증가                                │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
│  Time Quantum이 매우 작으면:                            │
│  ┌─────────────────────────────────────────────────┐    │
│  │  → 컨텍스트 스위치 오버헤드 증가                  │    │
│  │  → CPU 시간 낭비                                 │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
│  권장 Time Quantum:                                    │
│  • 평균 CPU burst의 80%가 Time Quantum 내에 완료되도록  │
│  • 일반적으로 10~100ms                                 │
│  • Context switch time의 10배 이상                    │
│                                                         │
│  시각화:                                                │
│                                                         │
│  q=∞: │P1(전체)                    │P2(전체)    │P3...  │
│       └────────────────────────────┴───────────┴──...  │
│                                                         │
│  q=1: │P│P│P│P│P│P│...│ ← 컨텍스트 스위치 너무 많음    │
│       └─┴─┴─┴─┴─┴─┴...┘                                │
│                                                         │
│  적절한 q: │──P1──│──P2──│──P1──│──P3──│...│           │
│           └──────┴──────┴──────┴──────┴...┘            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**타임 퀀텀(Time Quantum) 선택이 중요한 이유 -- 골디락스 문제**: 타임 퀀텀은 응답성(Responsiveness)과 오버헤드(Overhead) 사이의 균형을 직접 제어하는 핵심 튜닝 파라미터입니다:

- **너무 작으면** (예: q=1ms, 컨텍스트 스위치 5us): CPU가 매 퀀텀마다 약 0.5%를 컨텍스트 전환에만 씁니다. 프로세스가 많아지면 이 오버헤드가 누적되어 시스템이 실제 작업보다 *관리*에 더 많은 시간을 쓰게 됩니다. 극단적으로(q가 컨텍스트 스위치 시간에 근접하면) 유효 처리량이 거의 0에 수렴합니다.
- **너무 크면** (예: q=10초): 각 프로세스가 CPU를 오래 독점하고 다른 프로세스는 기다려야 합니다. 이는 FCFS와 동일한 동작으로 퇴화하여 Round Robin의 목적을 무산시킵니다. 대화형 사용자는 시스템이 응답하지 않는다고 느낄 것입니다.
- **적절한 값** (일반적으로 10~100ms): 경험 법칙은 전체 CPU 버스트(CPU Burst)의 약 80%가 하나의 퀀텀 내에 완료되도록 설정하는 것입니다. 이렇게 하면 대부분의 프로세스가 선점 없이 완료되어(불필요한 컨텍스트 스위치 회피) 장시간 실행 프로세스도 충분히 자주 중단되어 응답 시간을 낮게 유지합니다.

---

## 6. 알고리즘 비교

### 종합 비교표

```
┌─────────────┬────────┬─────────┬─────────┬─────────────┬──────────┐
│  알고리즘    │  선점   │  기아   │ 평균대기 │    구현      │   특징    │
├─────────────┼────────┼─────────┼─────────┼─────────────┼──────────┤
│ FCFS        │   X    │   X     │  길다   │ 매우 단순   │Convoy효과│
├─────────────┼────────┼─────────┼─────────┼─────────────┼──────────┤
│ SJF         │   X    │   O     │  최적   │ 실행시간예측│ 기아가능 │
├─────────────┼────────┼─────────┼─────────┼─────────────┼──────────┤
│ SRTF        │   O    │   O     │  최적   │ 실행시간예측│ 기아가능 │
├─────────────┼────────┼─────────┼─────────┼─────────────┼──────────┤
│ Priority    │  O/X   │   O     │  다양   │ 우선순위관리│Aging필요 │
├─────────────┼────────┼─────────┼─────────┼─────────────┼──────────┤
│ RR          │   O    │   X     │  중간   │ 단순       │TQ선택중요│
└─────────────┴────────┴─────────┴─────────┴─────────────┴──────────┘
```

### 동일 데이터 비교 예제

```
입력:
┌──────────┬───────────┬───────────┐
│ 프로세스  │ 도착 시간  │ 실행 시간  │
├──────────┼───────────┼───────────┤
│    P1    │     0     │     7     │
│    P2    │     2     │     4     │
│    P3    │     4     │     1     │
│    P4    │     5     │     4     │
└──────────┴───────────┴───────────┘

FCFS:
┌────────────────┬─────────┬──┬─────────┐
│       P1       │    P2   │P3│   P4    │
└────────────────┴─────────┴──┴─────────┘
0                7        11 12        16
평균 대기 시간: (0 + 5 + 7 + 7) / 4 = 4.75
→ P1이 먼저 도착했으므로 먼저 실행됩니다. P2~P4 모두
  P1의 전체 7ms 실행을 기다림 -- 전형적인 호위 효과(Convoy Effect).

SJF (비선점):
┌────────────────┬──┬─────────┬─────────┐
│       P1       │P3│    P4   │   P2    │
└────────────────┴──┴─────────┴─────────┘
0                7  8        12        16
평균 대기 시간: (0 + 10 + 3 + 3) / 4 = 4.00
→ P1이 먼저 실행(시간 0에 유일한 도착). P1 완료 후
  SJF가 P3(1) → P4(4) → P2(4) 순으로 선택. 짧은 작업부터
  처리하여 총 누적 대기 시간을 줄입니다.

SRTF:
┌────┬─────────┬──┬─────────┬────────┐
│ P1 │   P2    │P3│   P4    │   P1   │
└────┴─────────┴──┴─────────┴────────┘
0    2         6  7        11       16
평균 대기 시간: (9 + 0 + 2 + 2) / 4 = 3.25
→ P1이 시작하지만 시간 2에 P2(4)가 도착하여 P1(남은 5)보다
  짧으므로 선점됩니다. 선점을 통해 짧은 작업이 더 빨리 끝나
  비선점 SJF보다 평균 대기 시간을 더 낮춥니다.

RR (q=2):
┌────┬────┬────┬──┬────┬────┬────┐
│ P1 │ P2 │ P1 │P3│ P4 │ P2 │ P1 │
└────┴────┴────┴──┴────┴────┴────┘
0    2    4    6  7    9   11   14   16
평균 대기 시간: 계산 필요...
→ 모든 프로세스가 공평하게 2ms씩 할당받습니다. 기아(Starvation)는
  없지만 필요 이상으로 많은 컨텍스트 스위치 발생 -- 최적성 대신
  공정성을 선택한 대가입니다.

결론: SRTF가 가장 짧은 평균 대기 시간 제공
```

---

## 7. 연습 문제

### 문제 1: FCFS

다음 프로세스에 대해 FCFS 스케줄링을 적용하고 평균 대기 시간을 계산하세요.

| 프로세스 | 도착 시간 | 실행 시간 |
|---------|----------|----------|
| P1 | 0 | 5 |
| P2 | 1 | 3 |
| P3 | 2 | 8 |
| P4 | 3 | 6 |

<details>
<summary>정답 보기</summary>

**간트 차트:**
```
┌───────┬─────┬──────────┬────────┐
│  P1   │ P2  │    P3    │   P4   │
└───────┴─────┴──────────┴────────┘
0       5     8         16       22
```

**계산:**
- P1 대기: 0
- P2 대기: 5 - 1 = 4
- P3 대기: 8 - 2 = 6
- P4 대기: 16 - 3 = 13

**평균 대기 시간:** (0 + 4 + 6 + 13) / 4 = **5.75**

</details>

### 문제 2: SJF (비선점)

문제 1과 동일한 데이터에 대해 SJF(비선점)를 적용하세요.

<details>
<summary>정답 보기</summary>

**간트 차트:**
```
시간 0: P1(5) 실행 (P1만 도착)
시간 5: P1 완료, P2(3), P3(8), P4(6) 중 P2 선택
시간 8: P2 완료, P3(8), P4(6) 중 P4 선택
시간 14: P4 완료, P3 선택
시간 22: P3 완료

┌───────┬─────┬────────┬──────────┐
│  P1   │ P2  │   P4   │    P3    │
└───────┴─────┴────────┴──────────┘
0       5     8       14        22
```

**계산:**
- P1 대기: 0
- P2 대기: 5 - 1 = 4
- P3 대기: 14 - 2 = 12
- P4 대기: 8 - 3 = 5

**평균 대기 시간:** (0 + 4 + 12 + 5) / 4 = **5.25**

</details>

### 문제 3: Round Robin

문제 1과 동일한 데이터에 대해 RR(Time Quantum = 2)를 적용하세요.

<details>
<summary>정답 보기</summary>

**간트 차트:**
```
시간 0-2: P1(남은 3)
시간 2-4: P2(남은 1) - P2가 시간 1에 도착했으므로
시간 4-6: P3(남은 6) - P3가 시간 2에 도착
시간 6-8: P4(남은 4) - P4가 시간 3에 도착
시간 8-10: P1(남은 1)
시간 10-11: P2 완료
시간 11-13: P3(남은 4)
시간 13-15: P4(남은 2)
시간 15-16: P1 완료
시간 16-18: P3(남은 2)
시간 18-20: P4 완료
시간 20-22: P3 완료

┌──┬──┬──┬──┬──┬─┬──┬──┬─┬──┬──┬──┐
│P1│P2│P3│P4│P1│P2│P3│P4│P1│P3│P4│P3│
└──┴──┴──┴──┴──┴─┴──┴──┴─┴──┴──┴──┘
0  2  4  6  8 10 11 13 15 16 18 20 22
```

**대기 시간 계산:**
- P1: 16 - 0 - 5 = 11 (총 처리 16, 실행 5)
- P2: 11 - 1 - 3 = 7 (총 처리 10, 도착 1, 실행 3)
- P3: 22 - 2 - 8 = 12
- P4: 20 - 3 - 6 = 11

**평균 대기 시간:** (11 + 7 + 12 + 11) / 4 = **10.25**

</details>

### 문제 4: Priority (선점)

다음 데이터에 대해 Priority(선점) 스케줄링을 적용하세요.
(낮은 숫자 = 높은 우선순위)

| 프로세스 | 도착 시간 | 실행 시간 | 우선순위 |
|---------|----------|----------|---------|
| P1 | 0 | 4 | 2 |
| P2 | 1 | 3 | 1 |
| P3 | 2 | 2 | 3 |
| P4 | 3 | 5 | 4 |

<details>
<summary>정답 보기</summary>

**간트 차트:**
```
시간 0: P1(우선순위 2) 실행
시간 1: P2(우선순위 1) 도착 → P1 선점, P2 실행
시간 4: P2 완료, P1(우선순위 2), P3(우선순위 3), P4(우선순위 4) 중 P1 선택
시간 7: P1 완료, P3와 P4 중 P3 선택
시간 9: P3 완료, P4 선택
시간 14: P4 완료

┌─┬─────┬─────┬────┬────────────┐
│P1│  P2 │ P1  │ P3 │     P4     │
└─┴─────┴─────┴────┴────────────┘
0 1     4     7    9           14
```

**대기 시간:**
- P1: 4-1 = 3 (시간 1에 선점됨, 시간 4에 재개)
- P2: 0
- P3: 7 - 2 = 5
- P4: 9 - 3 = 6

**평균 대기 시간:** (3 + 0 + 5 + 6) / 4 = **3.5**

</details>

### 문제 5: 알고리즘 선택

다음 상황에 가장 적합한 스케줄링 알고리즘을 선택하고 이유를 설명하세요.

1. 배치 처리 시스템에서 처리량을 최대화하고 싶다
2. 대화형 시스템에서 응답 시간을 최소화하고 싶다
3. 모든 프로세스를 공정하게 처리하고 싶다

<details>
<summary>정답 보기</summary>

1. **SJF (또는 SRTF)**
   - 짧은 작업을 먼저 처리하여 평균 대기 시간 최소화
   - 처리량 최대화
   - 배치 시스템에서는 실행 시간 예측이 가능한 경우가 많음

2. **Round Robin**
   - 모든 프로세스에 빠르게 CPU 시간 할당
   - 응답 시간이 짧음
   - 적절한 Time Quantum 선택이 중요

3. **Round Robin** 또는 **FCFS**
   - 모든 프로세스에 동등한 기회 제공
   - FCFS: 도착 순서대로 공정하게 처리
   - RR: 각 프로세스에 동일한 시간 할당
   - 기아 현상 없음

</details>

---

## 실습 과제

### 실습 1: 스케줄링 알고리즘 비교

`examples/OS_Theory/05_scheduling_sim.py`를 실행하고 출력을 분석하세요.

**과제:**
1. 새로운 프로세스 집합을 추가하세요: P1(0,10), P2(2,5), P3(4,3), P4(6,1), P5(8,7). 네 가지 알고리즘을 모두 실행하고 평균 대기 시간 기준으로 순위를 매기세요
2. `round_robin()`을 수정하여 다른 양자 값(1, 2, 4, 8)을 받도록 하세요. 양자 크기에 따라 평균 대기 시간이 어떻게 변하는지 그래프로 그리세요
3. SJF의 경우, OS는 버스트 시간을 미리 알 수 없습니다. 지수 평균 예측을 구현하세요: `τ_{n+1} = α × t_n + (1-α) × τ_n` (α=0.5)

### 실습 2: 간트 차트 시각화

스케줄링 시뮬레이터에 그래픽 간트 차트(Gantt Chart)를 추가하세요:

**과제:**
1. matplotlib(또는 ASCII 아트)를 사용하여 각 프로세스가 고유한 색상을 가진 색상 코드 간트 차트를 만드세요
2. 주요 이벤트(도착, 완료, 선점)를 보여주는 타임라인을 추가하세요
3. 차트 아래에 프로세스별 메트릭을 표시하세요: 대기 시간, 반환 시간, 응답 시간

### 실습 3: 기아 현상 시연

SJF와 우선순위 스케줄링에서 기아 현상(Starvation)을 시연하는 실험을 설계하세요:

**과제:**
1. 짧은 프로세스가 계속 도착하여 긴 프로세스가 SJF에서 절대 실행되지 않는 워크로드를 만드세요
2. 에이징(Aging)을 구현하세요: 대기 중인 프로세스의 우선순위를 10 시간 단위마다 1씩 증가시키세요
3. 에이징 유무에 따른 최대 대기 시간을 비교하여 에이징이 기아 현상을 제거함을 보여주세요

---

## 연습 문제

### 연습 1: FCFS와 SJF 비교

다음 프로세스 집합에 대해 **FCFS**와 **비선점 SJF(Shortest Job First)** 양쪽의 모든 메트릭을 계산하세요:

| 프로세스 | 도착 시간 | CPU 버스트 |
|----------|----------|------------|
| P1 | 0 | 8 |
| P2 | 1 | 3 |
| P3 | 2 | 6 |
| P4 | 3 | 1 |
| P5 | 4 | 4 |

각 알고리즘에 대해:
1. 간트 차트(Gantt chart)를 그리세요
2. 각 프로세스의 대기 시간(waiting time), 반환 시간(turnaround time), 응답 시간(response time)을 계산하세요
3. 평균 대기 시간과 평균 반환 시간을 계산하세요
4. FCFS에서 호위 효과(convoy effect)가 발생하는지 확인하세요. 발생한다면 어떤 프로세스가 원인인가요?

### 연습 2: SRTF 분석

연습 1과 동일한 프로세스 집합에 **SRTF(Shortest Remaining Time First)**를 적용하세요.

1. 각 선점(preemption) 시점을 표시하여 간트 차트를 그리세요
2. SRTF와 비선점 SJF의 평균 대기 시간을 비교하세요. 어느 쪽이 더 낮고 그 이유는 무엇인가요?
3. t=3 시점에 현재 실행 중인 프로세스의 남은 시간(remaining time)은 얼마인가요? 선점이 발생하나요? 계산을 보여주세요.
4. 비선점 SJF에는 없는 SRTF의 단점 한 가지를 말하세요.

### 연습 3: 라운드 로빈(Round Robin) 타임 퀀텀 트레이드오프

다음 프로세스 집합에 타임 퀀텀(time quantum) q=2와 q=5로 각각 **라운드 로빈(Round Robin)**을 적용하세요.

| 프로세스 | 도착 시간 | CPU 버스트 |
|----------|----------|------------|
| P1 | 0 | 6 |
| P2 | 1 | 4 |
| P3 | 2 | 8 |
| P4 | 3 | 3 |

1. q=2와 q=5에 대해 각각 간트 차트를 그리세요
2. 각각의 평균 대기 시간을 계산하세요
3. 각각의 컨텍스트 스위치(context switch) 횟수를 세세요
4. 표를 채우고 트레이드오프(trade-off)를 설명하세요:

| 퀀텀 | 평균 대기 시간 | 컨텍스트 스위치 | 더 유사한 알고리즘 |
|------|--------------|----------------|-------------------|
| q=2 | | | FCFS 또는 SRTF? |
| q=5 | | | FCFS 또는 SRTF? |

### 연습 4: 기아(Starvation)와 에이징(Aging)

시스템이 비선점 **우선순위 스케줄링(Priority Scheduling)**을 사용합니다(숫자가 낮을수록 우선순위가 높음). t=0에 준비 큐에는:

| 프로세스 | CPU 버스트 | 우선순위 |
|----------|-----------|----------|
| P1 | 10 | 5 (최저) |
| P2 | 2 | 1 |
| P3 | 3 | 2 |
| P4 | 5 | 3 |

우선순위 1의 짧은 프로세스가 4 시간 단위마다 도착합니다. 에이징 없이:

1. P1은 어떻게 되나요? CPU 접근 시간이 있다면 언제인가요?
2. 에이징 정책 적용: 프로세스가 8 시간 단위를 기다릴 때마다 우선순위가 1씩 향상됩니다. 이 정책으로 P1의 우선순위가 1에 도달하는 시간은 언제인가요?
3. 스케줄링에서의 기아(starvation) 현상이 치명적인 문제가 되는 실제 상황을 설명하세요.

### 연습 5: 알고리즘 선택

아래 각 시스템에 대해 {FCFS, SJF, SRTF, Priority, Round Robin} 중 **가장 적합한** 스케줄링 알고리즘을 선택하세요. 각 알고리즘의 구체적인 장단점을 참조하여 선택 이유를 설명하세요.

1. 문서를 제출 순서대로 처리하는 프린트 서버로, 최적화보다 단순성이 중요한 경우
2. 시간 임계 작업이 낮은 우선순위 유지보수 작업보다 먼저 실행되어야 하는 실시간 제어 시스템
3. 대화형 사용자들이 몇 초 안에 빠른 피드백을 기대하는 공유 대학 컴퓨팅 클러스터
4. 정확한 CPU 버스트 이력 데이터가 있고 전체 처리량만이 목표인 배치 처리 시스템
5. 대화형 프로세스와 백그라운드 프로세스 모두를 공정하게 균형잡아야 하는 OS 커널의 프로세스 스케줄러

---

## 다음 단계

- [고급 스케줄링](./06_Advanced_Scheduling.md) - MLFQ, 멀티프로세서 스케줄링, 실시간 스케줄링

---

## 참고 자료

- [OSTEP - Scheduling: The Multi-Level Feedback Queue](https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-mlfq.pdf)
- [Operating System Concepts - Chapter 5](https://www.os-book.com/)
- [Process Scheduling Simulator](https://github.com/topics/process-scheduling-simulator)


# CPU 스케줄링 기초

**이전**: [스레드와 멀티스레딩](./03_Threads_and_Multithreading.md) | **다음**: [스케줄링 알고리즘](./05_Scheduling_Algorithms.md)

---

## 학습 목표(Learning Objectives)

이 레슨을 완료하면 다음을 할 수 있습니다:

1. CPU-I/O 버스트 사이클(CPU-I/O Burst Cycle)을 설명하고 프로세스 동작을 특성화하는 방법을 이해할 수 있습니다
2. CPU 바운드(CPU-bound) 프로세스와 I/O 바운드(I/O-bound) 프로세스를 구별하고 각각의 스케줄링 시사점을 설명할 수 있습니다
3. 처리량(Throughput), 반환 시간(Turnaround Time), 대기 시간(Waiting Time), 응답 시간(Response Time) 등의 스케줄링 기준을 나열하고 우선순위를 매길 수 있습니다
4. 선점 스케줄링(Preemptive Scheduling)과 비선점 스케줄링(Non-preemptive Scheduling)을 구별하고 각각의 결정 시점을 파악할 수 있습니다
5. 다단계 스케줄링 구조에서 장기, 단기, 중기 스케줄러의 역할을 설명할 수 있습니다
6. 디스패처(Dispatcher)가 하는 일과 디스패치 지연 시간(Dispatch Latency) 최소화가 중요한 이유를 설명할 수 있습니다

---

컴퓨터는 수십 개의 프로세스를 동시에 실행하지만 실제 CPU 코어는 몇 개에 불과합니다. CPU 스케줄링은 다음에 CPU를 받을 프로세스를 결정하는 기술이며, 이 결정이 시스템의 반응 속도를 직접적으로 좌우합니다. 이 레슨에서는 CPU-I/O 버스트 사이클, 스케줄링 목표와 메트릭, 선점·비선점 스케줄링의 차이, 그리고 다양한 스케줄러와 디스패처의 역할을 다룹니다.

> **비유 -- 병원 대기실**: CPU 스케줄링(CPU Scheduling)은 병원 대기실과 같습니다. 누가 다음에 진료를 받을지는 긴급도, 도착 시간, 진료 소요 시간에 따라 달라집니다. 5분짜리 간단한 검진 환자가 2시간짜리 수술 상담 환자 뒤에서 기다리고 있다면 당연히 답답할 것입니다 -- 짧은 프로세스가 긴 프로세스 뒤에서 기다리는 것과 같은 이치입니다. 서로 다른 스케줄링 정책은 서로 다른 분류(Triage) 규칙입니다: 먼저 온 순서대로(FCFS), 진료 시간이 짧은 순서대로(SJF), 또는 긴급도가 높은 순서대로(Priority). 모든 병원에 완벽한 단일 규칙이 없듯이, 운영체제에서도 마찬가지입니다.

## 목차

1. [CPU 스케줄링이란?](#1-cpu-스케줄링이란)
2. [CPU Burst와 I/O Burst](#2-cpu-burst와-io-burst)
3. [스케줄링 목표](#3-스케줄링-목표)
4. [선점 vs 비선점 스케줄링](#4-선점-vs-비선점-스케줄링)
5. [스케줄러 종류](#5-스케줄러-종류)
6. [디스패처](#6-디스패처)
7. [연습 문제](#7-연습-문제)

---

## 1. CPU 스케줄링이란?

> **비유**: CPU 스케줄링은 은행 창구 직원이 대기 줄의 고객을 응대하는 것과 같습니다. 어떤 고객은 간단한 거래(CPU 바운드)를 하고, 어떤 고객은 금고를 방문해야 합니다(I/O 바운드). 스케줄러는 공정성, 효율성, 응답성의 균형을 맞추며 다음에 누구를 얼마나 오래 응대할지 결정합니다.

### 정의

```
CPU 스케줄링 = Ready 큐에 있는 프로세스 중
              CPU를 할당할 프로세스를 선택하는 것

┌─────────────────────────────────────────────────────────┐
│                   CPU 스케줄링의 위치                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌────────┐    ┌─────────────────────────────────────┐  │
│  │ New    │───▶│          Ready Queue               │  │
│  │프로세스 │    │  P1 → P2 → P3 → P4 → ...          │  │
│  └────────┘    └─────────────┬───────────────────────┘  │
│                              │                          │
│                              │ CPU 스케줄러가 선택       │
│                              ▼                          │
│                       ┌───────────┐                     │
│                       │    CPU    │                     │
│                       │  (실행)    │                     │
│                       └─────┬─────┘                     │
│                             │                           │
│            ┌────────────────┼────────────────┐          │
│            ▼                ▼                ▼          │
│       ┌─────────┐    ┌───────────┐    ┌─────────┐      │
│       │ 종료    │    │ I/O 대기  │    │Ready로  │      │
│       │(Terminate)│   │ (Wait)   │    │복귀     │      │
│       └─────────┘    └───────────┘    └─────────┘      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 스케줄링이 필요한 이유

```
1. CPU 이용률 최대화
   - CPU가 놀지 않도록 항상 실행할 프로세스 준비

2. 공정한 자원 분배
   - 모든 프로세스에게 적절한 CPU 시간 제공

3. 시스템 성능 최적화
   - 처리량 증가, 응답 시간 감소

4. 멀티태스킹 지원
   - 여러 프로세스가 동시에 실행되는 것처럼 보이게 함

┌──────────────────────────────────────────────────────────┐
│             스케줄링 없이 vs 스케줄링 사용                 │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  스케줄링 없이 (순차 실행):                               │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ P1 (I/O대기)    │ P2 (I/O대기)    │ P3 (I/O대기)   │ │
│  └─────────────────────────────────────────────────────┘ │
│  시간: ████░░░░░░░████░░░░░░░████░░░░                    │
│               CPU 유휴 시간 많음                          │
│                                                          │
│  스케줄링 사용:                                          │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ P1 │ P2 │ P3 │ P1 │ P2 │ P3 │ ...                  │ │
│  └─────────────────────────────────────────────────────┘ │
│  시간: ██████████████████████████                        │
│               CPU 유휴 시간 최소화                        │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

## 2. CPU Burst와 I/O Burst

### Burst란?

```
프로세스 실행 = CPU Burst와 I/O Burst의 반복

┌─────────────────────────────────────────────────────────┐
│                    프로세스 실행 사이클                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  시작 ──▶ CPU Burst ──▶ I/O Burst ──▶ CPU Burst ──▶ ... │
│             │            │            │                 │
│             ▼            ▼            ▼                 │
│          연산 수행      I/O 대기     연산 수행           │
│          (Running)     (Waiting)   (Running)           │
│                                                         │
└─────────────────────────────────────────────────────────┘

시간축 예시:

프로세스 P1:
┌──────┬──────────┬───────┬──────────┬──────┬──────┐
│ CPU  │  I/O     │  CPU  │   I/O    │ CPU  │ 종료  │
│ 10ms │  50ms    │  5ms  │  30ms    │ 8ms  │      │
└──────┴──────────┴───────┴──────────┴──────┴──────┘
```

### CPU-bound vs I/O-bound 프로세스

```
┌──────────────────────────────────────────────────────────┐
│              프로세스 유형에 따른 Burst 패턴              │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  CPU-bound 프로세스 (계산 집약적):                        │
│  ┌────────────────────┬──┬────────────────────┬──┐       │
│  │     긴 CPU burst    │IO│     긴 CPU burst    │IO│       │
│  └────────────────────┴──┴────────────────────┴──┘       │
│  예: 과학 계산, 비디오 인코딩, 컴파일러                    │
│                                                          │
│  I/O-bound 프로세스 (입출력 집약적):                      │
│  ┌──┬─────┬──┬─────┬──┬─────┬──┬─────┐                   │
│  │CP│ I/O │CP│ I/O │CP│ I/O │CP│ I/O │                   │
│  └──┴─────┴──┴─────┴──┴─────┴──┴─────┘                   │
│  예: 텍스트 에디터, 웹 브라우저, 대화형 프로그램           │
│                                                          │
└──────────────────────────────────────────────────────────┘

┌─────────────────┬────────────────┬────────────────────────┐
│      특성        │  CPU-bound    │      I/O-bound        │
├─────────────────┼────────────────┼────────────────────────┤
│ CPU burst 길이  │ 김              │ 짧음                  │
│ I/O burst 빈도  │ 낮음           │ 높음                   │
│ 스케줄링 요구   │ 긴 시간 슬라이스 │ 빠른 응답 시간         │
│ 예시            │ 수치 연산       │ 웹 서버, 데이터베이스   │
└─────────────────┴────────────────┴────────────────────────┘
```

### CPU Burst 분포

```
빈도
 ↑
 │  ██
 │  ██
 │  ████
 │  ██████
 │  ████████
 │  ██████████
 │  ████████████
 │  ██████████████
 │  ████████████████
 │  ██████████████████
 └────────────────────────────────▶ CPU Burst 길이

대부분의 프로세스는 짧은 CPU burst를 가짐
→ I/O-bound 프로세스가 많음
→ 짧은 프로세스를 먼저 처리하면 평균 대기 시간 감소
```

---

## 3. 스케줄링 목표

### 주요 성능 지표

```
┌─────────────────────────────────────────────────────────┐
│                    스케줄링 성능 지표                    │
├───────────────────┬─────────────────────────────────────┤
│ CPU 이용률        │ CPU가 작업을 수행하는 시간의 비율    │
│ (CPU Utilization) │ 목표: 최대화 (40%~90%)              │
├───────────────────┼─────────────────────────────────────┤
│ 처리량            │ 단위 시간당 완료되는 프로세스 수      │
│ (Throughput)      │ 목표: 최대화                        │
├───────────────────┼─────────────────────────────────────┤
│ 총 처리 시간      │ 프로세스 제출 ~ 완료까지 걸린 시간   │
│ (Turnaround Time) │ = 대기 시간 + 실행 시간 + I/O 시간   │
│                   │ 목표: 최소화                        │
├───────────────────┼─────────────────────────────────────┤
│ 대기 시간         │ Ready 큐에서 대기한 총 시간          │
│ (Waiting Time)    │ 목표: 최소화                        │
├───────────────────┼─────────────────────────────────────┤
│ 응답 시간         │ 요청 제출 ~ 첫 응답까지 시간         │
│ (Response Time)   │ 대화형 시스템에서 중요               │
│                   │ 목표: 최소화                        │
└───────────────────┴─────────────────────────────────────┘
```

### 시간 개념 시각화

```
프로세스 P 타임라인:

도착                 완료
  │                   │
  ▼                   ▼
──┬─────────────────────┬─────────────────────┬──▶ 시간
  │                     │                     │
  │◀── 총 처리 시간 (Turnaround Time) ───────▶│
  │                                           │
  │    대기    │  실행  │  대기  │  실행     │
  │◀─ Wait ─▶│       │◀ Wait ▶│           │
  │                                           │
  │◀─▶첫응답                                  │
  │Response                                   │
  │Time                                       │


계산 예시:
┌─────────────────────────────────────────────────────────┐
│ 프로세스 P:                                             │
│   도착 시간 = 0                                         │
│   실행 시간 = 10ms (총 CPU 사용 시간)                    │
│   완료 시간 = 25ms                                      │
│                                                         │
│ 총 처리 시간 (Turnaround) = 완료 - 도착 = 25 - 0 = 25ms  │
│ 대기 시간 (Waiting) = 총처리시간 - 실행시간 = 25 - 10 = 15ms │
└─────────────────────────────────────────────────────────┘
```

**대기 시간(Waiting Time) = 총 처리 시간(Turnaround Time) - 실행 시간(Burst Time)인 이유**: 총 처리 시간은 프로세스가 시스템에 도착한 시점부터 완료될 때까지의 전체 경과 시간입니다. 이 시간 동안 프로세스는 두 가지 중 하나를 합니다: CPU에서 실제로 실행되거나(실행 시간), Ready 큐에서 자기 차례를 기다리거나(대기 시간). 이 두 가지가 전부이므로, 전체 시간에서 실행 시간을 빼면 정확히 대기 시간이 됩니다. 수식으로: `대기 시간 = 총 처리 시간 - 실행 시간`. 이 항등식은 간트 차트(Gantt Chart)에서 완료 시간을 바로 읽어낸 뒤, 큐 진입·이탈을 일일이 추적하지 않고도 대기 시간을 구할 수 있어 특히 유용합니다.

### 목표 간 트레이드오프

```
┌─────────────────────────────────────────────────────────┐
│                   스케줄링 목표 트레이드오프              │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  CPU 이용률 ←─────────────────────▶ 응답 시간           │
│  (최대화)           상충 관계          (최소화)          │
│                                                         │
│  처리량 ←───────────────────────▶ 공정성               │
│  (최대화)        상충 관계        (균등 분배)           │
│                                                         │
│  시스템 유형에 따라 우선순위가 다름:                     │
│                                                         │
│  ┌────────────────┬───────────────────────────────────┐ │
│  │ 배치 시스템     │ 처리량, CPU 이용률 우선            │ │
│  ├────────────────┼───────────────────────────────────┤ │
│  │ 대화형 시스템   │ 응답 시간 우선                    │ │
│  ├────────────────┼───────────────────────────────────┤ │
│  │ 실시간 시스템   │ 마감시간 준수 우선                │ │
│  └────────────────┴───────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 4. 선점 vs 비선점 스케줄링

### 비선점 스케줄링 (Non-preemptive)

```
┌─────────────────────────────────────────────────────────┐
│              비선점 스케줄링 (Non-preemptive)            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  • 프로세스가 CPU를 자발적으로 반환할 때까지 실행         │
│  • CPU를 강제로 빼앗지 않음                             │
│                                                         │
│  CPU 반환 시점:                                         │
│  1. 프로세스 종료                                       │
│  2. I/O 요청으로 대기 상태 전환                         │
│  3. yield() 등으로 자발적 양보                          │
│                                                         │
│  시간축:                                                │
│  ┌──────────────────────────────────────────────────┐   │
│  │ P1 (10ms)              │ P2 (5ms)    │ P3 (3ms) │   │
│  └──────────────────────────────────────────────────┘   │
│  P2, P3가 도착해도 P1이 끝날 때까지 대기                  │
│                                                         │
│  장점: 구현 단순, 컨텍스트 스위치 오버헤드 적음           │
│  단점: 응답 시간 길어질 수 있음, 긴 프로세스가 독점 가능  │
│                                                         │
│  예시 알고리즘: FCFS, SJF (비선점)                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**비선점 스케줄링(Non-preemptive Scheduling)이 존재하는 이유**: 비선점 스케줄링은 프로세스가 자발적으로 CPU를 반환할 때만 결정을 내리면 되므로 구현이 단순합니다. 타이머 인터럽트(Timer Interrupt)를 처리하거나 실행 중간의 컨텍스트 스위치(Context Switch)로 인한 경쟁 상태(Race Condition)를 걱정할 필요가 없습니다. 이러한 단순함 때문에 응답 시간보다 처리량(Throughput)이 중요한 배치 시스템(Batch System)에서 유용합니다. 그러나 단점은 **호위 효과(Convoy Effect)**입니다: 긴 CPU 바운드 프로세스가 먼저 도착하면 뒤에 있는 모든 짧은 프로세스가 대기해야 하므로 평균 대기 시간이 급격히 증가합니다 -- 마치 1차선 도로에서 느린 트럭 뒤에 막히는 것과 같습니다.

### 선점 스케줄링 (Preemptive)

```
┌─────────────────────────────────────────────────────────┐
│                선점 스케줄링 (Preemptive)                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  • 스케줄러가 프로세스의 CPU를 강제로 빼앗을 수 있음      │
│  • 더 중요한 프로세스가 도착하면 즉시 CPU 할당 가능       │
│                                                         │
│  CPU 빼앗는 시점:                                       │
│  1. 타임 슬라이스(Time Quantum) 만료                    │
│  2. 높은 우선순위 프로세스 도착                          │
│  3. I/O 완료로 프로세스가 Ready로 전환                   │
│                                                         │
│  시간축 (Round Robin 예시):                             │
│  ┌──────┬──────┬──────┬──────┬──────┬──────┐           │
│  │  P1  │  P2  │  P3  │  P1  │  P2  │  P1  │           │
│  └──────┴──────┴──────┴──────┴──────┴──────┘           │
│  타임 슬라이스마다 프로세스 교체                         │
│                                                         │
│  장점: 응답 시간 개선, CPU 독점 방지                     │
│  단점: 컨텍스트 스위치 오버헤드, 동기화 이슈 복잡         │
│                                                         │
│  예시 알고리즘: RR, SRTF, Priority (선점)               │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**대화형 시스템(Interactive System)에 선점 스케줄링이 필수적인 이유**: 대화형 시스템(데스크톱, 스마트폰, 웹 서버)에서 사용자는 즉각적인 피드백을 기대합니다. 긴 연산이 실행 중일 때 사용자가 버튼을 클릭하면, 선점 스케줄링(Preemptive Scheduling)은 OS가 해당 연산을 중단하고 UI 스레드에 응답 기회를 줄 수 있도록 보장합니다. 선점 없이는 사용자가 연산이 끝날 때까지 -- 잠재적으로 수 초 또는 수 분 -- 기다려야 합니다. 트레이드오프는 복잡성 증가입니다: OS는 경쟁 상태를 피하기 위해 컨텍스트 스위치를 신중하게 처리해야 하며, 각 전환에는 CPU 시간(일반적으로 1~10 마이크로초)이 소요됩니다. 선점형 SJF(SRTF)는 이론적으로 평균 대기 시간에 최적이지만, 미래의 버스트 길이를 예측해야 합니다 -- 그래서 대부분의 실제 시스템은 타임 슬라이스 기반 Round Robin이나 다단계 피드백 큐(MLFQ)를 사용합니다.

### 비교

```
┌─────────────────┬─────────────────┬─────────────────────┐
│      특성        │    비선점       │       선점           │
├─────────────────┼─────────────────┼─────────────────────┤
│ CPU 빼앗김      │ 불가능          │ 가능                │
├─────────────────┼─────────────────┼─────────────────────┤
│ 응답 시간       │ 길어질 수 있음   │ 짧음                │
├─────────────────┼─────────────────┼─────────────────────┤
│ 컨텍스트 스위치  │ 적음            │ 많음                │
├─────────────────┼─────────────────┼─────────────────────┤
│ 구현 복잡도     │ 낮음            │ 높음                │
├─────────────────┼─────────────────┼─────────────────────┤
│ 동기화 이슈     │ 적음            │ 경쟁 상태 주의 필요  │
├─────────────────┼─────────────────┼─────────────────────┤
│ 적합한 시스템   │ 배치 시스템      │ 대화형/실시간 시스템 │
└─────────────────┴─────────────────┴─────────────────────┘
```

### 스케줄링 결정 시점

```
┌─────────────────────────────────────────────────────────┐
│                CPU 스케줄링 결정 시점                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. Running → Waiting (I/O 요청)         [비선점]        │
│     • 프로세스가 자발적으로 CPU 반환                     │
│                                                         │
│  2. Running → Ready (인터럽트, 타임아웃)  [선점]          │
│     • 타임 슬라이스 만료                                │
│     • 높은 우선순위 프로세스 도착                        │
│                                                         │
│  3. Waiting → Ready (I/O 완료)           [선점 가능]     │
│     • I/O 완료된 프로세스가 현재 프로세스보다             │
│       우선순위가 높으면 선점 가능                        │
│                                                         │
│  4. Running → Terminated (종료)           [비선점]        │
│     • 프로세스 종료, 다음 프로세스 선택 필요             │
│                                                         │
│                                                         │
│  1번, 4번만 있으면: 비선점 스케줄링                      │
│  1~4번 모두 있으면: 선점 스케줄링                        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 5. 스케줄러 종류

### 3단계 스케줄러

```
┌─────────────────────────────────────────────────────────────┐
│                     3단계 스케줄러 구조                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │                   작업 큐 (Job Queue)               │    │
│  │     디스크에 있는 모든 프로세스                      │    │
│  │     ┌───┐ ┌───┐ ┌───┐ ┌───┐ ┌───┐                  │    │
│  │     │P1 │ │P2 │ │P3 │ │P4 │ │...│                  │    │
│  │     └───┘ └───┘ └───┘ └───┘ └───┘                  │    │
│  └───────────────────────┬─────────────────────────────┘    │
│                          │                                  │
│                    장기 스케줄러                             │
│                   (Long-term Scheduler)                    │
│                    • 작업 승인                              │
│                    • 멀티프로그래밍 정도 제어               │
│                    • 실행 빈도: 초~분 단위                  │
│                          │                                  │
│                          ▼                                  │
│  ┌─────────────────────────────────────────────────────┐    │
│  │                   준비 큐 (Ready Queue)             │    │
│  │     메모리에 있는 실행 대기 프로세스                 │    │
│  │     ┌───┐ ┌───┐ ┌───┐                              │    │
│  │     │P1 │→│P2 │→│P3 │                              │    │
│  │     └───┘ └───┘ └───┘                              │    │
│  └──────────────┬────────────────────────┬─────────────┘    │
│                 │                        │                  │
│           단기 스케줄러           중기 스케줄러              │
│         (Short-term Scheduler) (Medium-term Scheduler)     │
│          • CPU 할당                • 스와핑                 │
│          • 실행 빈도: ms 단위       • 메모리 관리            │
│          • 가장 빈번                • 멀티프로그래밍 조절    │
│                 │                        │                  │
│                 ▼                        ▼                  │
│            ┌─────────┐           ┌───────────────┐          │
│            │   CPU   │           │   Suspended   │          │
│            │(Running)│           │    Queue      │          │
│            └─────────┘           └───────────────┘          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 장기 스케줄러 (Long-term Scheduler)

```
┌─────────────────────────────────────────────────────────┐
│               장기 스케줄러 (Job Scheduler)              │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  역할:                                                  │
│  • 디스크의 작업 → 메모리 (Ready Queue)                 │
│  • 어떤 프로세스를 시스템에 들일지 결정                  │
│  • 멀티프로그래밍 정도 (Degree) 제어                    │
│                                                         │
│  결정 기준:                                             │
│  • 시스템 자원 (메모리, CPU) 상태                       │
│  • CPU-bound와 I/O-bound 프로세스의 적절한 혼합          │
│                                                         │
│  실행 빈도: 드물게 (초~분 단위)                         │
│                                                         │
│  현대 시스템:                                           │
│  • 시분할 시스템에서는 거의 사용 안 함                   │
│  • 모든 프로세스를 바로 Ready Queue로                    │
│  • 가상 메모리가 메모리 관리를 담당                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 단기 스케줄러 (Short-term Scheduler)

```
┌─────────────────────────────────────────────────────────┐
│               단기 스케줄러 (CPU Scheduler)              │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  역할:                                                  │
│  • Ready Queue → CPU (Running)                         │
│  • 어떤 프로세스에게 CPU를 할당할지 결정                 │
│                                                         │
│  실행 빈도: 매우 자주 (밀리초 단위)                      │
│  → 빠른 알고리즘이 필수                                 │
│                                                         │
│  호출 시점:                                             │
│  • 타임 슬라이스 만료                                   │
│  • 프로세스 블로킹 (I/O 요청)                           │
│  • 프로세스 종료                                        │
│  • 인터럽트 발생                                        │
│                                                         │
│  사용 알고리즘:                                         │
│  • FCFS, SJF, Priority, Round Robin, MLFQ 등           │
│                                                         │
│  주의: 스케줄러 자체도 CPU 시간을 사용                   │
│       → 스케줄러 오버헤드 최소화 필요                    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 중기 스케줄러 (Medium-term Scheduler)

```
┌─────────────────────────────────────────────────────────┐
│              중기 스케줄러 (Swapper)                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  역할:                                                  │
│  • 스와핑 (Swapping) 관리                               │
│  • 메모리 ↔ 디스크 간 프로세스 이동                      │
│  • 멀티프로그래밍 정도 동적 조절                         │
│                                                         │
│  동작:                                                  │
│  ┌─────────────────────────────────────────────────┐    │
│  │    메모리 (Ready/Blocked)                       │    │
│  │    ┌───┐ ┌───┐ ┌───┐                           │    │
│  │    │P1 │ │P2 │ │P3 │  ← 메모리 부족 시         │    │
│  │    └───┘ └───┘ └───┘       P3를 swap out       │    │
│  └─────────────────────────────────────────────────┘    │
│              │ swap out          ▲ swap in             │
│              ▼                   │                     │
│  ┌─────────────────────────────────────────────────┐    │
│  │    디스크 (Suspended)                           │    │
│  │    ┌───┐ ┌───┐                                 │    │
│  │    │P4 │ │P5 │  → 메모리 여유 시 swap in       │    │
│  │    └───┘ └───┘                                 │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
│  Swap out 기준:                                         │
│  • 오래 대기 중인 프로세스                              │
│  • 낮은 우선순위 프로세스                               │
│  • 메모리를 많이 사용하는 프로세스                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 스케줄러 비교

```
┌────────────────────┬────────────────┬────────────────┬────────────────┐
│       특성          │   장기 스케줄러 │  단기 스케줄러  │  중기 스케줄러  │
├────────────────────┼────────────────┼────────────────┼────────────────┤
│ 다른 이름          │ Job Scheduler  │ CPU Scheduler  │ Swapper       │
├────────────────────┼────────────────┼────────────────┼────────────────┤
│ 전환               │ 디스크→메모리   │ Ready→Running  │ 메모리↔디스크  │
├────────────────────┼────────────────┼────────────────┼────────────────┤
│ 실행 빈도          │ 드물게         │ 매우 자주      │ 가끔           │
├────────────────────┼────────────────┼────────────────┼────────────────┤
│ 속도 요구          │ 느려도 됨      │ 매우 빨라야 함 │ 중간           │
├────────────────────┼────────────────┼────────────────┼────────────────┤
│ 멀티프로그래밍     │ 전체 수 제어    │ 영향 없음      │ 동적 조절      │
├────────────────────┼────────────────┼────────────────┼────────────────┤
│ 현대 시스템        │ 거의 사용 X    │ 핵심 사용      │ 가상메모리 대체 │
└────────────────────┴────────────────┴────────────────┴────────────────┘
```

---

## 6. 디스패처

### 디스패처란?

```
┌─────────────────────────────────────────────────────────┐
│                    디스패처 (Dispatcher)                 │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  디스패처 = CPU 스케줄러가 선택한 프로세스에게            │
│            실제로 CPU 제어권을 넘겨주는 모듈             │
│                                                         │
│  스케줄러와 디스패처 관계:                               │
│  ┌───────────────┐          ┌───────────────┐           │
│  │   스케줄러     │ ─결정──▶ │   디스패처    │ ─실행──▶   │
│  │ "P3를 실행"   │          │ CPU 할당 수행 │           │
│  └───────────────┘          └───────────────┘           │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 디스패처 수행 작업

```
┌─────────────────────────────────────────────────────────┐
│                  디스패처 수행 작업                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 컨텍스트 스위치                                     │
│     • 현재 프로세스 상태를 PCB에 저장                   │
│     • 새 프로세스 상태를 PCB에서 복원                   │
│                                                         │
│  2. 사용자 모드로 전환                                  │
│     • 커널 모드 → 사용자 모드                           │
│                                                         │
│  3. 프로그램 재시작                                     │
│     • 새 프로세스의 적절한 위치로 점프                   │
│     • PC (프로그램 카운터) 설정                         │
│                                                         │
│  시간축:                                                │
│  ┌────────┬──────────────────┬────────────────────┐     │
│  │ P1 실행 │  디스패처 실행    │      P2 실행       │     │
│  │        │(디스패치 지연시간) │                   │     │
│  └────────┴──────────────────┴────────────────────┘     │
│           ↑                                             │
│      Dispatch Latency (가능한 짧아야 함)                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 디스패치 지연 시간 (Dispatch Latency)

```
디스패치 지연 시간 = 현재 프로세스 중단 ~ 새 프로세스 실행 시작

구성 요소:
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  1. 인터럽트 처리 시간                                  │
│  2. 현재 프로세스 상태 저장                             │
│  3. 스케줄링 알고리즘 실행                              │
│  4. 새 프로세스 상태 복원                               │
│  5. 캐시/TLB 관련 비용                                  │
│                                                         │
│  일반적으로: 1~10 마이크로초                            │
│                                                         │
│  최소화 방법:                                           │
│  • 효율적인 스케줄링 알고리즘                           │
│  • 최적화된 컨텍스트 스위치 코드                        │
│  • 하드웨어 지원 활용                                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 7. 연습 문제

### 문제 1: 기본 개념

다음 용어를 정의하세요.

1. CPU Burst
2. 처리량 (Throughput)
3. 총 처리 시간 (Turnaround Time)
4. 선점 스케줄링

<details>
<summary>정답 보기</summary>

1. **CPU Burst**: 프로세스가 CPU를 연속적으로 사용하는 시간. I/O 요청 없이 계산만 수행하는 구간.

2. **처리량 (Throughput)**: 단위 시간당 완료되는 프로세스의 수. 시스템 효율성의 지표.

3. **총 처리 시간 (Turnaround Time)**: 프로세스가 시스템에 제출된 시점부터 완료될 때까지 걸린 총 시간. 대기 시간 + 실행 시간 + I/O 시간.

4. **선점 스케줄링**: 스케줄러가 실행 중인 프로세스의 CPU를 강제로 빼앗을 수 있는 스케줄링 방식. 타임 슬라이스 만료, 높은 우선순위 프로세스 도착 등의 시점에 발생.

</details>

### 문제 2: 시간 계산

다음 프로세스에 대해 평균 대기 시간과 평균 총 처리 시간을 계산하세요.
(FCFS 스케줄링, 모든 프로세스가 시간 0에 도착)

| 프로세스 | 실행 시간 |
|---------|----------|
| P1 | 24 |
| P2 | 3 |
| P3 | 3 |

<details>
<summary>정답 보기</summary>

**간트 차트:**
```
┌────────────────────────┬───┬───┐
│          P1            │P2 │P3 │
└────────────────────────┴───┴───┘
0                       24  27  30
```

**대기 시간:**
- P1: 0
- P2: 24
- P3: 27
- 평균 대기 시간 = (0 + 24 + 27) / 3 = 17

**총 처리 시간:**
- P1: 24 - 0 = 24
- P2: 27 - 0 = 27
- P3: 30 - 0 = 30
- 평균 총 처리 시간 = (24 + 27 + 30) / 3 = 27

</details>

### 문제 3: 스케줄러 식별

다음 설명에 맞는 스케줄러를 고르세요.

A. 장기 스케줄러
B. 단기 스케줄러
C. 중기 스케줄러

1. ( ) 밀리초 단위로 매우 자주 실행되어야 한다.
2. ( ) CPU-bound와 I/O-bound 프로세스를 적절히 섞어 선택한다.
3. ( ) 메모리가 부족할 때 프로세스를 디스크로 스왑한다.
4. ( ) CPU를 할당할 다음 프로세스를 결정한다.

<details>
<summary>정답 보기</summary>

1. (B) 단기 스케줄러 - 매우 자주 실행되어 빠른 알고리즘 필요
2. (A) 장기 스케줄러 - 시스템 균형을 위해 프로세스 혼합 고려
3. (C) 중기 스케줄러 - 스와핑 담당
4. (B) 단기 스케줄러 - CPU 스케줄링 담당

</details>

### 문제 4: 선점 vs 비선점

다음 상황에서 스케줄링 결정이 선점인지 비선점인지 구분하세요.

1. 프로세스가 exit()를 호출하여 종료
2. 타임 슬라이스가 만료되어 다른 프로세스로 전환
3. 프로세스가 I/O를 요청하여 대기 상태로 전환
4. 높은 우선순위의 프로세스가 Ready 큐에 도착하여 현재 프로세스를 중단

<details>
<summary>정답 보기</summary>

1. **비선점** - 프로세스가 자발적으로 종료
2. **선점** - 스케줄러가 강제로 CPU를 빼앗음
3. **비선점** - 프로세스가 자발적으로 CPU 반환
4. **선점** - 스케줄러가 강제로 CPU를 빼앗음

</details>

### 문제 5: 디스패처

디스패처가 수행하는 세 가지 주요 작업을 설명하고, 디스패치 지연 시간이 긴 경우 시스템에 어떤 영향을 미치는지 서술하세요.

<details>
<summary>정답 보기</summary>

**디스패처의 주요 작업:**
1. **컨텍스트 스위치**: 현재 프로세스의 상태(레지스터, PC 등)를 PCB에 저장하고, 새 프로세스의 상태를 PCB에서 복원
2. **모드 전환**: 커널 모드에서 사용자 모드로 전환
3. **점프**: 새 프로세스의 적절한 위치(PC가 가리키는 주소)로 제어 이동

**디스패치 지연 시간이 긴 경우의 영향:**
- CPU 이용률 감소 (실제 작업에 사용되는 시간 비율 감소)
- 응답 시간 증가 (사용자 요청에 대한 반응 느려짐)
- 처리량 감소 (단위 시간당 완료되는 프로세스 수 감소)
- 시스템 오버헤드 증가

</details>

---

## 실습 과제

### 실습 1: CPU 버스트 분석

실제 워크로드의 CPU 버스트(Burst) 패턴을 분석하는 스크립트를 작성하세요:

```python
import time, random

def simulate_workload():
    """교대하는 CPU와 I/O 버스트를 시뮬레이션합니다."""
    bursts = []
    for _ in range(20):
        # CPU 버스트
        cpu_start = time.perf_counter()
        total = sum(range(random.randint(10000, 100000)))
        cpu_time = time.perf_counter() - cpu_start
        bursts.append(("CPU", cpu_time))

        # I/O 버스트 (시뮬레이션)
        io_time = random.uniform(0.001, 0.01)
        time.sleep(io_time)
        bursts.append(("IO", io_time))

    return bursts
```

**과제:**
1. 시뮬레이션을 실행하고 버스트 비율에 따라 워크로드를 CPU 바운드(CPU-bound) 또는 I/O 바운드(I/O-bound)로 분류하세요
2. CPU 버스트 지속 시간의 히스토그램을 그리세요 — 이론에서 설명하는 지수 분포와 일치하나요?
3. CPU 활용률을 계산하세요: `sum(CPU 버스트) / 총 시간`

### 실습 2: 스케줄링 메트릭 계산기

간트 차트에서 모든 스케줄링 메트릭을 계산하는 함수를 구축하세요:

**과제:**
1. `(process_id, start_time, end_time)` 튜플 리스트와 도착 시간이 주어졌을 때, 각 프로세스의 대기 시간(Waiting Time), 반환 시간(Turnaround Time), 응답 시간(Response Time)을 계산하세요
2. 시스템 전체 메트릭을 계산하세요: 처리량(Throughput), CPU 활용률(CPU Utilization), 평균 대기 시간
3. 프로세스 집합으로 테스트하세요: P1(도착=0, 버스트=8), P2(도착=1, 버스트=4), P3(도착=2, 버스트=9), P4(도착=3, 버스트=5), FCFS 기준

### 실습 3: 선점 시뮬레이터

`examples/OS_Theory/05_scheduling_sim.py`의 개념을 확장하세요:

**과제:**
1. 더 높은 우선순위 프로세스가 도착할 때마다 선점하는 `priority_preemptive()` 스케줄러를 추가하세요
2. 다음으로 테스트하세요: P1(도착=0, 버스트=7, 우선순위=3), P2(도착=2, 버스트=4, 우선순위=1), P3(도착=4, 버스트=1, 우선순위=2), P4(도착=5, 버스트=4, 우선순위=2)
3. 비선점 우선순위 스케줄링과 평균 대기 시간을 비교하세요

---

## 연습 문제

### 연습 1: CPU 바운드(CPU-bound)와 I/O 바운드(I/O-bound) 분류

아래 각 워크로드를 **CPU 바운드**, **I/O 바운드**, 또는 **혼합(mixed)**으로 분류하세요. 그런 다음 해당 워크로드에서 가장 중요한 스케줄링 기준(처리량(throughput), 응답 시간(response time), 공정성(fairness))을 예측하고 이유를 설명하세요.

| 워크로드 | 분류 | 가장 중요한 기준 | 이유 |
|----------|------|------------------|------|
| 4K 영상을 변환하는 비디오 트랜스코더 | | | |
| 대화형 텍스트 편집기 | | | |
| 많은 디스크 읽기가 있는 데이터베이스 쿼리 | | | |
| 머신러닝 모델 학습 | | | |
| 웹 페이지를 로드하는 웹 브라우저 | | | |
| 10GB 파일을 복사하는 `cp` 명령 | | | |

### 연습 2: 스케줄링 메트릭(Metrics) 계산

다섯 개의 프로세스가 다음 시간에 도착하고 주어진 CPU 버스트 길이를 가집니다. **FCFS(선착순)** 기준으로 메트릭을 계산하세요.

| 프로세스 | 도착 시간 | CPU 버스트 |
|----------|----------|------------|
| P1 | 0 | 10 |
| P2 | 1 | 4 |
| P3 | 2 | 7 |
| P4 | 3 | 3 |
| P5 | 4 | 5 |

1. 간트 차트(Gantt chart)를 그리세요
2. 각 프로세스의 대기 시간(waiting time)을 계산하세요
3. 각 프로세스의 반환 시간(turnaround time)을 계산하세요
4. 각 프로세스의 응답 시간(response time)을 계산하세요
5. 평균 대기 시간, 평균 반환 시간, CPU 이용률(utilization)을 계산하세요

### 연습 3: 선점(Preemption) 결정 시점

아래 OS 이벤트 각각에 대해 **선점(preemptive)** 스케줄링 결정 시점인지, **비선점(non-preemptive)** 결정 시점인지, 또는 **해당 없음(neither)**(스케줄링 결정 시점이 아님)인지 판단하세요. 이유를 설명하세요.

| 이벤트 | 유형 | 이유 |
|--------|------|------|
| 실행 중인 프로세스가 `read()`를 호출하여 I/O에서 블록됨 | | |
| 타이머 인터럽트 발생(타임 퀀텀(time quantum) 만료) | | |
| 더 높은 우선순위 프로세스가 대기 → 준비 상태로 전환 | | |
| 실행 중인 프로세스가 `exit()`를 호출 | | |
| `fork()`로 새 프로세스가 생성됨 | | |
| I/O 장치가 완료 인터럽트(completion interrupt)를 전송 | | |

### 연습 4: 스케줄러 유형의 역할

대규모 일괄 처리(batch processing) 시스템이 세 가지 스케줄러 유형을 모두 사용합니다. 다음 시나리오에서 각 스케줄러가 내리는 결정을 설명하세요:

> 대학의 컴퓨팅 클러스터가 야간 배치 작업(기상 시뮬레이션), 대화형 학생 터미널, 파일 아카이빙 프로세스를 실행합니다. 오전 2시에 50개의 새 배치 작업이 제출되고, 클러스터는 메모리의 80%를 사용 중이며, 하나의 시뮬레이션이 스왑 아웃(swap out)되었습니다.

1. **장기 스케줄러(long-term scheduler)**는 무엇을 결정하나요? 어떤 기준을 사용하나요?
2. **단기 스케줄러(short-term scheduler)**는 무엇을 결정하나요? 얼마나 자주 실행되나요?
3. **중기 스케줄러(medium-term scheduler)**는 무엇을 결정하나요? 이 시나리오에서 왜 필요했나요?
4. 대화형 터미널의 응답 시간에 가장 중요한 스케줄러 유형은 어느 것인가요?

### 연습 5: 디스패처(Dispatcher) 지연 분석

시스템의 디스패치 지연(dispatch latency)이 3마이크로초이고, 초당 5,000번의 컨텍스트 스위치(context switch)를 수행합니다.

1. 초당 디스패처에서 소비되는 총 시간은 얼마인가요?
2. 디스패칭에만 소비되는 CPU 시간의 비율은 얼마인가요?
3. 시스템 설계자가 디스패치 지연을 1마이크로초로 줄이려 합니다. 디스패치 지연에 기여하는 세 가지 구체적인 작업을 나열하고 각각을 최적화하는 방법을 설명하세요.
4. 타임 퀀텀을 늘려 컨텍스트 스위치 횟수를 5,000에서 1,000으로 줄였지만 평균 응답 시간이 10ms에서 25ms로 증가했습니다. 이 트레이드오프(trade-off)가 가치 있는지 평가하세요: (a) 배치 처리 서버의 경우? (b) 대화형 데스크톱 OS의 경우?

---

## 다음 단계

- [스케줄링 알고리즘](./05_Scheduling_Algorithms.md) - FCFS, SJF, Priority, RR 알고리즘

---

## 참고 자료

- [OSTEP - CPU Scheduling](https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched.pdf)
- [Operating System Concepts - Chapter 5](https://www.os-book.com/)
- [Linux Scheduler Documentation](https://www.kernel.org/doc/html/latest/scheduler/)


# 프로세스 개념

**이전**: [운영체제 개요](./01_OS_Overview.md) | **다음**: [스레드와 멀티스레딩](./03_Threads_and_Multithreading.md)

---

## 학습 목표(Learning Objectives)

이 레슨을 완료하면 다음을 할 수 있습니다:

1. 프로세스(Process)를 정의하고 프로그램(Program)과 구별할 수 있다
2. 텍스트(Text), 데이터(Data), BSS, 힙(Heap), 스택(Stack) 섹션을 포함한 프로세스 메모리 레이아웃을 설명할 수 있다
3. 프로세스 제어 블록(Process Control Block, PCB)의 내용과 프로세스 관리에서의 역할을 설명할 수 있다
4. 5-상태 모델과 7-상태 모델을 통해 프로세스 상태 전이를 추적할 수 있다
5. fork()를 사용한 프로세스 생성 방식과 exec()를 사용한 프로그램 교체 방식을 구별할 수 있다
6. 컨텍스트 스위치(Context Switch)의 직접 비용과 간접 비용을 분석할 수 있다
7. 좀비(Zombie) 프로세스와 고아(Orphan) 프로세스를 설명하고 운영체제가 이를 처리하는 방법을 설명할 수 있다

---

디스크에 저장된 프로그램은 요리책 속의 레시피와 같습니다 -- 생동감 없는 텍스트에 불과합니다. 프로세스는 그 레시피가 실제로 요리되고 있는 것입니다: 재료가 준비되고, 오븐이 예열되고, 타이머가 돌아가고 있는 상태입니다. 프로세스를 이해한다는 것은 컴퓨터가 어떻게 프로그램에 생명을 불어넣는지를 이해하는 것입니다. 이 레슨에서는 프로세스 메모리 구조, 프로세스 제어 블록(PCB), 프로세스 상태 전이, 컨텍스트 스위치를 다룹니다 -- 운영체제가 실행 중인 프로그램을 관리하는 핵심 메커니즘입니다.

## 목차

1. [프로세스란?](#1-프로세스란)
2. [프로세스 메모리 구조](#2-프로세스-메모리-구조)
3. [프로세스 제어 블록 (PCB)](#3-프로세스-제어-블록-pcb)
4. [프로세스 상태 전이](#4-프로세스-상태-전이)
5. [컨텍스트 스위치](#5-컨텍스트-스위치)
6. [프로세스 생성과 종료](#6-프로세스-생성과-종료)
7. [연습 문제](#7-연습-문제)

---

## 1. 프로세스란?

### 프로그램 vs 프로세스

```
┌────────────────────────────────────────────────────────┐
│                  프로그램 vs 프로세스                    │
├────────────────────┬───────────────────────────────────┤
│      프로그램       │              프로세스              │
├────────────────────┼───────────────────────────────────┤
│ 정적인 개체         │ 동적인 개체                       │
│ 디스크에 저장       │ 메모리에 적재                     │
│ 실행 파일           │ 실행 중인 파일                    │
│ 수동적 (passive)    │ 능동적 (active)                  │
│ 변하지 않음         │ 상태가 계속 변함                  │
└────────────────────┴───────────────────────────────────┘

프로그램 ──(로드)──▶ 프로세스
          메모리에
          적재하면
```

### 프로세스의 구성 요소

```
프로세스 = 코드 + 데이터 + 스택 + 힙 + PCB

┌─────────────────────────────────────┐
│              프로세스                │
├─────────────────────────────────────┤
│  ┌───────────────────────────────┐  │
│  │    텍스트 (코드) 섹션          │  │  실행할 명령어
│  ├───────────────────────────────┤  │
│  │    데이터 섹션                 │  │  전역/정적 변수
│  ├───────────────────────────────┤  │
│  │    힙                         │  │  동적 할당 메모리
│  ├───────────────────────────────┤  │
│  │    스택                       │  │  지역변수, 함수 호출
│  └───────────────────────────────┘  │
│                                     │
│  ┌───────────────────────────────┐  │
│  │    PCB (커널에 저장)           │  │  프로세스 메타데이터
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘
```

---

## 2. 프로세스 메모리 구조

### 메모리 레이아웃

```
높은 주소 (0xFFFFFFFF)
┌─────────────────────────────────────┐
│             커널 영역                │  OS 전용 (사용자 접근 불가)
├─────────────────────────────────────┤ ← 0xC0000000 (Linux 32-bit)
│                                     │
│              스택 (Stack)            │  지역 변수, 함수 매개변수
│              ↓ 아래로 성장           │  복귀 주소
│                                     │
├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤
│                                     │
│              ↑ 위로 성장             │
│              힙 (Heap)              │  malloc, new
│                                     │
├─────────────────────────────────────┤
│              BSS                    │  초기화되지 않은 전역/정적 변수
├─────────────────────────────────────┤
│              Data                   │  초기화된 전역/정적 변수
├─────────────────────────────────────┤
│              Text (Code)            │  프로그램 코드 (읽기 전용)
└─────────────────────────────────────┘
낮은 주소 (0x00000000)
```

### 각 섹션 상세

```c
#include <stdio.h>
#include <stdlib.h>

// BSS 섹션: 초기화되지 않은 전역 변수
int uninit_global;

// Data 섹션: 초기화된 전역 변수
int init_global = 42;

// Data 섹션: 정적 변수
static int static_var = 100;

void example_function(int param) {    // param: 스택
    int local_var = 10;               // 스택
    static int func_static = 0;       // Data 섹션
    int *heap_ptr;

    heap_ptr = malloc(sizeof(int));   // 힙에 메모리 할당
    *heap_ptr = 20;

    printf("local: %d, heap: %d\n", local_var, *heap_ptr);

    free(heap_ptr);                   // 힙 메모리 해제
}

// Text 섹션: 이 코드 자체
int main() {
    example_function(5);
    return 0;
}
```

### 메모리 영역 특성

```
┌──────────┬──────────┬──────────┬────────────────────────┐
│  섹션     │ 읽기     │ 쓰기     │         용도            │
├──────────┼──────────┼──────────┼────────────────────────┤
│ Text     │   O      │   X      │ 프로그램 코드           │
│ Data     │   O      │   O      │ 초기화된 전역/정적 변수  │
│ BSS      │   O      │   O      │ 미초기화 전역/정적 변수  │
│ Heap     │   O      │   O      │ 동적 할당 메모리         │
│ Stack    │   O      │   O      │ 지역 변수, 함수 호출     │
└──────────┴──────────┴──────────┴────────────────────────┘
```

### 스택 프레임

```
함수 호출 시 스택 구조:

int add(int a, int b) {
    int result = a + b;
    return result;
}

int main() {
    int x = add(3, 5);
    return 0;
}

┌─────────────────────────────┐ ← 높은 주소
│        ...                  │
├─────────────────────────────┤
│    main() 스택 프레임        │
│  ┌───────────────────────┐  │
│  │ x (지역 변수)          │  │
│  │ 이전 프레임 포인터      │  │
│  │ 복귀 주소              │  │
│  └───────────────────────┘  │
├─────────────────────────────┤
│    add() 스택 프레임         │
│  ┌───────────────────────┐  │
│  │ result (지역 변수)     │  │
│  │ 이전 프레임 포인터      │  │
│  │ 복귀 주소              │  │
│  │ b = 5 (매개변수)       │  │
│  │ a = 3 (매개변수)       │  │
│  └───────────────────────┘  │
├─────────────────────────────┤ ← Stack Pointer (SP)
│        ...                  │
└─────────────────────────────┘ ← 낮은 주소
```

---

## 3. 프로세스 제어 블록 (PCB)

### PCB란?

```
PCB (Process Control Block) = 프로세스를 관리하기 위한 모든 정보를 담은 자료구조
                            = 커널이 유지
                            = 프로세스 테이블에 저장

┌───────────────────────────────────────────────────────┐
│                    PCB 구조                            │
├───────────────────────────────────────────────────────┤
│                                                       │
│  ┌─────────────────────────────────────────────────┐  │
│  │ 프로세스 식별자 (PID)                            │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ 프로세스 상태 (Ready, Running, Waiting...)       │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ 프로그램 카운터 (PC) - 다음 실행 명령어 주소      │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ CPU 레지스터 (범용, 스택 포인터, 플래그...)       │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ CPU 스케줄링 정보 (우선순위, 스케줄링 큐)         │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ 메모리 관리 정보 (페이지 테이블, 세그먼트 테이블)  │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ 회계 정보 (CPU 사용 시간, 시작 시간...)          │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ I/O 상태 정보 (열린 파일 목록, I/O 장치...)       │  │
│  └─────────────────────────────────────────────────┘  │
│                                                       │
└───────────────────────────────────────────────────────┘
```

### Linux task_struct (간략화)

```c
// Linux 커널의 프로세스 구조체 (간략화)
struct task_struct {
    // 프로세스 식별
    pid_t pid;                    // 프로세스 ID — 수천 개의 프로세스 중에서 이 프로세스를 고유하게
                                  // 식별하여 커널이 추적, 스케줄링, 시그널 전송을 할 수 있게 함
    pid_t tgid;                   // 스레드 그룹 ID — 같은 주소 공간을 공유하는 스레드들을 그룹화하여
                                  // 시그널/종료가 개별 스레드가 아닌 전체 스레드 그룹에 영향을 미치도록 함

    // 프로세스 상태
    volatile long state;          // TASK_RUNNING, TASK_INTERRUPTIBLE...
                                  // 스케줄러가 이 필드를 확인하여 프로세스가 CPU 시간을 받을 수
                                  // 있는지, 아니면 이벤트를 기다려야 하는지 결정함

    // 스케줄링 정보
    int prio;                     // 동적 우선순위 — 런타임에 조정되어 대화형(Interactive) 프로세스는
                                  // 응답성 향상을, CPU 독점 프로세스는 우선순위 하락을 받음
    int static_prio;              // 정적 우선순위 — 사용자가 nice로 설정; 동적 우선
```

### 프로세스 테이블

```
┌─────────────────────────────────────────────────────────┐
│                   프로세스 테이블                         │
├─────┬──────────────────────────────────────────────────┤
│ PID │                    PCB                            │
├─────┼──────────────────────────────────────────────────┤
│  1  │ init: state=Running, priority=20, mem=4MB...     │
├─────┼──────────────────────────────────────────────────┤
│  2  │ kthreadd: state=Sleeping, priority=10...         │
├─────┼──────────────────────────────────────────────────┤
│ 100 │ bash: state=Ready, priority=20, mem=8MB...       │
├─────┼──────────────────────────────────────────────────┤
│ 101 │ vim: state=Waiting, priority=20, mem=12MB...     │
├─────┼──────────────────────────────────────────────────┤
│ ... │ ...                                              │
└─────┴──────────────────────────────────────────────────┘
```

---

## 4. 프로세스 상태 전이

### 5-상태 모델

```
                        생성 (New)
                            │
                            │ 승인 (Admitted)
                            ▼
         ┌──────────────┐ 디스패치 ┌──────────────┐
         │              │─────────▶│              │
         │   준비       │          │   실행       │──────┐ 종료
         │  (Ready)     │◀─────────│  (Running)   │      │
         │              │ 인터럽트  │              │      │
         └──────────────┘(타임아웃) └──────────────┘      │
                ▲                         │              ▼
                │                         │         ┌──────────┐
                │    I/O 또는             │         │   종료    │
                │   이벤트 완료           │         │(Terminated)│
                │                         │         └──────────┘
                │                         │ I/O 또는
                │                         │ 이벤트 대기
                │                         ▼
                │              ┌──────────────┐
                └──────────────│    대기      │
                               │  (Waiting)   │
                               └──────────────┘
```

### 상태 설명

```
┌────────────────┬────────────────────────────────────────┐
│      상태       │                  설명                   │
├────────────────┼────────────────────────────────────────┤
│ New (생성)      │ 프로세스가 생성 중                      │
├────────────────┼────────────────────────────────────────┤
│ Ready (준비)    │ CPU 할당을 기다리는 중                  │
│                │ 실행할 준비가 완료됨                     │
├────────────────┼────────────────────────────────────────┤
│ Running (실행)  │ CPU에서 명령어를 실행 중                │
│                │ 한 번에 하나의 프로세스만 (단일 CPU)      │
├────────────────┼────────────────────────────────────────┤
│ Waiting (대기)  │ I/O 완료나 이벤트를 기다리는 중          │
│                │ I/O 완료 시 Ready 상태로 전환           │
├────────────────┼────────────────────────────────────────┤
│ Terminated     │ 실행 완료, 자원 반환 중                  │
│ (종료)          │                                        │
└────────────────┴────────────────────────────────────────┘
```

### 상태 전이 조건

```
┌─────────────────┬─────────────────────────────────────────┐
│     전이         │                  조건                    │
├─────────────────┼─────────────────────────────────────────┤
│ New → Ready     │ OS가 프로세스를 승인                     │
├─────────────────┼─────────────────────────────────────────┤
│ Ready → Running │ 스케줄러가 CPU 할당 (dispatch)           │
├─────────────────┼─────────────────────────────────────────┤
│ Running → Ready │ 타임 슬라이스 만료 (타임아웃)             │
│                 │ 더 높은 우선순위 프로세스 도착 (선점)      │
├─────────────────┼─────────────────────────────────────────┤
│ Running → Wait  │ I/O 요청, 이벤트 대기                    │
├─────────────────┼─────────────────────────────────────────┤
│ Wait → Ready    │ I/O 완료, 이벤트 발생                    │
├─────────────────┼─────────────────────────────────────────┤
│ Running → Term  │ exit() 호출, 정상/비정상 종료            │
└─────────────────┴─────────────────────────────────────────┘
```

### 7-상태 모델 (Swapping 포함)

```
                           ┌──────────────────────────────────┐
                           │                                  │
                           │                 스왑 아웃          │
                           ▼                   │              │
┌─────────┐           ┌─────────┐          ┌───┴─────┐        │
│  New    │──────────▶│  Ready  │◀────────▶│ Ready   │        │
│         │           │         │  스왑인    │ Suspend │        │
└─────────┘           └─────────┘          └─────────┘        │
                           │                                  │
                      디스패치                                 │
                           │                                  │
                           ▼                                  │
┌─────────┐           ┌─────────┐                             │
│  Term   │◀──────────│ Running │                             │
│         │           │         │                             │
└─────────┘           └─────────┘                             │
                           │                                  │
                      I/O 요청                                 │
                           │                                  │
                           ▼                   스왑 아웃        │
                      ┌─────────┐          ┌─────────┐        │
                      │ Waiting │◀────────▶│ Waiting │────────┘
                      │         │  스왑인    │ Suspend │
                      └─────────┘          └─────────┘

Suspend 상태: 메모리에서 디스크로 스왑 아웃된 프로세스
```

---

## 5. 컨텍스트 스위치

### 컨텍스트 스위치란?

```
컨텍스트 스위치 (Context Switch)
= CPU를 다른 프로세스로 전환하는 과정
= 현재 프로세스의 상태를 저장하고, 새 프로세스의 상태를 복원

┌────────────────────────────────────────────────────────────┐
│                    컨텍스트 스위치 과정                      │
└────────────────────────────────────────────────────────────┘

프로세스 P0              운영체제              프로세스 P1
    │                      │                      │
    │  실행 중              │                      │  대기 중
    │                      │                      │
    │──인터럽트/시스템콜───▶│                      │
    │                      │                      │
    │                  PCB0에 상태 저장            │
    │                      │                      │
    │                  PCB1에서 상태 복원          │
    │                      │                      │
    │                      │──────────────────────▶│
    │  대기 중              │                      │  실행 중
    │                      │                      │
    │                      │◀──인터럽트/시스템콜────│
    │                      │                      │
    │                  PCB1에 상태 저장            │
    │                      │                      │
    │                  PCB0에서 상태 복원          │
    │                      │                      │
    │◀─────────────────────│                      │
    │  실행 중              │                      │  대기 중
```

### 컨텍스트 스위치에서 저장/복원하는 정보

```
┌────────────────────────────────────────────────────────┐
│               컨텍스트 (Context)                        │
├────────────────────────────────────────────────────────┤
│                                                        │
│  CPU 레지스터:                                         │
│  ┌──────────────────────────────────────────────────┐  │
│  │ • 프로그램 카운터 (PC)                            │  │
│  │ • 스택 포인터 (SP)                               │  │
│  │ • 베이스 포인터 (BP)                             │  │
│  │ • 범용 레지스터 (RAX, RBX, RCX, RDX...)          │  │
│  │ • 상태 레지스터 (FLAGS)                          │  │
│  │ • 부동소수점 레지스터                             │  │
│  └──────────────────────────────────────────────────┘  │
│                                                        │
│  메모리 관리 정보:                                     │
│  ┌──────────────────────────────────────────────────┐  │
│  │ • 페이지 테이블 베이스 레지스터                    │  │
│  │ • 세그먼트 레지스터                               │  │
│  └──────────────────────────────────────────────────┘  │
│                                                        │
└────────────────────────────────────────────────────────┘
```

### 컨텍스트 스위치 비용

```
┌────────────────────────────────────────────────────────┐
│               컨텍스트 스위치 비용                       │
├────────────────────────────────────────────────────────┤
│                                                        │
│  직접 비용:                                            │
│  • 레지스터 저장/복원: ~수백 나노초                     │
│  • 커널 모드 전환: ~수백 나노초                         │
│                                                        │
│  간접 비용 (더 큼):                                    │
│  • TLB 플러시: 수백~수천 사이클                         │
│  • 캐시 미스 증가 (캐시 오염)                           │
│  • 파이프라인 플러시                                   │
│                                                        │
│  일반적인 총 비용: 1~10 마이크로초                      │
│                                                        │
└────────────────────────────────────────────────────────┘

시간축에서 보는 컨텍스트 스위치:

P0 실행  │ 컨텍스트 스위치 │ P1 실행  │ 컨텍스트 스위치 │ P0 실행
━━━━━━━━│     오버헤드    │━━━━━━━━│     오버헤드    │━━━━━━━
        │← ~1-10 μs →│        │← ~1-10 μs →│
                 ↑ 이 시간 동안 유용한 작업 불가
```

---

## 6. 프로세스 생성과 종료

### fork()를 이용한 프로세스 생성

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid;
    int x = 10;

    printf("부모 프로세스 시작, PID: %d\n", getpid());

    pid = fork();  // 프로세스 분기점

    if (pid < 0) {
        // fork 실패
        perror("fork failed");
        return 1;
    }
    else if (pid == 0) {
        // 자식 프로세스
        printf("자식: PID=%d, 부모 PID=%d\n", getpid(), getppid());
        x = x + 10;
        printf("자식: x = %d\n", x);
    }
    else {
        // 부모 프로세스
        printf("부모: PID=%d, 자식 PID=%d\n", getpid(), pid);
        wait(NULL);  // 자식 종료 대기
        printf("부모: x = %d\n", x);  // 여전히 10
    }

    return 0;
}

/*
출력:
부모 프로세스 시작, PID: 1234
부모: PID=1234, 자식 PID=1235
자식: PID=1235, 부모 PID=1234
자식: x = 20
부모: x = 10
*/
```

### fork() 동작 과정

```
fork() 호출 전:
┌─────────────────────────────────┐
│        부모 프로세스 (PID: 100)   │
│  ┌─────────────────────────┐    │
│  │ x = 10                  │    │
│  │ 코드/데이터/스택/힙       │    │
│  └─────────────────────────┘    │
└─────────────────────────────────┘

fork() 호출 후:
┌─────────────────────────────────┐    ┌─────────────────────────────────┐
│        부모 프로세스 (PID: 100)   │    │        자식 프로세스 (PID: 101)   │
│  ┌─────────────────────────┐    │    │  ┌─────────────────────────┐    │
│  │ x = 10                  │    │    │  │ x = 10 (복사됨)          │    │
│  │ 코드/데이터/스택/힙       │    │    │  │ 코드/데이터/스택/힙       │    │
│  │ fork() 반환값: 101      │    │    │  │ fork() 반환값: 0         │    │
│  └─────────────────────────┘    │    │  └─────────────────────────┘    │
└─────────────────────────────────┘    └─────────────────────────────────┘
          │                                       │
          │  두 프로세스는 독립적                   │
          │  (별도의 메모리 공간)                  │
          ▼                                       ▼
```

### exec()를 이용한 프로그램 실행

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // 자식 프로세스: ls 명령어 실행
        printf("자식: ls 실행\n");

        // execl: exec with list of arguments
        execl("/bin/ls", "ls", "-l", NULL);

        // exec 성공 시 이 코드는 실행되지 않음
        perror("exec failed");
        return 1;
    }
    else {
        // 부모 프로세스
        wait(NULL);
        printf("부모: 자식 종료됨\n");
    }

    return 0;
}
```

### exec() 동작 과정

```
exec() 호출 전:
┌─────────────────────────────────┐
│        자식 프로세스             │
│  ┌─────────────────────────┐    │
│  │ 원래 프로그램 코드        │    │
│  │ 원래 데이터              │    │
│  │ 원래 스택/힙             │    │
│  └─────────────────────────┘    │
└─────────────────────────────────┘

exec("/bin/ls") 호출 후:
┌─────────────────────────────────┐
│        자식 프로세스             │
│  ┌─────────────────────────┐    │
│  │ ls 프로그램 코드          │    │  ← 새 프로그램으로
│  │ ls 데이터                │    │    완전히 교체
│  │ 새로운 스택/힙           │    │
│  └─────────────────────────┘    │
│                                 │
│  PID는 그대로 유지               │
└─────────────────────────────────┘
```

### 프로세스 종료

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        printf("자식 프로세스 종료\n");
        exit(42);  // 종료 코드 42로 종료
    }
    else {
        int status;
        wait(&status);  // 자식의 종료 상태 수집

        if (WIFEXITED(status)) {
            printf("자식 종료 코드: %d\n", WEXITSTATUS(status));
        }
    }

    return 0;
}

/*
출력:
자식 프로세스 종료
자식 종료 코드: 42
*/
```

### 좀비 프로세스와 고아 프로세스

```
좀비 프로세스 (Zombie Process):
- 자식이 종료되었지만 부모가 wait()를 호출하지 않은 상태
- PCB가 남아있음 (종료 상태 저장)
- 자원은 해제되었지만 프로세스 테이블 엔트리 유지

┌──────────────────────────────────────────────┐
│  부모 프로세스 (PID: 100)                     │
│  - wait() 호출 안 함                         │
└──────────────────────────────────────────────┘
          │
          │ (관계 유지)
          ▼
┌──────────────────────────────────────────────┐
│  좀비 프로세스 (PID: 101)                     │
│  - 상태: Z (Zombie)                          │
│  - 코드/데이터/스택 해제됨                    │
│  - PCB만 남아있음                             │
└──────────────────────────────────────────────┘


고아 프로세스 (Orphan Process):
- 부모가 자식보다 먼저 종료된 상태
- init(PID 1) 또는 systemd가 새 부모가 됨

┌──────────────────────────────────────────────┐
│  init (PID: 1)                               │
│  - 고아 프로세스의 새 부모                    │
│  - 주기적으로 wait() 호출                    │
└──────────────────────────────────────────────┘
          │
          │ (입양)
          ▼
┌──────────────────────────────────────────────┐
│  고아 프로세스 (PID: 102)                     │
│  - 원래 부모 (PID: 100)가 종료됨              │
│  - PPID가 1로 변경됨                          │
└──────────────────────────────────────────────┘
```

---

## 7. 연습 문제

### 문제 1: 메모리 영역 식별

다음 변수들이 저장되는 메모리 영역을 고르세요.

```c
int global_var = 100;        // (   )
int uninitialized;           // (   )
const char* str = "hello";   // (   )

void func() {
    int local = 10;          // (   )
    static int stat = 20;    // (   )
    int* ptr = malloc(4);    // ptr: (   ), *ptr: (   )
}
```

보기: Text, Data, BSS, Stack, Heap

<details>
<summary>정답 보기</summary>

```
int global_var = 100;        // (Data)
int uninitialized;           // (BSS)
const char* str = "hello";   // str: Data, "hello": Text (읽기전용)

void func() {
    int local = 10;          // (Stack)
    static int stat = 20;    // (Data)
    int* ptr = malloc(4);    // ptr: (Stack), *ptr: (Heap)
}
```

</details>

### 문제 2: 프로세스 상태 전이

다음 상황에서 프로세스 상태 전이를 설명하세요.

1. 프로세스 A가 CPU를 사용 중, 타임 슬라이스 만료
2. 프로세스 B가 파일 읽기 요청
3. 프로세스 C의 파일 읽기 완료
4. 스케줄러가 프로세스 D를 선택

<details>
<summary>정답 보기</summary>

1. A: Running → Ready (타임아웃/인터럽트)
2. B: Running → Waiting (I/O 요청)
3. C: Waiting → Ready (I/O 완료)
4. D: Ready → Running (디스패치)

</details>

### 문제 3: fork() 출력 예측

다음 코드의 출력 결과를 예측하세요.

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    printf("A\n");
    fork();
    printf("B\n");
    fork();
    printf("C\n");
    return 0;
}
```

<details>
<summary>정답 보기</summary>

```
A       (1번 출력 - 최초 프로세스)
B       (2번 출력 - 첫 번째 fork 후 2개 프로세스)
B
C       (4번 출력 - 두 번째 fork 후 4개 프로세스)
C
C
C

총: A 1번, B 2번, C 4번

프로세스 분기:
        main
          │
    ┌─────┴─────┐
    │  fork()   │
    │           │
  main        child1
    │           │
 ┌──┴──┐     ┌──┴──┐
 │fork()│    │fork()│
 │     │    │     │
main  c2   c1    c3

4개의 프로세스가 각각 "C" 출력
```

</details>

### 문제 4: PCB 정보

다음 상황에서 PCB에 저장되는 정보의 변화를 설명하세요.

1. 프로세스가 Running에서 Waiting으로 전이할 때
2. 컨텍스트 스위치가 발생할 때

<details>
<summary>정답 보기</summary>

1. Running → Waiting 전이:
   - PCB의 상태(state) 필드가 Running에서 Waiting으로 변경
   - I/O 상태 정보에 대기 중인 I/O 작업 기록
   - 프로세스가 대기 큐로 이동

2. 컨텍스트 스위치:
   - 현재 프로세스의 PC, 레지스터, 스택 포인터 등을 PCB에 저장
   - 새 프로세스의 PCB에서 PC, 레지스터, 스택 포인터 등을 복원
   - 메모리 관리 정보(페이지 테이블) 갱신
   - 새 프로세스의 상태를 Running으로 변경

</details>

### 문제 5: 컨텍스트 스위치 비용

컨텍스트 스위치의 직접 비용과 간접 비용을 각각 두 가지씩 설명하세요.

<details>
<summary>정답 보기</summary>

**직접 비용:**
1. 레지스터 저장/복원: 현재 프로세스의 레지스터를 PCB에 저장하고, 새 프로세스의 레지스터를 복원하는 시간
2. 커널 모드 전환: 사용자 모드에서 커널 모드로, 다시 사용자 모드로 전환하는 오버헤드

**간접 비용:**
1. 캐시 오염(Cache Pollution): 새 프로세스가 사용하는 데이터가 캐시에 없어서 캐시 미스 증가
2. TLB 플러시: 새 프로세스는 다른 가상 주소 공간을 사용하므로 TLB 항목이 무효화됨

</details>

---

## 실습 과제

### 실습 1: 프로세스 생명주기 시뮬레이션

`examples/OS_Theory/02_process_demo.py`를 실행하고 출력을 관찰하세요.

**과제:**
1. 우선순위 3인 새 프로세스 "P5"를 추가하고 상태 전이를 추적하세요: NEW → READY → RUNNING → WAITING → READY → RUNNING → TERMINATED
2. `ProcessTable`을 수정하여 각 프로세스가 각 상태에서 보낸 총 시간을 추적하도록 하세요
3. 어떤 상태에서든 강제로 TERMINATED로 전환하는 `kill_process(pid)` 메서드를 추가하세요

### 실습 2: 프로세스 트리 탐색

시스템 도구를 사용하여 머신의 프로세스 계층 구조를 탐색하세요:

```bash
# Linux
pstree -p | head -30

# macOS
ps -axo pid,ppid,comm | head -30
```

**과제:**
1. init/launchd 프로세스(PID 1)를 식별하고 자식 프로세스 3단계를 추적하세요
2. 현재 셸의 PPID는 무엇인가요? PID 1까지 조상을 추적하세요
3. `os.getpid()`와 `os.getppid()`를 사용하여 자신의 조상을 출력하는 Python 스크립트를 작성하세요

### 실습 3: 문맥 교환 오버헤드

파이프 기반 핑퐁을 사용하여 두 프로세스 간의 문맥 교환(Context Switch) 오버헤드를 측정하세요:

```python
import os, time

def measure_context_switches(n=10000):
    r1, w1 = os.pipe()
    r2, w2 = os.pipe()

    pid = os.fork()
    if pid == 0:
        for _ in range(n):
            os.read(r1, 1)
            os.write(w2, b'x')
        os._exit(0)
    else:
        start = time.perf_counter()
        for _ in range(n):
            os.write(w1, b'x')
            os.read(r2, 1)
        elapsed = time.perf_counter() - start
        os.wait()
        print(f"{n} 왕복: {elapsed*1000:.1f} ms")
        print(f"교환당: {elapsed/n*1e6:.1f} µs")

measure_context_switches()
```

**과제:**
1. 스크립트를 실행하고 교환당 지연 시간을 해석하세요
2. 이론적 최솟값(레지스터 저장/복원 시간)과 어떻게 비교되나요?
3. 레지스터 저장/복원 외에 문맥 교환 오버헤드에 기여하는 추가 비용은 무엇인가요?

---

## 연습 문제

### 연습 1: 메모리 레이아웃 분석

아래 프로그램에서 각 변수 또는 표현식이 어느 메모리 섹션(텍스트(Text), 데이터(Data), BSS, 힙(Heap), 스택(Stack))에 위치하는지 명시하고, 그 이유를 간략히 설명하세요.

```c
#include <stdio.h>
#include <stdlib.h>

int server_port = 8080;          // (1)
char *app_name;                  // (2)
static int request_count = 0;   // (3)

void handle_request(int id) {
    char buf[256];               // (4)
    static int call_num = 0;     // (5)
    int *data = malloc(1024);    // (6) data 자체는 어디에? data가 가리키는 곳은?
    free(data);
}
```

### 연습 2: 프로세스 상태 전이

시스템에 P1, P2, P3, P4 네 개의 프로세스가 있습니다. 아래 이벤트를 바탕으로 각 타임 스텝에서 각 프로세스의 상태를 추적하세요. 사용할 상태: 신규(New), 준비(Ready), 실행(Running), 대기(Waiting), 종료(Terminated).

| 시간 | 이벤트 |
|------|--------|
| t=0 | P1 생성, P2 생성 |
| t=1 | P1이 CPU에 디스패치됨 |
| t=2 | P3 생성 |
| t=3 | P1이 파일 읽기(I/O) 요청 |
| t=4 | P2 디스패치; P4 생성 |
| t=5 | P1의 I/O 완료 |
| t=6 | P2의 타임 슬라이스(time slice) 만료 |
| t=7 | P1 디스패치; P3 디스패치(멀티코어) |
| t=8 | P3가 exit() 호출 |

표를 채우세요:

| 프로세스 | t=0 | t=1 | t=2 | t=3 | t=4 | t=5 | t=6 | t=7 | t=8 |
|----------|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| P1 | | | | | | | | | |
| P2 | | | | | | | | | |
| P3 | | | | | | | | | |
| P4 | | | | | | | | | |

### 연습 3: fork() 출력 예측

아래 프로그램의 정확한 출력을 예측하세요. 각 줄이 몇 번 출력되는지도 포함합니다. 버퍼링 문제는 없고 PID가 1000, 1001, 1002 순서로 할당된다고 가정합니다.

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int x = 0;

int main() {
    printf("start\n");

    pid_t p1 = fork();
    if (p1 == 0) {
        x = 10;
        printf("child1: x=%d\n", x);
        return 0;
    }

    pid_t p2 = fork();
    if (p2 == 0) {
        x = 20;
        printf("child2: x=%d\n", x);
        return 0;
    }

    wait(NULL);
    wait(NULL);
    printf("parent: x=%d\n", x);
    return 0;
}
```

1. 원래 프로세스를 포함하여 총 몇 개의 프로세스가 생성되나요?
2. 종료 시 부모 프로세스에서 `x`의 값은 얼마인가요? 그 이유는?
3. 두 자식 프로세스의 출력 순서가 바뀔 수 있나요? 이유는?

### 연습 4: 좀비(Zombie)와 고아(Orphan) 프로세스

다음 코드를 읽고 질문에 답하세요.

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int main() {
    pid_t pid = fork();

    if (pid > 0) {
        // Parent
        printf("Parent sleeping...\n");
        sleep(60);   // Does NOT call wait()
        printf("Parent done\n");
    } else {
        // Child
        printf("Child exiting immediately\n");
        exit(0);
    }
    return 0;
}
```

1. 부모가 잠든 동안 자식 프로세스가 `exit(0)`을 호출하면 어떤 상태가 되나요? 이유는?
2. 리눅스(Linux)의 커맨드라인 도구를 사용하여 이 상태를 어떻게 확인할 수 있나요?
3. 이 상황을 예방하기 위해 부모 코드에 어떤 변경이 필요한가요?
4. 부모가 `sleep(60)`이 끝나기 전에 충돌(crash)한다면 자식은 어떻게 되나요? 어떤 프로세스가 자식을 입양하나요?

### 연습 5: 컨텍스트 스위치(Context Switch) 비용 추정

어떤 시스템이 초당 1,000번의 컨텍스트 스위치를 수행합니다. 각 스위치의 직접 오버헤드(레지스터 저장/복원)는 약 5마이크로초이고, 간접 오버헤드(TLB 플러시, 캐시 워밍)는 추가로 15마이크로초입니다.

1. 초당 컨텍스트 스위치로 인해 손실되는 총 CPU 시간을 계산하세요
2. 이를 1GHz 단일 코어 CPU의 초당 전체 사이클 수 대비 백분율로 나타내세요
3. 타임 퀀텀(time quantum)을 두 배로 늘려 초당 컨텍스트 스위치를 500회로 줄인다면 새로운 오버헤드 비율은 얼마인가요?
4. 오버헤드가 줄어도 컨텍스트 스위치를 줄이면 성능이 저하되는 두 가지 워크로드(workload) 유형을 말하세요

---

## 다음 단계

- [스레드와 멀티스레딩](./03_Threads_and_Multithreading.md) - 스레드 개념과 멀티스레딩 모델

---

## 참고 자료

- [OSTEP - Processes](https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf)
- [Linux man pages - fork](https://man7.org/linux/man-pages/man2/fork.2.html)
- [Linux Kernel - task_struct](https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h)


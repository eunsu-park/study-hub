# 스레드와 멀티스레딩

**이전**: [프로세스 개념](./02_Process_Concepts.md) | **다음**: [CPU 스케줄링 기초](./04_CPU_Scheduling_Basics.md)

---

## 학습 목표(Learning Objectives)

이 레슨을 완료하면 다음을 할 수 있습니다:

1. 스레드와 프로세스를 구별하고, 스레드가 공유하는 자원과 독립적으로 유지하는 자원을 설명할 수 있습니다
2. 생성 비용, 전환 비용, 메모리 오버헤드 측면에서 스레드가 프로세스보다 경량인 이유를 설명할 수 있습니다
3. 사용자 수준 스레드(User-Level Thread)와 커널 수준 스레드(Kernel-Level Thread)를 비교하고 각 방식의 트레이드오프를 식별할 수 있습니다
4. 세 가지 멀티스레딩 모델(다대일, 일대일, 다대다)을 설명하고 현대 운영체제가 사용하는 모델을 파악할 수 있습니다
5. POSIX pthread API를 사용하여 기본적인 멀티스레드 프로그램을 구현할 수 있습니다
6. 공유 메모리 동시성에서 경쟁 상태(Race Condition)와 같은 스레드 안전(Thread Safety) 문제를 분석할 수 있습니다

---

현대 CPU는 여러 코어를 갖추고 있지만, 단일 코어조차 수많은 스레드를 실행할 수 있습니다. 스레드를 사용하면 하나의 프로세스가 여러 작업을 동시에 처리할 수 있습니다 — 파일을 내려받으면서 UI를 렌더링하고 사용자 입력을 처리하는 것이 그 예입니다. 스레드를 이해하는 것은 응답성 있고 효율적인 소프트웨어를 작성하는 데 필수적입니다. 이 레슨에서는 스레드와 프로세스의 차이, 사용자 수준 스레드와 커널 수준 스레드, 멀티스레딩 모델, 그리고 이러한 개념을 C 언어로 실현하는 pthread API를 다룹니다.

## 목차

1. [스레드란?](#1-스레드란)
2. [스레드 vs 프로세스](#2-스레드-vs-프로세스)
3. [스레드 제어 블록 (TCB)](#3-스레드-제어-블록-tcb)
4. [사용자 스레드와 커널 스레드](#4-사용자-스레드와-커널-스레드)
5. [멀티스레딩 모델](#5-멀티스레딩-모델)
6. [pthread API 기초](#6-pthread-api-기초)
7. [연습 문제](#7-연습-문제)

---

## 1. 스레드란?

### 정의

```
스레드 (Thread) = 프로세스 내의 실행 흐름
               = CPU 스케줄링의 기본 단위
               = 경량 프로세스 (Lightweight Process)

┌─────────────────────────────────────────────────────────┐
│                    싱글 스레드 프로세스                   │
│  ┌─────────────────────────────────────────────────┐   │
│  │  코드  │  데이터  │       힙       │    스택    │   │
│  └─────────────────────────────────────────────────┘   │
│               하나의 실행 흐름만 존재                    │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                    멀티 스레드 프로세스                   │
│  ┌────────────────────────────────────────────────────┐ │
│  │  코드  │  데이터  │       힙       │               │ │
│  └────────────────────────────────────────────────────┘ │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │  스택1   │  │  스택2   │  │  스택3   │              │
│  │ 스레드1  │  │ 스레드2  │  │ 스레드3  │              │
│  └──────────┘  └──────────┘  └──────────┘              │
│           세 개의 실행 흐름 (병렬 실행 가능)              │
└─────────────────────────────────────────────────────────┘
```

### 스레드가 필요한 이유

```
┌────────────────────────────────────────────────────────┐
│                   스레드 사용 이점                       │
├────────────────────────────────────────────────────────┤
│                                                        │
│ 1. 응답성 (Responsiveness)                             │
│    - 하나의 스레드가 블로킹되어도 다른 스레드 실행        │
│    - UI 스레드와 작업 스레드 분리                       │
│                                                        │
│ 2. 자원 공유 (Resource Sharing)                        │
│    - 같은 주소 공간 공유                               │
│    - IPC 없이 데이터 교환 가능                          │
│                                                        │
│ 3. 경제성 (Economy)                                    │
│    - 프로세스 생성보다 스레드 생성이 빠름                 │
│    - 컨텍스트 스위치 비용 감소                          │
│                                                        │
│ 4. 확장성 (Scalability)                                │
│    - 멀티코어 CPU 활용                                 │
│    - 각 스레드가 다른 코어에서 실행                      │
│                                                        │
└────────────────────────────────────────────────────────┘
```

---

## 2. 스레드 vs 프로세스

### 공유하는 것과 독립적인 것

```
┌─────────────────────────────────────────────────────────┐
│                   스레드 간 공유/독립                     │
├────────────────────────┬────────────────────────────────┤
│       공유 (Shared)     │       독립 (Private)           │
├────────────────────────┼────────────────────────────────┤
│ • 코드 섹션            │ • 스레드 ID                     │
│ • 데이터 섹션          │ • 프로그램 카운터 (PC)          │
│ • 힙 영역              │ • 레지스터 집합                  │
│ • 열린 파일            │ • 스택                          │
│ • 신호 처리기          │ • 스케줄링 정보 (우선순위)       │
│ • 현재 작업 디렉토리    │ • 시그널 마스크                  │
│ • 사용자/그룹 ID       │ • errno 값                      │
└────────────────────────┴────────────────────────────────┘
```

### 메모리 레이아웃 비교

```
프로세스 메모리:                멀티스레드 프로세스 메모리:

┌─────────────┐                ┌─────────────────────────┐
│   커널      │                │         커널            │
├─────────────┤                ├─────────────────────────┤
│   스택      │                │ 스레드1 │ 스레드2 │ 스레드3│
│     ↓       │                │  스택   │  스택   │  스택  │
│             │                │   ↓     │   ↓     │   ↓    │
├ ─ ─ ─ ─ ─ ─ ┤                ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤
│             │                │                         │
│     ↑       │                │           ↑             │
│   힙        │                │         힙 (공유)        │
├─────────────┤                ├─────────────────────────┤
│   데이터    │                │       데이터 (공유)       │
├─────────────┤                ├─────────────────────────┤
│   코드      │                │       코드 (공유)        │
└─────────────┘                └─────────────────────────┘
```

### 비용 비교

```
┌─────────────────────────────────────────────────────────┐
│               프로세스 vs 스레드 비용 비교                │
├───────────────────┬─────────────┬───────────────────────┤
│       항목         │   프로세스   │        스레드         │
├───────────────────┼─────────────┼───────────────────────┤
│ 생성 시간         │    느림     │         빠름          │
│ (Linux 기준)      │  ~10ms      │        ~1ms           │
├───────────────────┼─────────────┼───────────────────────┤
│ 컨텍스트 스위치    │    느림     │         빠름          │
│                   │ TLB 플러시   │ TLB 유지 가능          │
├───────────────────┼─────────────┼───────────────────────┤
│ 메모리 사용       │    많음     │         적음          │
│                   │ 독립된 공간  │  공유 공간            │
├───────────────────┼─────────────┼───────────────────────┤
│ 통신 비용         │    높음     │         낮음          │
│                   │  IPC 필요   │  직접 메모리 접근      │
├───────────────────┼─────────────┼───────────────────────┤
│ 안정성            │    높음     │         낮음          │
│                   │ 격리됨      │  하나가 죽으면 전체 영향│
└───────────────────┴─────────────┴───────────────────────┘
```

---

## 3. 스레드 제어 블록 (TCB)

### TCB 구조

```
┌───────────────────────────────────────────────────────┐
│                   TCB (Thread Control Block)          │
├───────────────────────────────────────────────────────┤
│                                                       │
│  ┌─────────────────────────────────────────────────┐  │
│  │ 스레드 ID (TID)                                 │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ 스레드 상태 (Running, Ready, Blocked...)        │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ 프로그램 카운터 (PC)                            │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ CPU 레지스터 (범용 레지스터, 플래그...)          │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ 스택 포인터                                     │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ 스케줄링 정보 (우선순위)                        │  │
│  ├─────────────────────────────────────────────────┤  │
│  │ 소속 프로세스 PCB 포인터                        │  │
│  └─────────────────────────────────────────────────┘  │
│                                                       │
│  TCB는 PCB보다 훨씬 작음 (스레드 전환이 빠른 이유)     │
│                                                       │
└───────────────────────────────────────────────────────┘
```

### PCB와 TCB 관계

```
┌─────────────────────────────────────────────────────────┐
│                        PCB                              │
│  ┌───────────────────────────────────────────────────┐  │
│  │ PID, 메모리 정보, 열린 파일, 시그널 핸들러...      │  │
│  │                                                   │  │
│  │  스레드 목록:                                     │  │
│  │  ┌───────────────────────────────────────────┐   │  │
│  │  │     TCB1      │     TCB2      │    TCB3   │   │  │
│  │  │ TID, PC, SP,  │ TID, PC, SP,  │ TID, PC,  │   │  │
│  │  │ 레지스터, 상태 │ 레지스터, 상태 │ SP, ...   │   │  │
│  │  └───────────────────────────────────────────┘   │  │
│  │                                                   │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

---

## 4. 사용자 스레드와 커널 스레드

### 사용자 수준 스레드 (User-Level Threads)

```
┌─────────────────────────────────────────────────────────┐
│              사용자 수준 스레드 (ULT)                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   사용자 공간:                                          │
│   ┌───────────────────────────────────────────────────┐ │
│   │              응용 프로그램                         │ │
│   │  ┌─────────────────────────────────────────────┐  │ │
│   │  │  스레드1    스레드2    스레드3               │  │ │
│   │  └─────────────────────────────────────────────┘  │ │
│   │              ↑    ↑    ↑                         │ │
│   │              └────┼────┘                         │ │
│   │                   ↓                              │ │
│   │         스레드 라이브러리                         │ │
│   │         (스케줄링, 생성, 동기화)                  │ │
│   └───────────────────────────────────────────────────┘ │
│                       │                                 │
│   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ │
│                       │                                 │
│   커널 공간:          ↓                                 │
│   ┌───────────────────────────────────────────────────┐ │
│   │              커널 (단일 스레드로 인식)              │ │
│   │                                                   │ │
│   │   커널은 프로세스만 알고, 스레드는 모름             │ │
│   └───────────────────────────────────────────────────┘ │
│                                                         │
│   장점: 빠른 컨텍스트 스위치, 이식성                     │
│   단점: 하나가 블로킹되면 전체 블로킹, 멀티코어 활용 불가 │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 커널 수준 스레드 (Kernel-Level Threads)

```
┌─────────────────────────────────────────────────────────┐
│              커널 수준 스레드 (KLT)                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   사용자 공간:                                          │
│   ┌───────────────────────────────────────────────────┐ │
│   │              응용 프로그램                         │ │
│   │  ┌─────────────────────────────────────────────┐  │ │
│   │  │  스레드1    스레드2    스레드3               │  │ │
│   │  └─────────────────────────────────────────────┘  │ │
│   └───────────────────────────────────────────────────┘ │
│              │         │         │                      │
│   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ │
│              ↓         ↓         ↓                      │
│   커널 공간:                                            │
│   ┌───────────────────────────────────────────────────┐ │
│   │              커널 스케줄러                         │ │
│   │  ┌─────────────────────────────────────────────┐  │ │
│   │  │ K-스레드1  K-스레드2  K-스레드3              │  │ │
│   │  └─────────────────────────────────────────────┘  │ │
│   │                                                   │ │
│   │   커널이 각 스레드를 개별적으로 스케줄링           │ │
│   └───────────────────────────────────────────────────┘ │
│                                                         │
│   장점: 멀티코어 활용, 블로킹 시 다른 스레드 실행        │
│   단점: 느린 컨텍스트 스위치 (시스템 콜 필요)            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 비교표

```
┌────────────────────┬────────────────────┬────────────────────┐
│       특성         │    사용자 스레드    │    커널 스레드      │
├────────────────────┼────────────────────┼────────────────────┤
│ 관리 주체          │ 스레드 라이브러리   │ 운영체제 커널       │
├────────────────────┼────────────────────┼────────────────────┤
│ 생성/전환 속도     │ 빠름 (시스템콜 X)  │ 느림 (시스템콜 O)   │
├────────────────────┼────────────────────┼────────────────────┤
│ 멀티코어 활용      │ 불가능             │ 가능               │
├────────────────────┼────────────────────┼────────────────────┤
│ 블로킹 시스템콜    │ 전체 프로세스 블록  │ 해당 스레드만 블록  │
├────────────────────┼────────────────────┼────────────────────┤
│ OS 지원 필요       │ 불필요             │ 필요               │
├────────────────────┼────────────────────┼────────────────────┤
│ 예시               │ GNU Portable Threads│ Linux NPTL, Windows│
└────────────────────┴────────────────────┴────────────────────┘
```

---

## 5. 멀티스레딩 모델

### 다대일 모델 (Many-to-One, N:1)

```
┌─────────────────────────────────────────────────────────┐
│                  다대일 모델 (N:1)                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   사용자 공간:                                          │
│   ┌─────────────────────────────────────────────────┐   │
│   │  ULT1    ULT2    ULT3    ULT4    ULT5          │   │
│   │   │       │       │       │       │            │   │
│   │   └───────┼───────┼───────┼───────┘            │   │
│   │           └───────┼───────┘                    │   │
│   │                   ↓                            │   │
│   │           스레드 라이브러리                     │   │
│   └─────────────────────────────────────────────────┘   │
│                       │                                 │
│   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ │
│                       ↓                                 │
│   커널 공간:    ┌──────────┐                            │
│                 │  KLT 1   │                            │
│                 └──────────┘                            │
│                                                         │
│   • 장점: 효율적인 스레드 관리                          │
│   • 단점: 멀티코어 활용 불가, 하나 블로킹 시 전체 블로킹  │
│   • 예시: 초기 Green Threads                            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 일대일 모델 (One-to-One, 1:1)

```
┌─────────────────────────────────────────────────────────┐
│                  일대일 모델 (1:1)                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   사용자 공간:                                          │
│   ┌─────────────────────────────────────────────────┐   │
│   │  ULT1    ULT2    ULT3    ULT4                  │   │
│   │   │       │       │       │                    │   │
│   └───┼───────┼───────┼───────┼────────────────────┘   │
│       │       │       │       │                        │
│   ━━━━│━━━━━━━│━━━━━━━│━━━━━━━│━━━━━━━━━━━━━━━━━━━━━━━ │
│       ↓       ↓       ↓       ↓                        │
│   커널 공간:                                            │
│   ┌───────────────────────────────────────────────┐     │
│   │  KLT1    KLT2    KLT3    KLT4                │     │
│   └───────────────────────────────────────────────┘     │
│                                                         │
│   • 장점: 멀티코어 활용, 블로킹 시 다른 스레드 계속 실행  │
│   • 단점: 커널 스레드 생성 오버헤드                      │
│   • 예시: Linux NPTL, Windows, macOS                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 다대다 모델 (Many-to-Many, M:N)

```
┌─────────────────────────────────────────────────────────┐
│                  다대다 모델 (M:N)                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   사용자 공간:                                          │
│   ┌─────────────────────────────────────────────────┐   │
│   │  ULT1  ULT2  ULT3  ULT4  ULT5  ULT6  ULT7     │   │
│   │   │     │     │     │     │     │     │       │   │
│   │   └─────┼─────┼─────┼─────┼─────┼─────┘       │   │
│   │         └─────┼─────┼─────┼─────┘             │   │
│   │               ↓     ↓     ↓                   │   │
│   │           스레드 스케줄러                      │   │
│   └─────────────────────────────────────────────────┘   │
│                   │     │     │                        │
│   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ │
│                   ↓     ↓     ↓                        │
│   커널 공간:                                            │
│   ┌───────────────────────────────────────────────┐     │
│   │      KLT1      KLT2      KLT3                │     │
│   └───────────────────────────────────────────────┘     │
│                                                         │
│   7개의 사용자 스레드가 3개의 커널 스레드에 매핑          │
│                                                         │
│   • 장점: 유연성, 효율성과 병렬성의 균형                 │
│   • 단점: 구현 복잡성                                   │
│   • 예시: Solaris, Go goroutines                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 모델 비교

```
┌──────────────┬──────────────┬──────────────┬──────────────┐
│     특성      │   N:1       │    1:1      │    M:N      │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ 병렬 실행     │ 불가능       │ 가능         │ 가능         │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ 블로킹 문제   │ 전체 블로킹   │ 영향 없음    │ 부분적 영향  │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ 스레드 생성   │ 빠름         │ 느림         │ 중간         │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ 구현 복잡도   │ 낮음         │ 낮음         │ 높음         │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ 스케일러빌리티│ 낮음         │ 높음         │ 높음         │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ 현대 OS      │ 거의 사용 X   │ 주로 사용    │ 일부 사용    │
└──────────────┴──────────────┴──────────────┴──────────────┘
```

---

## 6. pthread API 기초

### 스레드 생성과 종료

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

// 스레드가 실행할 함수
void* thread_function(void* arg) {
    int thread_num = *(int*)arg;
    printf("스레드 %d 시작\n", thread_num);

    // 작업 수행
    sleep(1);

    printf("스레드 %d 종료\n", thread_num);
    return NULL;
}

int main() {
    pthread_t threads[3];
    int thread_args[3] = {1, 2, 3};

    // 스레드 생성
    for (int i = 0; i < 3; i++) {
        int result = pthread_create(&threads[i], NULL,
                                    thread_function, &thread_args[i]);
        if (result != 0) {
            perror("pthread_create failed");
            exit(1);
        }
    }

    // 모든 스레드가 종료될 때까지 대기
    for (int i = 0; i < 3; i++) {
        pthread_join(threads[i], NULL);
        printf("스레드 %d join 완료\n", thread_args[i]);
    }

    printf("메인 스레드 종료\n");
    return 0;
}

/*
컴파일: gcc -pthread thread_example.c -o thread_example

출력 (순서는 달라질 수 있음):
스레드 1 시작
스레드 2 시작
스레드 3 시작
스레드 1 종료
스레드 2 종료
스레드 3 종료
스레드 1 join 완료
스레드 2 join 완료
스레드 3 join 완료
메인 스레드 종료
*/
```

### pthread API 주요 함수

```
┌────────────────────────┬────────────────────────────────────┐
│        함수             │              설명                  │
├────────────────────────┼────────────────────────────────────┤
│ pthread_create()       │ 새 스레드 생성                      │
│ pthread_join()         │ 스레드 종료 대기                    │
│ pthread_exit()         │ 현재 스레드 종료                    │
│ pthread_self()         │ 현재 스레드 ID 반환                 │
│ pthread_equal()        │ 두 스레드 ID 비교                   │
│ pthread_detach()       │ 스레드 분리 (자동 자원 회수)         │
│ pthread_cancel()       │ 다른 스레드 취소 요청               │
├────────────────────────┼────────────────────────────────────┤
│ pthread_mutex_init()   │ 뮤텍스 초기화                       │
│ pthread_mutex_lock()   │ 뮤텍스 잠금                         │
│ pthread_mutex_unlock() │ 뮤텍스 해제                         │
│ pthread_mutex_destroy()│ 뮤텍스 파괴                         │
├────────────────────────┼────────────────────────────────────┤
│ pthread_cond_init()    │ 조건 변수 초기화                    │
│ pthread_cond_wait()    │ 조건 변수 대기                      │
│ pthread_cond_signal()  │ 조건 변수 시그널                    │
│ pthread_cond_broadcast()│ 모든 대기 스레드에 시그널           │
└────────────────────────┴────────────────────────────────────┘
```

### 반환 값 받기

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// 정수의 제곱을 계산하고 반환
void* calculate_square(void* arg) {
    int num = *(int*)arg;
    int* result = malloc(sizeof(int));
    *result = num * num;

    printf("스레드: %d의 제곱 = %d\n", num, *result);

    return (void*)result;  // 힙에 할당된 결과 반환
}

int main() {
    pthread_t thread;
    int num = 5;
    void* result;

    // 스레드 생성
    pthread_create(&thread, NULL, calculate_square, &num);

    // 스레드 종료 대기 및 결과 받기
    pthread_join(thread, &result);

    printf("메인: 결과 = %d\n", *(int*)result);

    free(result);  // 메모리 해제

    return 0;
}

/*
출력:
스레드: 5의 제곱 = 25
메인: 결과 = 25
*/
```

### 스레드 분리 (Detach)

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

void* detached_thread(void* arg) {
    printf("분리된 스레드 시작\n");
    sleep(2);
    printf("분리된 스레드 종료\n");
    return NULL;
}

int main() {
    pthread_t thread;
    pthread_attr_t attr;

    // 스레드 속성 초기화
    pthread_attr_init(&attr);

    // 분리 상태로 설정
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    // 분리된 스레드 생성
    pthread_create(&thread, &attr, detached_thread, NULL);

    // 속성 객체 파괴
    pthread_attr_destroy(&attr);

    printf("메인 스레드: 분리된 스레드를 join하지 않아도 됨\n");

    // 분리된 스레드가 실행할 시간 확보
    sleep(3);

    printf("메인 스레드 종료\n");
    return 0;
}

/*
분리된 스레드:
- 종료 시 자동으로 자원 회수
- pthread_join() 불필요 (오히려 에러)
- 백그라운드 작업에 적합
*/
```

### 스레드 안전 문제 예시

```c
#include <stdio.h>
#include <pthread.h>

int counter = 0;  // 공유 변수

void* increment(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        counter++;  // 경쟁 상태 (Race Condition)!
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;

    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    // 예상: 2000000, 실제: 그보다 작은 값 (매번 다름)
    printf("Counter: %d\n", counter);

    return 0;
}

/*
counter++ 연산은 원자적이지 않음:
1. 메모리에서 counter 값 읽기
2. 값 증가
3. 메모리에 결과 저장

두 스레드가 동시에 실행하면 값이 손실됨 (다음 레슨에서 해결)
*/
```

---

## 7. 연습 문제

### 문제 1: 스레드와 프로세스

다음 중 스레드가 공유하지 않는 것을 모두 고르세요.

A. 코드 섹션
B. 데이터 섹션
C. 스택
D. 힙
E. 프로그램 카운터
F. 열린 파일

<details>
<summary>정답 보기</summary>

**C, E**

- 스택: 각 스레드는 자신만의 스택을 가짐 (지역 변수, 함수 호출 정보)
- 프로그램 카운터: 각 스레드는 다른 위치의 코드를 실행할 수 있음

나머지는 모두 스레드 간 공유됨.

</details>

### 문제 2: 멀티스레딩 모델

다음 설명에 맞는 멀티스레딩 모델을 고르세요.

1. 하나의 사용자 스레드가 블로킹되면 전체 프로세스가 블로킹된다.
2. Linux NPTL이 사용하는 모델이다.
3. 커널 스레드 수보다 많은 사용자 스레드를 효율적으로 관리할 수 있다.

보기: N:1, 1:1, M:N

<details>
<summary>정답 보기</summary>

1. **N:1 (다대일)** - 모든 사용자 스레드가 하나의 커널 스레드에 매핑되므로, 하나가 블로킹되면 전체가 블로킹됨
2. **1:1 (일대일)** - Linux NPTL, Windows, macOS가 사용하는 모델
3. **M:N (다대다)** - 여러 사용자 스레드를 적은 수의 커널 스레드에 매핑하여 효율적으로 관리

</details>

### 문제 3: pthread 코드 분석

다음 코드의 출력 결과로 가능한 것을 모두 고르세요.

```c
#include <stdio.h>
#include <pthread.h>

void* print_msg(void* arg) {
    char* msg = (char*)arg;
    printf("%s", msg);
    return NULL;
}

int main() {
    pthread_t t1, t2;

    pthread_create(&t1, NULL, print_msg, "A");
    pthread_create(&t2, NULL, print_msg, "B");

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("C");
    return 0;
}
```

A. ABC
B. BAC
C. CAB
D. ACB

<details>
<summary>정답 보기</summary>

**A, B**

- A와 B의 출력 순서는 스레드 스케줄링에 따라 달라질 수 있음
- C는 항상 마지막 (두 스레드가 모두 join된 후 출력)
- 따라서 가능한 출력: ABC 또는 BAC

CAB, ACB는 불가능 (C는 join 이후에만 출력됨)

</details>

### 문제 4: 스레드 생성

다음 코드의 문제점을 설명하세요.

```c
#include <stdio.h>
#include <pthread.h>

void* thread_func(void* arg) {
    int* num = (int*)arg;
    printf("Thread: %d\n", *num);
    return NULL;
}

int main() {
    pthread_t threads[5];

    for (int i = 0; i < 5; i++) {
        pthread_create(&threads[i], NULL, thread_func, &i);
    }

    for (int i = 0; i < 5; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}
```

<details>
<summary>정답 보기</summary>

**문제: 경쟁 상태 (Race Condition)**

모든 스레드가 같은 변수 `i`의 주소를 전달받음. 스레드가 실행될 때 `i`의 값이 이미 변경되어 있을 수 있음.

예상 출력: 0, 1, 2, 3, 4
실제 가능한 출력: 5, 5, 5, 5, 5 또는 2, 3, 4, 5, 5 등

**해결 방법:**

```c
int thread_args[5];

for (int i = 0; i < 5; i++) {
    thread_args[i] = i;
    pthread_create(&threads[i], NULL, thread_func, &thread_args[i]);
}
```

각 스레드에 별도의 인자 공간을 할당해야 함.

</details>

### 문제 5: TCB와 PCB

TCB가 PCB보다 작은 이유를 스레드의 특성과 연관지어 설명하세요.

<details>
<summary>정답 보기</summary>

TCB가 PCB보다 작은 이유:

1. **자원 공유**: 스레드는 코드, 데이터, 힙, 열린 파일 등을 같은 프로세스의 다른 스레드와 공유함. 이 정보는 PCB에만 저장되고 TCB에는 저장할 필요가 없음.

2. **TCB에 저장되는 정보가 적음**:
   - 스레드 ID
   - 프로그램 카운터
   - 레지스터 집합
   - 스택 포인터
   - 스레드 상태
   - 우선순위

3. **PCB에 추가로 저장되는 정보**:
   - 메모리 관리 정보 (페이지 테이블)
   - 열린 파일 목록
   - I/O 상태
   - 계정 정보
   - 시그널 핸들러

결과적으로 스레드 컨텍스트 스위치가 프로세스 컨텍스트 스위치보다 빠름.

</details>

---

## 실습 과제

### 실습 1: 경쟁 조건과 GIL

`examples/OS_Theory/03_threading_demo.py`를 실행하고 경쟁 조건(Race Condition)과 GIL 데모를 관찰하세요.

**과제:**
1. `demo_race_condition()`에서 반복 횟수를 1,000,000으로 변경하세요. 안전하지 않은 카운터가 정확한 결과를 생성하는 경우가 있나요? 10번 실행하고 오류율을 기록하세요
2. Python의 GIL이 단순 정수 증가에서는 경쟁 조건을 방지하지만 검사-후-행동 패턴(예: `if balance > 0: balance -= 1`)에서는 방지하지 못하는 이유를 설명하세요
3. `threading.RLock`(재진입 락)을 사용하도록 스레딩 데모를 수정하고, 일반 `Lock`은 교착 상태에 빠지지만 `RLock`은 성공하는 시나리오를 시연하세요

### 실습 2: 스레드 vs 프로세스 성능

스레드 생성 vs 프로세스 생성 오버헤드를 비교하는 벤치마크를 작성하세요:

```python
import threading, multiprocessing, time

def worker():
    pass  # 최소한의 작업

def benchmark(label, create_func, n=1000):
    start = time.perf_counter()
    items = [create_func(target=worker) for _ in range(n)]
    for item in items:
        item.start()
    for item in items:
        item.join()
    elapsed = time.perf_counter() - start
    print(f"{label}: {elapsed*1000:.1f} ms for {n} workers")

benchmark("Threads", threading.Thread)
benchmark("Processes", multiprocessing.Process, n=100)
```

**과제:**
1. 벤치마크를 실행하고 스레드 vs 프로세스 생성 시간을 비교하세요
2. 프로세스 생성이 더 느린 이유는? fork()에 어떤 추가 설정이 필요한가요?
3. CPU 바운드 작업(1부터 1M까지 합산)을 추가하고 총 실행 시간을 비교하세요 — 언제 프로세스가 이기나요?

### 실습 3: 스레드 풀 패턴

새 스레드를 생성하는 대신 스레드를 재사용하는 간단한 스레드 풀(Thread Pool)을 구현하세요:

**과제:**
1. `submit(func, *args)` 메서드가 있는 `ThreadPool(n_workers)` 클래스를 생성하세요
2. 작업 분배에 `queue.Queue`를 사용하세요
3. 4개 워커 풀에서 100개 작업으로 테스트하고 모든 작업이 완료되는지 확인하세요
4. 100개 개별 스레드를 생성하는 것과 총 시간을 비교하세요

---

## 연습 문제

### 연습 1: 스레드(Thread)와 프로세스(Process)의 자원 공유

웹 서버가 들어오는 각 요청마다 새 **스레드(thread)**를 생성합니다. 아래 나열된 각 자원이 모든 스레드 간에 **공유(shared)**되는지, 각 스레드에 **독립적(private)**인지 명시하고 이유를 설명하세요.

| 자원 | 공유 또는 독립? | 이유? |
|------|----------------|-------|
| 전역 변수 `int total_requests` | | |
| 핸들러 내부의 지역 변수 `char buf[4096]` | | |
| 접근 로그용으로 열린 파일 디스크립터(file descriptor) | | |
| errno 값 | | |
| 힙(Heap)에 `malloc()`으로 할당된 요청 객체 | | |
| 시그널 처리 방식(SIGTERM → 정상 종료) | | |

### 연습 2: 멀티스레딩 모델(Multithreading Model) 비교

학생이 새 애플리케이션을 위한 스레딩 모델을 선택하려 합니다. 각 시나리오를 평가하고 가장 적합한 모델(N:1, 1:1, M:N)을 추천하되 이유를 설명하세요.

1. 12코어 머신의 8개 CPU 코어에 걸쳐 행렬 곱셈을 병렬화하는 과학 시뮬레이션
2. 커널 스레드(kernel thread)를 지원하지 않는 레거시 임베디드 시스템에서 협력적(cooperative) 멀티태스킹이 필요한 경우
3. 4코어 시스템에서 10,000개의 동시 연결을 처리하는 고동시성(high-concurrency) 서버
4. UI 응답성을 유지하기 위해 하나의 백그라운드 작업을 오프로드(offload)하는 간단한 데스크톱 GUI 앱

### 연습 3: 경쟁 조건(Race Condition) 분석

두 스레드가 동시에 실행하는 다음 코드를 살펴보세요. 모든 경쟁 조건(race condition)을 식별하고, 각각에 대해 (a) 관련된 공유 자원, (b) 잘못된 동작을 유발하는 구체적인 인터리빙(interleaving), (c) 수정 방법을 설명하세요.

```c
#include <stdio.h>
#include <pthread.h>

int counter = 0;
int log_count = 0;
FILE *log_file;

void *worker(void *arg) {
    int id = *(int *)arg;
    for (int i = 0; i < 1000; i++) {
        counter++;                            // (A)
        fprintf(log_file, "thread %d: %d\n", id, counter);  // (B)
        log_count++;                          // (C)
    }
    return NULL;
}
```

1. 경쟁 조건이 몇 개 존재하나요? 각각 나열하세요.
2. 동기화(synchronization)가 없을 때 두 스레드가 종료된 후 `counter`의 기댓값은 얼마인가요? 실제로 가능한 값의 범위는?
3. `pthread_mutex_t`를 사용하여 경쟁 조건을 수정하세요.

### 연습 4: 컨텍스트 스위치(Context Switch) 시 TCB 필드

스레드가 실행 중 선점(preemption)됩니다. 선점 순간에 스레드 제어 블록(Thread Control Block, TCB)에 저장해야 하는 필드를 나열하고, 각 필드가 저장되지 않을 경우 어떤 문제가 발생하는지 설명하세요.

| TCB 필드 | 저장하지 않을 경우 결과 |
|----------|------------------------|
| 프로그램 카운터(Program Counter) | |
| 스택 포인터(Stack Pointer) | |
| 범용 레지스터(General-purpose registers) | |
| 부동소수점 레지스터(Floating-point registers) | |
| 스레드 상태(Thread state) | |

### 연습 5: 동시성(Concurrency)을 위한 설계

단일 스레드 이미지 처리 서버가 순차적으로 작업을 처리합니다: (1) 네트워크로 이미지 수신, (2) 크기 조정, (3) 필터 적용, (4) 디스크에 저장. 측정된 시간은 네트워크 I/O 200ms, 크기 조정 50ms, 필터 150ms, 디스크 I/O 100ms입니다. 서버는 한 번에 하나의 요청을 처리합니다.

1. 요청 하나의 총 지연 시간(latency)과 최대 처리량(throughput, 초당 요청 수)은 얼마인가요?
2. 처리량을 최대화하기 위해 멀티스레딩(multithreading)을 사용하여 서버를 재설계하세요. 설계 내용(스레드 수, 각 스레드의 역할, 통신 방식)을 설명하세요.
3. 어떤 단계가 멀티코어 CPU에서 진정한 병렬 처리의 이점을 얻을 수 있나요? 스레드를 사용해도 I/O에 의해 제한되는 단계는 어느 것인가요?
4. CPU 단계가 I/O 단계와 겹칠 수 있다면, 멀티스레드 설계의 이론적 최대 처리량은 얼마인가요?

---

## 다음 단계

- [04_CPU_스케줄링_기초.md](./04_CPU_스케줄링_기초.md) - CPU 스케줄링의 기본 개념

---

## 참고 자료

- [POSIX Threads Programming](https://computing.llnl.gov/tutorials/pthreads/)
- [Linux man pages - pthreads](https://man7.org/linux/man-pages/man7/pthreads.7.html)
- [OSTEP - Concurrency: Threads](https://pages.cs.wisc.edu/~remzi/OSTEP/threads-intro.pdf)


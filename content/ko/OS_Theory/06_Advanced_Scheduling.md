# 고급 스케줄링

**이전**: [스케줄링 알고리즘](./05_Scheduling_Algorithms.md) | **다음**: [동기화 기초](./07_Synchronization_Basics.md)

---

## 학습 목표(Learning Objectives)

이 레슨을 완료하면 다음을 할 수 있습니다:

1. MLFQ가 버스트 시간에 대한 사전 지식 없이 프로세스 동작에 적응하는 방식을 설명할 수 있습니다
2. MLFQ의 문제점(기아, 게이밍)을 분석하고 해결책(우선순위 부스트, 누적 추적)을 설명할 수 있습니다
3. 대칭 멀티프로세싱(Symmetric Multiprocessing)과 비대칭 멀티프로세싱(Asymmetric Multiprocessing)을 구분하고, 스케줄링에 미치는 영향을 설명할 수 있습니다
4. 프로세서 친화성(Processor Affinity)과 부하 분산(Load Balancing)을 설명하고, 캐시 효율과 균등한 워크로드 분배 사이의 트레이드오프를 설명할 수 있습니다
5. 경성 실시간(Hard Real-Time)과 연성 실시간(Soft Real-Time) 스케줄링을 구분하고, 각각에 적합한 사용 사례를 파악할 수 있습니다
6. 단조 주기 스케줄링(Rate Monotonic Scheduling, RMS)과 최조기 마감 우선(Earliest Deadline First, EDF)을 우선순위 할당, 이용률 한계, 오버헤드 측면에서 비교할 수 있습니다
7. 범용 시스템부터 실시간 시스템까지 다양한 워크로드에 대한 스케줄링 알고리즘 트레이드오프를 평가할 수 있습니다

---

실제 시스템은 교과서의 단순한 알고리즘을 그대로 사용하지 않습니다 -- 여러 기법을 조합하고 적응시킵니다. Linux의 CFS, Windows의 스레드 스케줄러, 실시간 시스템은 각각 다른 목표를 최적화하기 때문에 서로 다른 방식으로 스케줄링 문제를 해결합니다. 이 레슨에서는 실제 운영체제에서 사용되는 고급 스케줄링 기법인 MLFQ, 친화성과 부하 분산을 갖춘 멀티프로세서 스케줄링, 실시간 스케줄링 보장, 그리고 Linux의 완전 공정 스케줄러(Completely Fair Scheduler)를 다룹니다.

## 목차

1. [MLFQ (Multi-Level Feedback Queue)](#1-mlfq-multi-level-feedback-queue)
2. [멀티프로세서 스케줄링](#2-멀티프로세서-스케줄링)
3. [프로세서 친화성](#3-프로세서-친화성)
4. [실시간 스케줄링](#4-실시간-스케줄링)
5. [Linux CFS](#5-linux-cfs)
6. [연습 문제](#6-연습-문제)

---

## 1. MLFQ (Multi-Level Feedback Queue)

### 개념

```
MLFQ = 여러 개의 준비 큐를 사용하는 스케줄링
     = 프로세스의 행동에 따라 큐 간 이동
     = SJF의 장점 + 적응형 스케줄링

┌─────────────────────────────────────────────────────────┐
│                      MLFQ 구조                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  높은 우선순위 (짧은 Time Quantum)                       │
│  ┌─────────────────────────────────────────────────┐    │
│  │ Queue 0 (TQ=8ms): P1 → P5 → ...                │ ←── 새 프로세스
│  └─────────────────────────────────────────────────┘    │
│                          │                              │
│                          ▼ TQ 소진 시 강등              │
│  ┌─────────────────────────────────────────────────┐    │
│  │ Queue 1 (TQ=16ms): P2 → P7 → ...               │    │
│  └─────────────────────────────────────────────────┘    │
│                          │                              │
│                          ▼ TQ 소진 시 강등              │
│  ┌─────────────────────────────────────────────────┐    │
│  │ Queue 2 (TQ=32ms): P3 → P8 → ...               │    │
│  └─────────────────────────────────────────────────┘    │
│                          │                              │
│                          ▼                              │
│  ┌─────────────────────────────────────────────────┐    │
│  │ Queue N (FCFS): P4 → P6 → ...                  │    │
│  └─────────────────────────────────────────────────┘    │
│  낮은 우선순위 (긴 Time Quantum 또는 FCFS)              │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### MLFQ 규칙

```
┌─────────────────────────────────────────────────────────┐
│                    MLFQ 기본 규칙                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  규칙 1: 우선순위가 높은 프로세스 먼저 실행              │
│         Priority(A) > Priority(B) → A 실행              │
│                                                         │
│  규칙 2: 우선순위가 같으면 RR 방식                       │
│         Priority(A) = Priority(B) → RR                  │
│                                                         │
│  규칙 3: 새 프로세스는 최상위 큐에 배치                  │
│         새 프로세스 → Queue 0                           │
│                                                         │
│  규칙 4: 타임 퀀텀을 모두 사용하면 강등                  │
│         TQ 소진 → Priority 감소                         │
│                                                         │
│  규칙 5: TQ 전에 CPU를 양보하면 같은 큐 유지             │
│         I/O 요청 등 → 같은 Priority 유지                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### MLFQ 동작 예제

```
시나리오: 긴 작업 (CPU-bound)와 짧은 작업 (I/O-bound) 혼합

┌─────────────────────────────────────────────────────────┐
│  시간 0: 긴 작업 A 도착                                  │
│                                                         │
│  Q0: [A] ───▶ A 실행 (8ms)                             │
│  Q1: []                                                 │
│  Q2: []                                                 │
├─────────────────────────────────────────────────────────┤
│  시간 8: A가 TQ 소진 → 강등                             │
│                                                         │
│  Q0: []                                                 │
│  Q1: [A] ───▶ A 실행 (16ms)                            │
│  Q2: []                                                 │
├─────────────────────────────────────────────────────────┤
│  시간 10: 짧은 작업 B 도착 (5ms 작업)                   │
│                                                         │
│  Q0: [B] ───▶ B가 높은 우선순위, A 선점                 │
│  Q1: [A]     B 실행 시작                                │
│  Q2: []                                                 │
├─────────────────────────────────────────────────────────┤
│  시간 15: B 완료 (TQ 전에 끝남 → I/O 많은 작업으로 간주) │
│                                                         │
│  Q0: []                                                 │
│  Q1: [A] ───▶ A 재개                                   │
│  Q2: []                                                 │
└─────────────────────────────────────────────────────────┘

결과: 짧은 작업이 먼저 완료됨 (SJF와 유사한 효과)
      실행 시간을 모르면서도 짧은 작업 우선 처리 가능
```

### MLFQ 문제점과 해결

```
┌─────────────────────────────────────────────────────────┐
│                  MLFQ 문제점과 해결                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  문제 1: 기아 (Starvation)                              │
│  ┌───────────────────────────────────────────────────┐  │
│  │ 높은 우선순위 작업이 계속 도착하면                  │  │
│  │ 낮은 큐의 작업은 영원히 실행 안 됨                  │  │
│  └───────────────────────────────────────────────────┘  │
│  해결: Priority Boost                                   │
│  ┌───────────────────────────────────────────────────┐  │
│  │ 주기적으로 모든 프로세스를 최상위 큐로 이동         │  │
│  │ 예: 매 S 시간마다 모든 작업을 Q0으로               │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  문제 2: 게이밍 (Gaming the Scheduler)                  │
│  ┌───────────────────────────────────────────────────┐  │
│  │ 악의적인 프로세스가 TQ 만료 직전에 I/O 요청         │  │
│  │ → 강등 방지, CPU 독점                              │  │
│  └───────────────────────────────────────────────────┘  │
│  해결: 누적 시간 추적                                   │
│  ┌───────────────────────────────────────────────────┐  │
│  │ 각 레벨에서 사용한 총 시간을 누적 추적              │  │
│  │ 할당량 소진 시 강등 (여러 번에 나눠 쓰더라도)       │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### MLFQ 파라미터

```
┌─────────────────────────────────────────────────────────┐
│                   MLFQ 주요 파라미터                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 큐 개수 (Number of queues)                         │
│     • 일반적으로 3~5개                                  │
│     • 너무 많으면 오버헤드, 너무 적으면 차별화 부족      │
│                                                         │
│  2. 각 큐의 Time Quantum                               │
│     • 보통 2배씩 증가 (8, 16, 32, 64ms...)             │
│     • 높은 큐: 짧은 TQ (빠른 응답)                      │
│     • 낮은 큐: 긴 TQ (컨텍스트 스위치 감소)             │
│                                                         │
│  3. Priority Boost 주기 (S)                            │
│     • 너무 짧으면: CPU-bound 작업 유리                 │
│     • 너무 길면: 기아 발생                             │
│     • 일반적으로 1초 ~ 100ms                           │
│                                                         │
│  Solaris Time-sharing 클래스 예:                       │
│  ┌─────────┬──────┬──────────┬─────────────┐           │
│  │ Priority │  TQ  │  강등시  │   승격시    │           │
│  ├─────────┼──────┼──────────┼─────────────┤           │
│  │   59    │ 20ms │   54     │    -        │           │
│  │   40    │ 40ms │   35     │    45       │           │
│  │   20    │ 80ms │   15     │    25       │           │
│  │   0     │ 200ms│   0      │    5        │           │
│  └─────────┴──────┴──────────┴─────────────┘           │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 2. 멀티프로세서 스케줄링

### 멀티프로세서 시스템 유형

```
┌─────────────────────────────────────────────────────────┐
│               멀티프로세서 시스템 유형                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. SMP (Symmetric Multi-Processing)                   │
│  ┌───────────────────────────────────────────────────┐  │
│  │  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐                 │  │
│  │  │CPU 0│ │CPU 1│ │CPU 2│ │CPU 3│                 │  │
│  │  └──┬──┘ └──┬──┘ └──┬──┘ └──┬──┘                 │  │
│  │     └───────┴───────┴───────┘                     │  │
│  │                 │                                 │  │
│  │          ┌──────┴──────┐                         │  │
│  │          │ 공유 메모리  │                         │  │
│  │          └─────────────┘                         │  │
│  │  모든 프로세서가 동등, 메모리 공유                 │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  2. NUMA (Non-Uniform Memory Access)                   │
│  ┌───────────────────────────────────────────────────┐  │
│  │  ┌─────────────┐     ┌─────────────┐             │  │
│  │  │ CPU 0, 1    │     │ CPU 2, 3    │             │  │
│  │  │ 로컬 메모리  │◀───▶│ 로컬 메모리  │             │  │
│  │  └─────────────┘     └─────────────┘             │  │
│  │                                                   │  │
│  │  로컬 메모리 접근: 빠름                            │  │
│  │  원격 메모리 접근: 느림                            │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 스케줄링 접근 방법

```
┌─────────────────────────────────────────────────────────┐
│             멀티프로세서 스케줄링 접근 방법               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 비대칭 멀티프로세싱 (Asymmetric)                    │
│  ┌───────────────────────────────────────────────────┐  │
│  │  ┌─────────────────┐                             │  │
│  │  │ 마스터 프로세서  │ ← 모든 스케줄링 결정         │  │
│  │  │   (CPU 0)       │                             │  │
│  │  └────────┬────────┘                             │  │
│  │           │ 작업 할당                             │  │
│  │     ┌─────┼─────┬─────┐                          │  │
│  │     ▼     ▼     ▼     ▼                          │  │
│  │  ┌─────┐┌─────┐┌─────┐┌─────┐                   │  │
│  │  │CPU 1││CPU 2││CPU 3││CPU 4│ ← 슬레이브        │  │
│  │  └─────┘└─────┘└─────┘└─────┘                   │  │
│  │                                                   │  │
│  │  장점: 단순, 데이터 공유 문제 없음                 │  │
│  │  단점: 마스터 병목                                │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  2. 대칭 멀티프로세싱 (SMP)                            │
│  ┌───────────────────────────────────────────────────┐  │
│  │  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐                 │  │
│  │  │CPU 0│ │CPU 1│ │CPU 2│ │CPU 3│                 │  │
│  │  │스케줄││스케줄││스케줄││스케줄│                 │  │
│  │  └──┬──┘ └──┬──┘ └──┬──┘ └──┬──┘                 │  │
│  │     └───────┴───┬───┴───────┘                     │  │
│  │                 ▼                                 │  │
│  │         ┌──────────────┐                         │  │
│  │         │  공유 Ready   │ (동기화 필요)           │  │
│  │         │    Queue      │                         │  │
│  │         └──────────────┘                         │  │
│  │  또는:  각 CPU가 자체 Ready Queue 유지            │  │
│  │                                                   │  │
│  │  장점: 확장성, 병목 없음                          │  │
│  │  단점: 동기화 복잡, 부하 불균형 가능               │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 부하 분산 (Load Balancing)

```
┌─────────────────────────────────────────────────────────┐
│                    부하 분산 기법                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  문제: 각 CPU가 별도 큐를 가질 때 부하 불균형 발생       │
│                                                         │
│  CPU 0: ████████   CPU 1: ██   CPU 2: ████████████     │
│         (과부하)        (유휴)         (과부하)          │
│                                                         │
│  해결책 1: Push Migration (밀어내기)                    │
│  ┌───────────────────────────────────────────────────┐  │
│  │  주기적으로 각 큐의 부하 검사                       │  │
│  │  과부하 큐 → 유휴 큐로 프로세스 이동                │  │
│  │                                                   │  │
│  │  CPU 0: ████████ ──push──▶ CPU 1: ██              │  │
│  │  결과:  █████               █████                 │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  해결책 2: Pull Migration (끌어오기)                    │
│  ┌───────────────────────────────────────────────────┐  │
│  │  유휴 CPU가 다른 CPU에서 작업을 가져옴             │  │
│  │                                                   │  │
│  │  CPU 0: ████████ ◀──pull── CPU 1: (유휴)         │  │
│  │  결과:  █████               ███                   │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  Linux: 둘 다 사용                                     │
│  • 주기적 Push (rebalance 작업)                        │
│  • 유휴 시 Pull (idle_balance)                         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 3. 프로세서 친화성

### 프로세서 친화성이란?

```
┌─────────────────────────────────────────────────────────┐
│              프로세서 친화성 (Processor Affinity)        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  정의: 프로세스가 특정 CPU에서 계속 실행되도록 하는 것   │
│                                                         │
│  이유: 캐시 효율                                        │
│  ┌───────────────────────────────────────────────────┐  │
│  │  프로세스 P가 CPU 0에서 실행                       │  │
│  │  → CPU 0의 캐시에 P의 데이터 적재                  │  │
│  │                                                   │  │
│  │  P가 다른 CPU로 이동하면:                         │  │
│  │  • CPU 0 캐시: P 데이터 무효화                    │  │
│  │  • CPU 1 캐시: P 데이터 다시 적재 필요            │  │
│  │  → 캐시 미스 증가, 성능 저하                      │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  캐시 상태 시각화:                                      │
│                                                         │
│  CPU 0         CPU 1         CPU 0         CPU 1       │
│  ┌─────┐      ┌─────┐       ┌─────┐       ┌─────┐      │
│  │캐시 │      │캐시 │       │캐시 │       │캐시 │      │
│  │[P의 │      │[   ]│  이동  │[   ]│       │[P의 │      │
│  │데이터│      │     │ ───▶  │     │       │데이터│      │
│  └─────┘      └─────┘       └─────┘       └─────┘      │
│    ↑ 따뜻함    차가움          차가움        ↑ 다시 적재 │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 친화성 유형

```
┌─────────────────────────────────────────────────────────┐
│                   친화성 유형                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 소프트 친화성 (Soft Affinity)                       │
│  ┌───────────────────────────────────────────────────┐  │
│  │  • 기본 동작: 같은 CPU에서 실행하려고 노력         │  │
│  │  • 부하 분산이 필요하면 이동 가능                  │  │
│  │  • Linux 기본 동작                                │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  2. 하드 친화성 (Hard Affinity)                         │
│  ┌───────────────────────────────────────────────────┐  │
│  │  • 프로세스를 특정 CPU 집합에 고정                 │  │
│  │  • 부하 분산에도 이동 안 함                        │  │
│  │  • 시스템 호출로 설정                              │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  Linux에서 설정:                                        │
│  ```c                                                  │
│  #define _GNU_SOURCE                                   │
│  #include <sched.h>                                    │
│                                                         │
│  cpu_set_t mask;                                       │
│  CPU_ZERO(&mask);                                      │
│  CPU_SET(0, &mask);  // CPU 0에만 실행                 │
│  CPU_SET(2, &mask);  // CPU 2에도 실행 가능            │
│                                                         │
│  // 현재 프로세스의 친화성 설정                         │
│  sched_setaffinity(0, sizeof(mask), &mask);            │
│  ```                                                   │
│                                                         │
│  명령어:                                                │
│  ```bash                                               │
│  # CPU 0,1에서만 실행                                  │
│  taskset -c 0,1 ./program                              │
│                                                         │
│  # 실행 중인 프로세스 친화성 변경                       │
│  taskset -c 2,3 -p PID                                 │
│  ```                                                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 4. 실시간 스케줄링

### 실시간 시스템 개요

```
┌─────────────────────────────────────────────────────────┐
│                   실시간 시스템 개요                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  실시간 시스템 = 시간 제약 (Deadline)이 있는 시스템      │
│                                                         │
│  분류:                                                  │
│  ┌───────────────────────────────────────────────────┐  │
│  │ 경성 실시간 (Hard Real-Time)                      │  │
│  │ • 마감시간 위반 = 시스템 실패                      │  │
│  │ • 예: 항공 제어, 의료 기기, ABS 브레이크           │  │
│  │ • 마감시간 보장 필수                               │  │
│  └───────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────┐  │
│  │ 연성 실시간 (Soft Real-Time)                      │  │
│  │ • 마감시간 위반 = 성능 저하                        │  │
│  │ • 예: 비디오 스트리밍, 게임, VoIP                  │  │
│  │ • 대부분의 마감시간 충족 목표                      │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 실시간 태스크 특성

```
┌─────────────────────────────────────────────────────────┐
│                  실시간 태스크 특성                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  주기적 태스크 (Periodic Task):                         │
│                                                         │
│  시간 ────────────────────────────────────────────▶     │
│  │←── 주기(Period) P ──→│←── 주기(Period) P ──→│       │
│  ┌───┐                  ┌───┐                  ┌───┐   │
│  │ C │                  │ C │                  │ C │   │
│  └───┘                  └───┘                  └───┘   │
│  ↑   ↑                  ↑   ↑                          │
│  도착 마감시간(D)        도착 마감시간(D)                 │
│                                                         │
│  파라미터:                                              │
│  • P (Period): 태스크가 반복되는 주기                   │
│  • C (Computation time): 실행 시간                     │
│  • D (Deadline): 완료해야 하는 시간                    │
│  • 이용률 U = C/P                                      │
│                                                         │
│  예시: 비디오 프레임                                    │
│  • P = 33ms (30fps)                                    │
│  • C = 10ms (프레임 처리 시간)                         │
│  • D = 33ms                                            │
│  • U = 10/33 ≈ 0.3 (30%)                              │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Rate Monotonic Scheduling (RMS)

```
┌─────────────────────────────────────────────────────────┐
│           Rate Monotonic Scheduling (RMS)               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  원리: 주기가 짧은 태스크 = 높은 우선순위               │
│       (Rate = 1/Period, 더 높은 Rate = 높은 우선순위)  │
│                                                         │
│  특징:                                                  │
│  • 정적 우선순위 (고정)                                 │
│  • 선점형                                               │
│  • 최적 (정적 우선순위 중)                              │
│                                                         │
│  예제:                                                  │
│  ┌─────────┬───────┬────────┬──────────┐               │
│  │ 태스크   │ 주기 P │ 실행 C │ 우선순위  │               │
│  ├─────────┼───────┼────────┼──────────┤               │
│  │   T1    │  50   │   20   │   높음   │               │
│  │   T2    │  100  │   35   │   낮음   │               │
│  └─────────┴───────┴────────┴──────────┘               │
│                                                         │
│  간트 차트:                                             │
│  ┌──────────┬──────────────┬──────────┬─────────────┐  │
│  │    T1    │      T2      │    T1    │    T2(계속)  │  │
│  └──────────┴──────────────┴──────────┴─────────────┘  │
│  0         20            55        75             100  │
│       T2 시작       T1 재도착(선점)    T2 재개          │
│                                                         │
│  스케줄 가능 조건:                                      │
│  총 이용률 ≤ n(2^(1/n) - 1)                            │
│  • n=1: 100%                                           │
│  • n=2: 약 82.8%                                       │
│  • n→∞: 약 69.3%                                       │
│                                                         │
│  위 예제: U = 20/50 + 35/100 = 0.4 + 0.35 = 0.75      │
│          0.75 < 0.828 → 스케줄 가능                    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Earliest Deadline First (EDF)

```
┌─────────────────────────────────────────────────────────┐
│            Earliest Deadline First (EDF)                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  원리: 마감시간이 가장 가까운 태스크 = 최고 우선순위     │
│                                                         │
│  특징:                                                  │
│  • 동적 우선순위 (마감시간에 따라 변경)                  │
│  • 선점형                                               │
│  • 이론적으로 최적 (이용률 100%까지 가능)               │
│                                                         │
│  예제 (RMS와 동일 데이터):                              │
│  ┌─────────┬───────┬────────┬────────────────┐         │
│  │ 태스크   │ 주기 P │ 실행 C │ 마감시간 D      │         │
│  ├─────────┼───────┼────────┼────────────────┤         │
│  │   T1    │  50   │   20   │ 50, 100, 150...│         │
│  │   T2    │  100  │   35   │ 100, 200...    │         │
│  └─────────┴───────┴────────┴────────────────┘         │
│                                                         │
│  시간 0:                                                │
│  • T1 마감: 50, T2 마감: 100                           │
│  • T1 우선 실행                                        │
│                                                         │
│  시간 50 (T1 두번째 인스턴스):                          │
│  • T1 마감: 100, T2 마감: 100 (같음)                   │
│  • 동률 → 임의 선택 또는 다른 기준                      │
│                                                         │
│  RMS vs EDF:                                           │
│  ┌──────────────┬────────────────┬─────────────────┐   │
│  │     특성      │      RMS      │      EDF       │   │
│  ├──────────────┼────────────────┼─────────────────┤   │
│  │ 우선순위     │ 정적          │ 동적           │   │
│  │ 최대 이용률  │ ~69% (n→∞)    │ 100%           │   │
│  │ 구현 복잡도  │ 낮음          │ 높음           │   │
│  │ 오버헤드     │ 낮음          │ 높음           │   │
│  │ 과부하 시    │ 예측 가능     │ 도미노 효과    │   │
│  └──────────────┴────────────────┴─────────────────┘   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 5. Linux CFS

### CFS 개요

```
┌─────────────────────────────────────────────────────────┐
│         CFS (Completely Fair Scheduler)                 │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Linux 2.6.23부터 기본 스케줄러 (2007년~)               │
│                                                         │
│  핵심 아이디어:                                         │
│  • 모든 프로세스에게 공정하게 CPU 시간 분배              │
│  • 가상 런타임 (virtual runtime)으로 공정성 추적        │
│  • Red-Black 트리로 효율적 관리                        │
│                                                         │
│  가상 런타임 (vruntime):                                │
│  • 프로세스가 CPU를 사용한 가중 시간                    │
│  • 우선순위가 높으면 천천히 증가                        │
│  • 우선순위가 낮으면 빠르게 증가                        │
│                                                         │
│  스케줄링 결정:                                         │
│  • 항상 vruntime이 가장 작은 프로세스 선택              │
│  • = 가장 덜 실행된 프로세스                            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### CFS 동작 방식

```
┌─────────────────────────────────────────────────────────┐
│                    CFS 동작 방식                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Red-Black 트리 (vruntime 기준 정렬):                   │
│                                                         │
│                    ┌───────┐                            │
│                    │ P2:50 │                            │
│                    └───┬───┘                            │
│              ┌─────────┴─────────┐                      │
│          ┌───────┐           ┌───────┐                  │
│          │ P1:30 │           │ P3:80 │                  │
│          └───┬───┘           └───┬───┘                  │
│        ┌─────┴─────┐       ┌─────┴─────┐                │
│    ┌───────┐   ┌───────┐ ┌───────┐  ┌───────┐          │
│    │ P4:10 │   │ P5:40 │ │ P6:70 │  │ P7:100│          │
│    └───────┘   └───────┘ └───────┘  └───────┘          │
│    ↑                                                    │
│    가장 왼쪽 = 가장 작은 vruntime = 다음 실행            │
│                                                         │
│  시간이 지나면:                                         │
│  1. P4 실행, vruntime 증가 (10 → 25)                   │
│  2. P4가 더 이상 최소가 아니면 다른 프로세스로 전환      │
│  3. 트리 재구성, 새로운 최소 선택                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### CFS 타임슬라이스 계산

```
┌─────────────────────────────────────────────────────────┐
│                CFS 타임슬라이스 계산                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  CFS는 고정 타임슬라이스 대신 목표 지연 시간 사용        │
│                                                         │
│  목표 지연 (Target Latency): 기본 6ms (조정 가능)       │
│                                                         │
│  계산:                                                  │
│  각 프로세스의 타임슬라이스 = 목표 지연 × (가중치/총가중치)│
│                                                         │
│  예시 (n=3, 같은 우선순위):                             │
│  ┌───────────────────────────────────────────────────┐  │
│  │ 목표 지연 = 6ms                                   │  │
│  │ 각 프로세스 가중치 = 1024 (nice 0)                │  │
│  │ 총 가중치 = 1024 × 3 = 3072                       │  │
│  │                                                   │  │
│  │ 각 타임슬라이스 = 6ms × (1024/3072) = 2ms         │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  예시 (다른 우선순위):                                  │
│  ┌───────────────────────────────────────────────────┐  │
│  │ P1: nice -5 (가중치 3121)                        │  │
│  │ P2: nice 0 (가중치 1024)                         │  │
│  │ P3: nice 5 (가중치 335)                          │  │
│  │ 총 가중치 = 4480                                  │  │
│  │                                                   │  │
│  │ P1 타임슬라이스 = 6ms × (3121/4480) ≈ 4.2ms      │  │
│  │ P2 타임슬라이스 = 6ms × (1024/4480) ≈ 1.4ms      │  │
│  │ P3 타임슬라이스 = 6ms × (335/4480) ≈ 0.4ms       │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  Nice 값과 가중치:                                      │
│  • nice -20 (최고): 가중치 88761                       │
│  • nice 0 (기본): 가중치 1024                          │
│  • nice 19 (최저): 가중치 15                           │
│  • 약 10% 차이 당 nice 1 차이                          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 6. 연습 문제

### 문제 1: MLFQ

3개의 큐를 가진 MLFQ 시스템에서:
- Q0: TQ=4ms
- Q1: TQ=8ms
- Q2: FCFS

프로세스 A(CPU-bound, 30ms 작업)와 프로세스 B(I/O-bound, 3ms CPU + I/O 반복)가 동시에 도착했을 때, 처음 20ms 동안의 실행을 설명하세요.

<details>
<summary>정답 보기</summary>

**초기 상태:**
- Q0: [A, B]
- Q1: []
- Q2: []

**시간 0-3ms:** B 실행 (3ms), I/O 요청 → B는 Q0에 남음
**시간 3-7ms:** A 실행 (4ms), TQ 소진 → A는 Q1로 강등
**시간 7-10ms:** B가 I/O 완료 후 도착, B 실행 (3ms)
**시간 10-18ms:** A 실행 (8ms), TQ 소진 → A는 Q2로 강등
**시간 18-20ms:** B가 돌아왔다면 B 실행...

**결과:**
- B는 짧은 작업으로 높은 큐에서 빠르게 서비스됨
- A는 점점 낮은 큐로 이동하여 긴 타임슬라이스 사용

</details>

### 문제 2: RMS 스케줄 가능성

다음 태스크 집합이 RMS로 스케줄 가능한지 확인하세요.

| 태스크 | 주기 (P) | 실행 시간 (C) |
|-------|---------|--------------|
| T1 | 100 | 20 |
| T2 | 150 | 30 |
| T3 | 350 | 80 |

<details>
<summary>정답 보기</summary>

**총 이용률 계산:**
- U1 = 20/100 = 0.20
- U2 = 30/150 = 0.20
- U3 = 80/350 = 0.23

**총 U = 0.20 + 0.20 + 0.23 = 0.63**

**RMS 스케줄 가능 조건 (n=3):**
- 한계 = 3 × (2^(1/3) - 1) = 3 × 0.26 = 0.78

**결론:**
- 0.63 < 0.78
- **스케줄 가능**

</details>

### 문제 3: 프로세서 친화성

소프트 친화성과 하드 친화성의 차이를 설명하고, 각각이 적합한 상황을 예시와 함께 설명하세요.

<details>
<summary>정답 보기</summary>

**소프트 친화성:**
- 정의: OS가 프로세스를 같은 CPU에서 실행하려고 노력하지만, 부하 분산이 필요하면 이동 가능
- 적합한 상황:
  - 일반적인 응용 프로그램
  - 캐시 효율과 부하 분산 균형이 필요한 경우
  - 예: 웹 서버, 데이터베이스

**하드 친화성:**
- 정의: 프로세스가 특정 CPU 집합에서만 실행되도록 강제
- 적합한 상황:
  - 실시간 시스템 (예측 가능한 성능 필요)
  - NUMA 시스템에서 로컬 메모리 접근 최적화
  - 특정 CPU 코어 전용 할당
  - 예: 게임 서버의 물리 엔진 스레드, 고빈도 트레이딩 시스템

</details>

### 문제 4: EDF vs RMS

다음 태스크 집합에 대해 RMS와 EDF를 비교하세요.

| 태스크 | 주기 | 실행 시간 |
|-------|-----|---------|
| T1 | 4 | 1 |
| T2 | 5 | 2 |
| T3 | 10 | 3 |

<details>
<summary>정답 보기</summary>

**이용률:**
- U = 1/4 + 2/5 + 3/10 = 0.25 + 0.4 + 0.3 = 0.95

**RMS 분석:**
- 한계 = 3 × (2^(1/3) - 1) ≈ 0.78
- 0.95 > 0.78 → RMS로 보장되지 않음
- (실제로는 스케줄 가능할 수도 있지만 보장 안 됨)

**EDF 분석:**
- 한계 = 1.0 (100%)
- 0.95 < 1.0 → EDF로 스케줄 가능!

**결론:**
- 이 태스크 집합은 RMS로는 스케줄 가능성이 보장되지 않지만
- EDF로는 스케줄 가능

</details>

### 문제 5: Linux CFS

nice 값이 0인 프로세스 A와 nice 값이 5인 프로세스 B가 있을 때, A가 B보다 얼마나 더 많은 CPU 시간을 받는지 계산하세요.

<details>
<summary>정답 보기</summary>

**가중치 (근사값):**
- nice 0: 가중치 1024
- nice 5: 가중치 약 335 (nice 1 차이당 약 1.25배)

**CPU 시간 비율:**
- A의 비율 = 1024 / (1024 + 335) = 1024 / 1359 ≈ 0.753 (75.3%)
- B의 비율 = 335 / 1359 ≈ 0.247 (24.7%)

**A는 B보다 약 3배 더 많은 CPU 시간을 받음**

(정확한 비율: 1024/335 ≈ 3.06배)

</details>

---

## 실습 과제

### 실습 1: MLFQ 시뮬레이터

`examples/OS_Theory/06_mlfq_sim.py`를 실행하고 설정을 실험하세요.

**과제:**
1. 세 번째 작업 유형을 추가하세요: 5ms CPU 버스트와 I/O를 번갈아 수행하는 혼합 워크로드. 어떤 큐에서 안정화되는지 관찰하세요
2. 우선순위 부스트(Priority Boost) 간격을 50에서 200으로 변경하세요. CPU 바운드 작업의 기아 현상(Starvation)에 어떤 영향을 미치나요?
3. "게이밍 방지"를 구현하세요: 작업이 양자 만료 직전에 자발적으로 CPU를 해제해도 전체 양자 사용으로 간주하세요

### 실습 2: CFS 가상 런타임

단순화된 CFS(Completely Fair Scheduler) 시뮬레이터를 구현하세요:

**과제:**
1. 가상 런타임(Virtual Runtime)으로 키가 지정된 레드-블랙 트리(`sortedcontainers.SortedList` 사용)가 있는 `CFSScheduler`를 만드세요
2. `vruntime += actual_runtime × (base_weight / process_weight)`를 구현하세요. nice=0의 가중치는 1024입니다
3. nice 값이 (0, 5, -5)인 3개 프로세스를 100ms 동안 실행하고 CPU 시간 비율이 가중치 비율과 일치하는지 확인하세요

### 실습 3: 실시간 스케줄링 검증

Rate-Monotonic Scheduling(RMS)을 구현하고 검증하세요:

**과제:**
1. 태스크 T1(P=50, C=10), T2(P=80, C=20), T3(P=200, C=50)에 대해 활용률을 계산하고 RMS 경계를 확인하세요
2. 처음 400ms의 실행을 시뮬레이션하고 간트 차트를 그리세요
3. T4(P=100, C=30)를 추가하세요. 태스크 집합이 여전히 스케줄 가능한가요? RMS 경계와 시뮬레이션 모두로 검증하세요

---

## 연습 문제

### 연습 1: MLFQ 프로세스 배치

3단계 MLFQ(Multi-Level Feedback Queue)의 구성:
- Q0 (최상위): 타임 퀀텀(time quantum) = 4ms, 새 프로세스는 여기서 시작
- Q1 (중간): 타임 퀀텀 = 8ms
- Q2 (최하위): FCFS (선점 없음)
- 우선순위 부스트(priority boost): 50ms마다 모든 프로세스를 Q0으로 이동

t=0에 세 프로세스가 도착:
- 잡 A: CPU 집약적, 자발적으로 CPU를 반납하지 않음 (선점될 때까지 실행)
- 잡 B: I/O 집약적, 2ms CPU 작업마다 I/O 수행
- 잡 C: t=20ms에 도착, 적당한 CPU 사용 (6ms 버스트)

1. 잡 A의 t=5ms, t=15ms, t=30ms, t=60ms 시점의 큐 레벨을 추적하세요
2. 잡 B의 t=5ms, t=15ms, t=30ms 시점의 큐 레벨을 추적하세요
3. 잡 C가 t=20ms에 도착할 때 어느 큐에서 시작하나요? 이것이 잡 A와 잡 B에 어떤 영향을 미치나요?
4. 우선순위 부스트 없이 잡 A는 결국 어떤 문제를 경험하나요? 부스트는 이를 어떻게 해결하나요?

### 연습 2: 프로세서 선호도(Processor Affinity)와 부하 분산(Load Balancing)

4코어 NUMA 시스템에 두 NUMA 노드(Node 0: 코어 0,1; Node 1: 코어 2,3)가 있습니다. 노드 내 메모리 접근은 10ns, 노드 간 접근은 40ns입니다. 프로세스 A, B, C, D가 배치됨:

| 프로세스 | 현재 코어 | NUMA 노드 | 캐시 상태 |
|----------|----------|----------|-----------|
| A | 0 | 0 | 핫(Hot, 캐시 데이터 많음) |
| B | 1 | 0 | 핫(Hot) |
| C | 2 | 1 | 웜(Warm) |
| D | 3 | 1 | 콜드(Cold) |

코어 0이 유휴 상태가 됩니다. 준비된 프로세스 세 개: X(Node 0 메모리 필요), Y(Node 1 메모리 필요), Z(NUMA 선호도 없음, 캐시 콜드).

1. **하드 어피니티(hard affinity)** 관점에서 스케줄러가 따라야 할 규칙은 무엇인가요?
2. **소프트 어피니티(soft affinity)** 관점에서 코어 0에 {X, Y, Z} 중 어느 것을 선호해야 하며 이유는 무엇인가요?
3. 시스템이 **풀 마이그레이션(pull migration)**으로 부하를 균형잡는다면, 어느 코어가 어느 코어에서 작업을 당겨와야 하며 프로세스 Y를 코어 2에서 코어 0으로 마이그레이션하는 비용은 얼마인가요?
4. 부하를 균형잡지 않는 것이(즉, 한 코어가 다른 코어보다 더 바쁘게 두는 것이) 유익한 경우는 언제인가요?

### 연습 3: 속도 단조 스케줄링(Rate Monotonic Scheduling) 가능성 확인

각 태스크 집합이 속도 단조 스케줄링(RMS)에서 **스케줄 가능한지** 판단하세요. RMS 활용률 경계: U ≤ n(2^(1/n) − 1). 모든 계산을 보여주세요.

**태스크 집합 1:**
- T1: 주기(Period)=20ms, 실행 시간(Execution)=5ms
- T2: 주기=50ms, 실행 시간=10ms
- T3: 주기=100ms, 실행 시간=20ms

**태스크 집합 2:**
- T1: 주기=10ms, 실행 시간=4ms
- T2: 주기=25ms, 실행 시간=8ms
- T3: 주기=50ms, 실행 시간=12ms

각 태스크 집합에 대해:
1. 총 CPU 활용률(utilization)을 계산하세요
2. n개 태스크에 대한 RMS 경계를 계산하세요
3. 태스크 집합이 반드시 스케줄 가능한지, 가능할 수도 있는지, 불가능한지 명시하세요
4. RMS 경계를 초과하는 태스크 집합에 대해 EDF(Earliest Deadline First)로 스케줄 가능한가요? EDF는 과부하 상황을 RMS와 어떻게 다르게 처리하나요?

### 연습 4: CFS 가상 실행 시간(Virtual Runtime)

리눅스 CFS(Completely Fair Scheduler)는 nice 값에 따라 각 프로세스에 가중치를 부여합니다. nice 값이 -10(가중치=9548), 0(가중치=1024), 10(가중치=110)인 세 프로세스가 t=0에서 모두 vruntime=0으로 시작합니다. 스케줄러는 항상 가장 낮은 vruntime의 프로세스를 실행합니다. 스케줄링 주기는 10ms로 가정합니다.

1. 첫 10ms 동안 각 프로세스가 가중치에 따라 받는 이상적인 CPU 시간을 계산하세요
2. 각 프로세스가 이상적인 몫을 받은 후 10ms 실행 시 각 프로세스의 vruntime은 얼마인가요?
3. nice=10 프로세스가 5ms 동안 I/O를 수행하고 돌아올 때, CFS는 이 프로세스가 "따라잡기(catch up)" 위해 대량의 CPU 시간을 받는 것을 어떻게 방지하나요?
4. CFS가 각 프로세스에 고정 타임 슬라이스(fixed time slice)를 주는 대신 가상 실행 시간(virtual runtime)을 사용하는 이유는 무엇인가요?

---

## 다음 단계

- [동기화 기초](./07_Synchronization_Basics.md) - 경쟁 상태와 임계 구역

---

## 참고 자료

- [OSTEP - MLFQ](https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-mlfq.pdf)
- [Linux CFS Documentation](https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html)
- [Real-Time Systems (Jane Liu)](https://www.pearson.com/us/higher-education/program/Liu-Real-Time-Systems/PGM293020.html)


# 합의 알고리즘 (Consensus Algorithms)

**이전**: [분산 시스템 개념](./15_Distributed_Systems_Concepts.md) | **다음**: [실전 설계 예제 1](./17_Design_Example_1.md)

## 학습 목표(Learning Objectives)

**난이도**: ⭐⭐⭐⭐ (고급)

이 레슨을 완료하면 다음을 할 수 있습니다:

1. 합의 문제(consensus problem)와 그 세 가지 정확성 속성(합의(agreement), 유효성(validity), 종료(termination))을 정의할 수 있습니다
2. Basic Paxos의 역할(제안자(proposer), 수락자(acceptor), 학습자(learner))과 두 단계 프로토콜을 설명하고, 경쟁하는 제안들을 어떻게 처리하는지 설명할 수 있습니다
3. Raft의 리더 선출(leader election), 로그 복제(log replication), 안전성 메커니즘을 설명하고, Raft가 Paxos보다 더 이해하기 쉽도록 설계된 이유를 말할 수 있습니다
4. 충돌 결함 허용(crash fault tolerance, CFT)과 비잔틴 결함 허용(Byzantine fault tolerance, BFT)을 구분하고 각각에 필요한 최소 노드 수를 제시할 수 있습니다
5. 실용적인 합의 구현체(ZooKeeper ZAB, etcd Raft, Consul)를 비교하고, 조정(coordination), 설정 관리(configuration), 리더 선출에서의 사용 사례를 설명할 수 있습니다
6. 리더 장애, 분산 투표(split vote), 네트워크 파티션(network partition) 등 합의 프로토콜 실행 시나리오를 추적하며 분석할 수 있습니다

---

합의(Consensus)는 모든 신뢰할 수 있는 분산 시스템의 심장 박동입니다: 데이터베이스 복제 클러스터가 어느 쓰기가 먼저 커밋되었는지 합의하는 방법이고, Kubernetes 컨트롤 플레인이 리더를 선출하는 방법이며, 블록체인이 트랜잭션을 검증하는 방법입니다. 합의를 잘못 구현하면 스플릿 브레인(split-brain) 시나리오, 데이터 손실, 또는 조용한 데이터 오염으로 이어집니다. 이 레슨은 여러분이 매일 사용하는 도구들을 뒷받침하는 알고리즘인 Paxos와 Raft를 명확하게 이해하고, 실제 운영 환경에서 그 보장(guarantees)과 한계(limitations)에 대해 논리적으로 추론할 수 있게 해줍니다.

## 목차

1. [합의 문제 정의](#1-합의-문제-정의)
2. [Paxos 알고리즘](#2-paxos-알고리즘)
3. [Raft 알고리즘](#3-raft-알고리즘)
4. [Byzantine Fault Tolerance](#4-byzantine-fault-tolerance)
5. [실전 활용](#5-실전-활용)
6. [연습 문제](#6-연습-문제)

---

## 1. 합의 문제 정의

### 합의란?

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     합의 문제 (Consensus Problem)                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  목표: N개의 노드가 하나의 값에 동의하기                                │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │   Node 1: "A"                                                   │   │
│  │   Node 2: "B"        ───►    모든 노드: "A" (또는 "B")          │   │
│  │   Node 3: "A"                                                   │   │
│  │   Node 4: "C"                                                   │   │
│  │   Node 5: (장애)                                                │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  사용 사례:                                                             │
│  - 리더 선출: 누가 리더인가?                                            │
│  - 분산 락: 누가 락을 획득했는가?                                       │
│  - 분산 DB: 어떤 트랜잭션 순서로 커밋하는가?                            │
│  - 상태 머신 복제: 어떤 명령을 실행하는가?                              │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 합의의 속성

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     합의 알고리즘의 필수 속성                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1. Safety (안전성) - 잘못된 것이 발생하지 않음                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │  Agreement (합의):                                               │   │
│  │  - 모든 정상 노드는 같은 값에 합의                               │   │
│  │  - 두 노드가 다른 값을 결정하면 안됨                             │   │
│  │                                                                  │   │
│  │  Validity (유효성):                                              │   │
│  │  - 결정된 값은 어떤 노드가 제안한 값이어야 함                    │   │
│  │  - 아무도 제안하지 않은 값은 선택 불가                           │   │
│  │                                                                  │   │
│  │  Integrity (무결성):                                             │   │
│  │  - 각 노드는 최대 한 번만 결정                                   │   │
│  │  - 한번 결정하면 변경 불가                                       │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  2. Liveness (활성) - 좋은 것이 결국 발생함                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │  Termination (종료):                                             │   │
│  │  - 모든 정상 노드는 결국 값을 결정                               │   │
│  │  - 영원히 대기하지 않음                                          │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  FLP Impossibility (1985):                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  비동기 시스템에서 단 하나의 노드 장애도 허용하면서              │   │
│  │  Safety와 Liveness를 동시에 보장하는 것은 불가능하다.            │   │
│  │                                                                  │   │
│  │  실제 시스템의 대응:                                             │   │
│  │  - Liveness를 약간 희생 (타임아웃 후 재시도)                     │   │
│  │  - 동기 가정 추가 (부분 동기)                                    │   │
│  │  - Safety는 항상 보장                                            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

> **FLP의 직관적 이해**: 완전 비동기(fully asynchronous) 네트워크에서는 메시지 전달 시간에 상한이 없습니다. 이는 느린 노드와 장애가 발생한 노드를 구별할 수 없다는 것을 의미합니다 — 메시지가 아직 전송 중인지, 발신자가 실패한 것인지 확신할 수 없습니다. 이 근본적인 모호성 때문에 어떤 알고리즘도 항상 종료됨(liveness)을 보장하면서 동시에 상충하는 값을 결정하지 않음(safety)을 보장할 수 없습니다. 실제 시스템은 *부분 동기(partial synchrony)* — 메시지가 미지의 유한 시간 내에 결국 전달된다는 가정 — 을 도입하여 FLP를 우회하며, 이것이 Paxos와 Raft 같은 알고리즘이 실제로 작동하는 이유입니다.

### 장애 모델

**f** = 시스템이 허용해야 하는 장애 수로 정의합니다.

| 모델 | 설명 | 필요 노드 수 |
|------|------|-------------|
| Crash Failure | 노드가 멈춤, 복구 가능 | 2f + 1 |
| Omission Failure | 메시지 손실 가능 | 2f + 1 |
| Byzantine Failure | 악의적/임의의 행동 | 3f + 1 |

**정족수(quorum) 직관**: `2f + 1`개 노드에서 `f`개가 장애를 일으켜도 나머지 `f + 1`개가 여전히 과반수(strict majority)를 형성하여 진행할 수 있습니다. 비잔틴 장애의 경우 악의적 노드가 상충하는 메시지를 보낼 수 있으므로, 적대자를 이길 수 있는 충분한 정직한 노드가 필요하여 `3f + 1`이 요구됩니다.

---

## 2. Paxos 알고리즘

> **📌 비유 — 다수결 회의록**
>
> 다른 사무실에 있는 다섯 명의 동료가 이메일(전화나 채팅 없이)로 단 하나의 회의 시간에 합의하려 한다고 상상해보세요. 한 사람이 "화요일 오후 3시"를 **제안(propose)**하고 모두에게 일단 수락해달라고 요청합니다. 과반수(5명 중 3명)가 "네, 일단 적어두겠습니다"라고 답하면, 제안자는 **확정(confirm)** 메시지를 보내고 그 시간이 최종 결정됩니다. 만약 두 사람이 동시에 서로 다른 시간을 제안하면, 그룹은 항상 더 높은 순번의 제안을 우선시함으로써 문제를 해결합니다 — 이것이 바로 Paxos와 Raft가 경쟁하는 리더들 사이의 충돌을 해결하는 정확한 메커니즘입니다.

### Paxos 개요

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Paxos 알고리즘                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Leslie Lamport이 1989년에 발명 (1998년 발표)                           │
│  분산 합의의 기초가 되는 알고리즘                                        │
│                                                                         │
│  역할:                                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │  Proposer (제안자)                                               │   │
│  │  - 값을 제안                                                     │   │
│  │  - 클라이언트 요청 처리                                          │   │
│  │                                                                  │   │
│  │  Acceptor (수락자)                                               │   │
│  │  - 제안을 투표                                                   │   │
│  │  - 과반수가 수락하면 결정                                        │   │
│  │  - 상태 저장                                                     │   │
│  │                                                                  │   │
│  │  Learner (학습자)                                                │   │
│  │  - 결정된 값을 학습                                              │   │
│  │  - 읽기 전용 복제본                                              │   │
│  │                                                                  │   │
│  │  (실제로는 한 노드가 여러 역할 수행 가능)                        │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Basic Paxos: 두 단계

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Basic Paxos: Phase 1 - Prepare                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Proposer                   Acceptors (과반수 필요)                     │
│      │                    A1      A2      A3                           │
│      │                    │       │       │                            │
│      │───Prepare(n=1)────►│       │       │                            │
│      │───Prepare(n=1)────────────►│       │                            │
│      │───Prepare(n=1)────────────────────►│                            │
│      │                    │       │       │                            │
│      │                    │       │       │                            │
│      │◄──Promise(n=1)────│       │       │                            │
│      │◄──Promise(n=1)────────────│       │                            │
│      │◄──Promise(n=1)────────────────────│                            │
│      │                    │       │       │                            │
│                                                                         │
│  Prepare(n): "제안 번호 n으로 제안하려 합니다"                          │
│  Promise(n): "n보다 작은 제안은 무시하겠습니다"                         │
│              + 이전에 수락한 값이 있으면 함께 반환                       │
│                                                                         │
│  Acceptor 규칙:                                                         │
│  - 받은 n > 기존 promised_n 이면 Promise                               │
│  - 그렇지 않으면 무시/거부                                              │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│                     Basic Paxos: Phase 2 - Accept                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  과반수 Promise 받은 후:                                                │
│                                                                         │
│  Proposer                   Acceptors                                  │
│      │                    A1      A2      A3                           │
│      │                    │       │       │                            │
│      │──Accept(n=1,v="X")─►│       │       │                            │
│      │──Accept(n=1,v="X")─────────►│       │                            │
│      │──Accept(n=1,v="X")─────────────────►│                            │
│      │                    │       │       │                            │
│      │◄──Accepted(n=1)────│       │       │                            │
│      │◄──Accepted(n=1)────────────│       │                            │
│      │◄──Accepted(n=1)────────────────────│                            │
│      │                    │       │       │                            │
│      ▼                                                                  │
│  과반수 Accepted → 값 "X" 결정!                                        │
│                                                                         │
│  Accept(n, v): "제안 번호 n으로 값 v를 수락해주세요"                    │
│  Accepted(n): "수락했습니다"                                            │
│                                                                         │
│  v 선택 규칙:                                                           │
│  - Promise에서 받은 이전 값이 있으면 그 중 가장 높은 n의 값 사용        │
│  - 없으면 자신이 원하는 값 제안                                         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**단순화된 단일 결의(single-decree) Paxos 의사 코드:**

```python
class PaxosProposer:
    def __init__(self, node_id, acceptors):
        self.node_id = node_id
        self.acceptors = acceptors
        self.proposal_number = 0

    def propose(self, value):
        while True:
            # 고유하고 단조 증가하는 제안 번호 생성
            # 더 높은 번호가 항상 이김 — Paxos가 충돌을 해결하는 방식
            self.proposal_number += 1
            n = self.proposal_number

            # Phase 1 — Prepare: acceptor들에게 n보다 낮은 번호의
            # 제안은 수락하지 않겠다는 약속(promise)을 요청
            promises = []
            for acceptor in self.acceptors:
                resp = acceptor.prepare(n)
                if resp.promised:
                    promises.append(resp)

            # 과반수가 필요 — 두 정족수는 반드시 최소 한 노드가
            # 겹쳐야 하며, 이것이 상충하는 결정을 방지
            if len(promises) < len(self.acceptors) // 2 + 1:
                continue  # 더 높은 n으로 재시도

            # acceptor가 이미 값을 수락했다면, 우리 값 대신 그 값을
            # 반드시 제안해야 함. 이 규칙이 안전성을 보장:
            # 값이 한번 선택되면 모든 미래 제안은 같은 값으로 수렴
            prev = [p for p in promises if p.accepted_value is not None]
            if prev:
                value = max(prev, key=lambda p: p.accepted_n).accepted_value

            # Phase 2 — Accept: acceptor들에게 (n, value)를 수락 요청
            accepted = sum(
                1 for a in self.acceptors if a.accept(n, value)
            )

            if accepted >= len(self.acceptors) // 2 + 1:
                return value  # 합의 달성!
            # 아니면: 더 높은 n의 제안이 선점함; 반복하여 재시도
```

### Paxos 충돌 해결

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Paxos: 동시 제안 처리                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  시나리오: 두 Proposer가 동시에 제안                                    │
│                                                                         │
│  Proposer1     Proposer2          Acceptors                            │
│      │             │            A1      A2      A3                     │
│      │             │             │       │       │                     │
│      │─Prepare(1)─►│             │       │       │                     │
│      │             │─Prepare(2)─►│       │       │                     │
│      │             │             │       │       │                     │
│      │◄─Promise(1)─┼─────────────│       │       │   A1: n=1          │
│      │             │◄─Promise(2)─────────│       │   A2: n=2          │
│      │             │◄─Promise(2)─────────────────│   A3: n=2          │
│      │             │             │       │       │                     │
│      │             │             │       │       │                     │
│      │─Accept(1,X)►│             │       │       │                     │
│      │             │             X NACK! (n=1 < promised n=2)          │
│      │             │             │       │       │                     │
│      │             │─Accept(2,Y)►│       │       │                     │
│      │             │◄─Accepted───────────│       │                     │
│      │             │◄─Accepted───────────────────│                     │
│      │             │             │       │       │                     │
│      │             ▼             │       │       │                     │
│      │         값 "Y" 결정       │       │       │                     │
│      │             │             │       │       │                     │
│      │             │             │       │       │                     │
│  Proposer1은 더 높은 n으로 재시도 필요                                  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Multi-Paxos

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Multi-Paxos                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Basic Paxos의 문제: 매번 Prepare 필요 (2 RTT)                          │
│                                                                         │
│  Multi-Paxos 최적화:                                                    │
│  - 안정적인 리더 선출                                                   │
│  - 리더가 연속적인 값들을 결정                                          │
│  - Prepare 단계 생략 (1 RTT)                                            │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │  Leader           Acceptors                                      │   │
│  │    │           A1      A2      A3                               │   │
│  │    │            │       │       │                               │   │
│  │    │──Prepare(n=1)────►│       │  (최초 1회만)                  │   │
│  │    │◄─Promise(n=1)─────│       │                                │   │
│  │    │            │       │       │                               │   │
│  │    │            │       │       │                               │   │
│  │    │──Accept(1,v1)────►│       │  Log Entry 1                   │   │
│  │    │◄─Accepted─────────│       │                                │   │
│  │    │            │       │       │                               │   │
│  │    │──Accept(1,v2)────►│       │  Log Entry 2                   │   │
│  │    │◄─Accepted─────────│       │                                │   │
│  │    │            │       │       │                               │   │
│  │    │──Accept(1,v3)────►│       │  Log Entry 3                   │   │
│  │    │◄─Accepted─────────│       │                                │   │
│  │    │            │       │       │                               │   │
│  │                                                                  │   │
│  │  리더가 안정적인 동안 Accept만 반복 (1 RTT)                      │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 3. Raft 알고리즘

### Raft 개요

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Raft 알고리즘                                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  "In Search of an Understandable Consensus Algorithm" (2014)           │
│  Diego Ongaro, John Ousterhout                                         │
│                                                                         │
│  설계 목표: 이해하기 쉬운 합의 알고리즘                                 │
│  - Paxos와 동등한 성능/안전성                                           │
│  - 훨씬 이해하기 쉬움                                                   │
│                                                                         │
│  주요 개념 분리:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  1. Leader Election (리더 선출)                                  │   │
│  │  2. Log Replication (로그 복제)                                  │   │
│  │  3. Safety (안전성)                                              │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  노드 상태:                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │           타임아웃           과반수 획득                         │   │
│  │  ┌────────┐   ───────►   ┌────────────┐   ──────►   ┌────────┐  │   │
│  │  │Follower│              │ Candidate  │             │ Leader │  │   │
│  │  └────────┘   ◄───────   └────────────┘   ◄──────   └────────┘  │   │
│  │              더 높은 Term        타임아웃      더 높은 Term      │   │
│  │                                 (재선거)                         │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Term (임기)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Raft: Term (임기)                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Term: 논리적 시간 단위                                                 │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │   Term 1    │   Term 2    │  Term 3  │    Term 4    │           │   │
│  │  ┌───────┐  │  ┌───────┐  │  ┌───┐   │  ┌─────────┐ │           │   │
│  │  │선거   │  │  │선거   │  │  │선거│  │  │선거     │ │           │   │
│  │  │       │  │  │       │  │  │실패│  │  │         │ │           │   │
│  │  │Node 1 │  │  │Node 3 │  │  │    │  │  │ Node 2  │ │           │   │
│  │  │Leader │  │  │Leader │  │  │    │  │  │ Leader  │ │           │   │
│  │  └───────┘  │  └───────┘  │  └───┘   │  └─────────┘ │           │   │
│  │             │             │          │              │           │   │
│  │  ───────────┼─────────────┼──────────┼──────────────┼───►      │   │
│  │                                                       시간       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Term 규칙:                                                             │
│  - 각 Term에는 최대 한 명의 리더                                        │
│  - Term 시작: 새 선거 시작                                              │
│  - 더 높은 Term을 발견하면 즉시 Follower로 전환                         │
│  - 오래된 Term의 메시지는 무시                                          │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Leader Election

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Raft: Leader Election                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Step 1: Election Timeout                                              │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │  Node A (Follower)                                               │   │
│  │  │                                                               │   │
│  │  │─────────────────────────────────────────────►                 │   │
│  │  │           heartbeat 없음 (150-300ms)        │                 │   │
│  │  │                                             ▼                 │   │
│  │  │                                      타임아웃!               │   │
│  │  │                                      → Candidate로 전환      │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Step 2: Request Vote                                                  │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │  Node A (Candidate)              Node B        Node C            │   │
│  │  term: 2                         term: 1       term: 1           │   │
│  │       │                            │             │               │   │
│  │       │── RequestVote(term=2) ────►│             │               │   │
│  │       │── RequestVote(term=2) ──────────────────►│               │   │
│  │       │                            │             │               │   │
│  │       │◄── VoteGranted ────────────│             │               │   │
│  │       │◄── VoteGranted ──────────────────────────│               │   │
│  │       │                            │             │               │   │
│  │       ▼                                                          │   │
│  │  과반수 (2/3) 획득 → Leader 선출!                                │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  투표 규칙:                                                             │
│  - 각 Term에서 최대 1표만 행사                                          │
│  - 요청자의 로그가 자신보다 최신이어야 투표                             │
│  - 투표 후 타이머 리셋                                                  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Log Replication

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Raft: Log Replication                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Leader의 로그:                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Index:  1       2       3       4       5       6              │   │
│  │        ┌─────┬─────┬─────┬─────┬─────┬─────┐                   │   │
│  │  Term: │  1  │  1  │  2  │  2  │  2  │  3  │                   │   │
│  │        ├─────┼─────┼─────┼─────┼─────┼─────┤                   │   │
│  │  Cmd:  │ x=1 │ y=2 │ x=3 │ z=1 │ y=4 │ x=5 │                   │   │
│  │        └─────┴─────┴─────┴─────┴─────┴─────┘                   │   │
│  │                                  ▲                              │   │
│  │                              commitIndex                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  복제 과정:                                                             │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │  Leader              Follower 1        Follower 2               │   │
│  │    │                     │                 │                    │   │
│  │    │  AppendEntries      │                 │                    │   │
│  │    │  (term, prevLogIdx, │                 │                    │   │
│  │    │   prevLogTerm,      │                 │                    │   │
│  │    │   entries[])        │                 │                    │   │
│  │    │────────────────────►│                 │                    │   │
│  │    │────────────────────────────────────►  │                    │   │
│  │    │                     │                 │                    │   │
│  │    │◄── Success ─────────│                 │                    │   │
│  │    │◄── Success ─────────────────────────  │                    │   │
│  │    │                     │                 │                    │   │
│  │    │  과반수 복제 완료                      │                    │   │
│  │    │  → commitIndex 증가                   │                    │   │
│  │    │  → 상태 머신에 적용                   │                    │   │
│  │    │                     │                 │                    │   │
│  │    │  다음 AppendEntries에 commitIndex 포함                     │   │
│  │    │  → Follower도 커밋                    │                    │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Log Consistency

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Raft: Log Consistency                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Log Matching Property:                                                │
│  - 같은 index, 같은 term → 같은 command                                │
│  - 같은 index, 같은 term → 이전 모든 entry도 동일                      │
│                                                                         │
│  불일치 발생 시:                                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │  Leader:   [1,1] [1,2] [2,3] [3,4] [3,5] [3,6]                  │   │
│  │  Follower: [1,1] [1,2] [2,3] [2,4] [2,5]                        │   │
│  │                              ▲                                  │   │
│  │                          불일치 지점                             │   │
│  │                                                                  │   │
│  │  해결: Leader가 Follower 로그를 자신과 일치하도록 덮어씀         │   │
│  │                                                                  │   │
│  │  1. AppendEntries(prevLogIdx=3, prevLogTerm=2) 실패             │   │
│  │  2. nextIndex 감소하며 재시도                                    │   │
│  │  3. 일치점 발견 (index=3)                                       │   │
│  │  4. index 4부터 Leader 로그로 덮어씀                            │   │
│  │                                                                  │   │
│  │  결과:                                                           │   │
│  │  Follower: [1,1] [1,2] [2,3] [3,4] [3,5] [3,6]                  │   │
│  │            (Leader와 동일)                                       │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Raft vs Paxos

| 특성 | Raft | Paxos |
|------|------|-------|
| 이해 용이성 | 높음 | 낮음 |
| 리더 역할 | 명확 (강한 리더) | 유연 |
| 로그 순서 | 연속적 | 구멍 가능 |
| 구현 복잡도 | 낮음 | 높음 |
| 논문 명확성 | 상세 | 추상적 |
| 활용 사례 | etcd, CockroachDB | Chubby, Spanner |

---

## 4. Byzantine Fault Tolerance

### Byzantine Generals Problem

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Byzantine Generals Problem                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  상황: N명의 장군이 공격/후퇴를 결정해야 함                             │
│       일부 장군이 배신자일 수 있음                                       │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │                    ┌──────────┐                                  │   │
│  │                    │ General 1│                                  │   │
│  │                    │ (배신자) │                                  │   │
│  │                    └────┬─────┘                                  │   │
│  │                         │                                        │   │
│  │           "공격"       │       "후퇴"                           │   │
│  │              ▼                    ▼                              │   │
│  │       ┌──────────┐         ┌──────────┐                         │   │
│  │       │ General 2│         │ General 3│                         │   │
│  │       │ (충성)   │         │ (충성)   │                         │   │
│  │       └──────────┘         └──────────┘                         │   │
│  │                                                                  │   │
│  │  Gen 2: "1번이 공격이래" / Gen 3: "1번이 후퇴래"                │   │
│  │  → 충성스러운 장군들도 다른 결정을 내릴 수 있음!                 │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  해결 조건: 3f + 1 장군이 있으면 f명의 배신자 허용                      │
│  예: 4명의 장군 → 1명의 배신자 허용                                     │
│      7명의 장군 → 2명의 배신자 허용                                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### PBFT (Practical Byzantine Fault Tolerance)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     PBFT 알고리즘                                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  3단계 프로토콜: Pre-Prepare → Prepare → Commit                        │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │  Client     Primary     Replica 1    Replica 2    Replica 3     │   │
│  │    │           │            │            │            │         │   │
│  │    │──Request──►│            │            │            │         │   │
│  │    │           │            │            │            │         │   │
│  │    │           │─Pre-Prepare─►│           │            │         │   │
│  │    │           │─Pre-Prepare──────────────►│           │         │   │
│  │    │           │─Pre-Prepare──────────────────────────►│         │   │
│  │    │           │            │            │            │         │   │
│  │    │           │◄──Prepare──│            │            │         │   │
│  │    │           │────Prepare─►│◄─Prepare──│            │         │   │
│  │    │           │            │────Prepare──►◄─Prepare──│         │   │
│  │    │           │            │            │────Prepare─►│         │   │
│  │    │           │            │            │            │         │   │
│  │    │           │◄───Commit──│            │            │         │   │
│  │    │           │────Commit──►│◄──Commit──│            │         │   │
│  │    │           │            │────Commit───►◄──Commit──│         │   │
│  │    │           │            │            │────Commit──►│         │   │
│  │    │           │            │            │            │         │   │
│  │    │◄──Reply───│            │            │            │         │   │
│  │    │◄──Reply───────────────│            │            │         │   │
│  │    │◄──Reply──────────────────────────── │            │         │   │
│  │    │◄──Reply────────────────────────────────────────  │         │   │
│  │    │           │            │            │            │         │   │
│  │                                                                  │   │
│  │  f+1 동일한 Reply 받으면 클라이언트가 결과 수락                  │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  복잡도: O(n²) 메시지                                                   │
│  한계: 확장성 낮음 (보통 ~20 노드)                                       │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### BFT 활용

| 분야 | 예시 |
|------|------|
| 블록체인 | Tendermint, Hyperledger Fabric |
| 항공/우주 | 비행 제어 시스템 |
| 금융 | 고가용성 트레이딩 시스템 |

---

## 5. 실전 활용

### ZooKeeper (ZAB)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     ZooKeeper / ZAB                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ZAB (ZooKeeper Atomic Broadcast):                                     │
│  - Paxos 변형                                                           │
│  - 리더 기반                                                            │
│  - 순서 보장                                                            │
│                                                                         │
│  데이터 모델:                                                           │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │  /                        (루트)                                 │   │
│  │  ├── /config             설정 데이터                             │   │
│  │  │   └── /config/db      {"host": "localhost"}                  │   │
│  │  ├── /locks              분산 락                                 │   │
│  │  │   └── /locks/job1     (ephemeral)                            │   │
│  │  └── /leader             리더 선출                               │   │
│  │      └── /leader/node-1  (ephemeral + sequential)               │   │
│  │                                                                  │   │
│  │  노드 타입:                                                      │   │
│  │  - Persistent: 명시적 삭제 전까지 유지                           │   │
│  │  - Ephemeral: 세션 종료 시 자동 삭제                             │   │
│  │  - Sequential: 자동 증가 번호 부여                               │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  활용:                                                                  │
│  - Kafka: 브로커 조정, 토픽 메타데이터                                  │
│  - HBase: 마스터 선출, 리전 할당                                        │
│  - Hadoop: HA NameNode                                                 │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### etcd (Raft)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     etcd                                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  특징:                                                                  │
│  - Raft 합의 알고리즘                                                   │
│  - 키-값 저장소                                                         │
│  - gRPC API                                                            │
│  - Watch 기능                                                          │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │  Kubernetes Control Plane                                        │   │
│  │                                                                  │   │
│  │  ┌─────────────┐         ┌─────────────────────────┐            │   │
│  │  │ API Server  │────────►│        etcd Cluster     │            │   │
│  │  │             │         │                         │            │   │
│  │  │             │         │  ┌─────┐ ┌─────┐ ┌─────┐│            │   │
│  │  │ - Pods      │         │  │etcd1│ │etcd2│ │etcd3││            │   │
│  │  │ - Services  │         │  │Raft │ │Raft │ │Raft ││            │   │
│  │  │ - ConfigMaps│         │  └─────┘ └─────┘ └─────┘│            │   │
│  │  └─────────────┘         └─────────────────────────┘            │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  사용 예시:                                                             │
│  ```                                                                   │
│  # 키 저장                                                             │
│  etcdctl put /config/db/host "localhost"                              │
│                                                                         │
│  # 키 조회                                                             │
│  etcdctl get /config/db/host                                          │
│                                                                         │
│  # Watch (변경 감지)                                                    │
│  etcdctl watch /config/db/                                            │
│                                                                         │
│  # 리더 확인                                                            │
│  etcdctl endpoint status                                               │
│  ```                                                                   │
│                                                                         │
│  활용:                                                                  │
│  - Kubernetes: 클러스터 상태 저장                                       │
│  - Service Discovery: Consul 대안                                      │
│  - Feature Flags: 동적 설정                                             │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### Consul

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Consul                                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  특징:                                                                  │
│  - Raft 합의 알고리즘                                                   │
│  - 서비스 디스커버리                                                    │
│  - 헬스 체크                                                            │
│  - KV 저장소                                                            │
│  - 다중 데이터센터                                                      │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                                                                  │   │
│  │   DC1 (Primary)                   DC2 (Secondary)                │   │
│  │   ┌─────────────────┐            ┌─────────────────┐            │   │
│  │   │  Consul Servers │◄──WAN────►│  Consul Servers │            │   │
│  │   │  (3 nodes, Raft)│  Gossip    │  (3 nodes, Raft)│            │   │
│  │   └────────┬────────┘            └────────┬────────┘            │   │
│  │            │                              │                      │   │
│  │     ┌──────┴──────┐                ┌──────┴──────┐              │   │
│  │     │             │                │             │              │   │
│  │  ┌──┴──┐       ┌──┴──┐          ┌──┴──┐       ┌──┴──┐          │   │
│  │  │Agent│       │Agent│          │Agent│       │Agent│          │   │
│  │  │Svc A│       │Svc B│          │Svc A│       │Svc C│          │   │
│  │  └─────┘       └─────┘          └─────┘       └─────┘          │   │
│  │                                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  주요 기능:                                                             │
│  - DNS 기반 서비스 디스커버리: service.consul                          │
│  - 분산 락: Consul Sessions                                            │
│  - 리더 선출: consul lock                                              │
│  - 설정 관리: Consul KV + Template                                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 도구 비교

| 특성 | ZooKeeper | etcd | Consul |
|------|-----------|------|--------|
| 합의 알고리즘 | ZAB (Paxos 변형) | Raft | Raft |
| 데이터 모델 | 계층형 (파일시스템) | 플랫 KV | 플랫 KV |
| Watch | O | O | O |
| 서비스 디스커버리 | 수동 구현 | 수동 구현 | 내장 |
| 헬스 체크 | X | X | 내장 |
| 다중 DC | X | X | O |
| 언어 | Java | Go | Go |
| 주요 사용처 | Hadoop, Kafka | Kubernetes | HashiCorp 생태계 |

---

## 6. 연습 문제

### 연습 1: Paxos 시나리오

5개의 Acceptor가 있는 Paxos 시스템에서 다음 시나리오를 분석하세요:
- Proposer 1이 n=1로 "A" 제안
- Proposer 2가 n=2로 "B" 제안
- 네트워크 지연으로 메시지 순서가 뒤섞임
- 최종적으로 어떤 값이 선택되는가?

### 연습 2: Raft 로그 복구

다음 상황에서 Raft의 로그 일관성 복구 과정을 설명하세요:
```
Leader:   [1,1] [2,2] [2,3] [3,4] [3,5]
Follower: [1,1] [2,2] [2,3] [2,4]
```

### 연습 3: 합의 시스템 설계

다음 요구사항의 분산 설정 관리 시스템을 설계하세요:
- 3개 데이터센터에 배포
- 하나의 DC 장애에도 서비스 지속
- 설정 변경은 밀리초 내 전파
- 읽기 성능 최적화

---

**이전**: [분산 시스템 개념](./15_Distributed_Systems_Concepts.md) | **다음**: [실전 설계 예제 1](./17_Design_Example_1.md)

---

## 참고 자료

- "Paxos Made Simple" - Leslie Lamport
- "In Search of an Understandable Consensus Algorithm (Raft)" - Diego Ongaro
- "Practical Byzantine Fault Tolerance" - Castro, Liskov
- etcd Documentation: etcd.io
- ZooKeeper Documentation: zookeeper.apache.org
- Consul Documentation: consul.io
- Raft Visualization: raft.github.io

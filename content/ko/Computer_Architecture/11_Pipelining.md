# 파이프라이닝 (Pipelining)

**이전**: [어셈블리 언어 기초](./10_Assembly_Language_Basics.md) | **다음**: [분기 예측](./12_Branch_Prediction.md)

---

## 학습 목표(Learning Objectives)

이 레슨을 완료하면 다음을 할 수 있습니다:

1. 파이프라이닝이 레이턴시를 줄이지 않고 명령어 처리량(throughput)을 높이는 원리를 설명할 수 있습니다
2. 고전적인 5단계 파이프라인(IF, ID, EX, MEM, WB)을 서술할 수 있습니다
3. 데이터 해저드(data hazard), 제어 해저드(control hazard), 구조적 해저드(structural hazard)를 구별할 수 있습니다
4. 포워딩(forwarding, 바이패싱)을 데이터 해저드 해결책으로 설명할 수 있습니다
5. 분기 예측(branch prediction)을 제어 해저드 완화 기법으로 설명할 수 있습니다
6. 파이프라인 속도 향상을 계산하고 이상적인 N배에 못 미치는 이유를 분석할 수 있습니다

---

파이프라이닝은 프로세서 설계에서 가장 큰 영향을 미치는 기법입니다. 이 기법이 없다면 CPU는 명령어를 하나씩 순차적으로 실행하여 하드웨어 대부분을 낭비하게 됩니다. 현대 프로세서는 수십 단계의 파이프라인을 운용하여 클럭 사이클당 거의 하나의 명령어를 처리하지만, 해저드(데이터 의존성, 분기)가 이 이상적인 처리량을 끊임없이 위협합니다. 파이프라이닝을 이해하면 명령어 순서가 왜 성능에 영향을 미치는지 알 수 있습니다.

## 목차

1. [파이프라이닝 개념](#1-파이프라이닝-개념)
2. [5단계 파이프라인](#2-5단계-파이프라인)
3. [파이프라인 성능](#3-파이프라인-성능)
4. [파이프라인 해저드](#4-파이프라인-해저드)
5. [해저드 해결 기법](#5-해저드-해결-기법)
6. [연습 문제](#6-연습-문제)

---

> 파이프라이닝은 자동차 조립 라인과 같습니다. 한 명의 작업자가 처음부터 끝까지 자동차 한 대를 완성하는 대신(순차 실행), 조립 라인에는 전문화된 공정이 있습니다. 한 공정은 엔진을 장착하고, 다음은 바퀴를 달고, 그 다음은 차체를 도색합니다. 각 공정은 서로 다른 자동차를 동시에 처리합니다. 자동차 한 대를 만드는 시간 자체는 변하지 않지만, 공장은 훨씬 더 자주 완성 차량을 생산합니다. CPU 파이프라이닝도 같은 원리를 적용합니다. 프로세서의 서로 다른 단계들이 동시에 서로 다른 명령어를 처리합니다.

## 1. 파이프라이닝 개념

### 기본 아이디어

```
비파이프라인 (순차 실행):
┌─────┐     ┌─────┐     ┌─────┐
│ I1  │────▶│ I2  │────▶│ I3  │
└─────┘     └─────┘     └─────┘
  5ns         5ns         5ns      총 15ns

파이프라인 (병렬 실행):
시간:  1ns   2ns   3ns   4ns   5ns   6ns   7ns
I1:   [IF]─[ID]─[EX]─[MEM]─[WB]
I2:        [IF]─[ID]─[EX]─[MEM]─[WB]
I3:             [IF]─[ID]─[EX]─[MEM]─[WB]
                                     총 7ns
```

### 세탁기 비유

```
비파이프라인:
세탁1 ──▶ 건조1 ──▶ 세탁2 ──▶ 건조2 ──▶ 세탁3 ──▶ 건조3

파이프라인:
시간:   1    2    3    4    5    6
세탁1   ■
건조1        ■
세탁2        ■
건조2             ■
세탁3             ■
건조3                  ■

3배 빨라짐!
```

---

## 2. 5단계 파이프라인

### MIPS 5단계 파이프라인

```
┌────────────────────────────────────────────────────────────┐
│                    5-Stage Pipeline                         │
├───────┬───────┬───────┬───────┬───────┐                    │
│  IF   │  ID   │  EX   │  MEM  │  WB   │                    │
│(Fetch)│(Decode│(Exec) │(Memory│(Write │                    │
│       │       │       │Access)│ Back) │                    │
└───────┴───────┴───────┴───────┴───────┘                    │
└────────────────────────────────────────────────────────────┘
```

### 각 단계 설명

| 단계 | 이름 | 동작 |
|------|------|------|
| IF | Instruction Fetch | PC가 가리키는 명령어를 메모리에서 가져옴 |
| ID | Instruction Decode | 명령어 해독, 레지스터 읽기 |
| EX | Execute | ALU 연산 수행, 주소 계산 |
| MEM | Memory Access | 메모리 읽기/쓰기 (load/store) |
| WB | Write Back | 연산 결과를 레지스터에 저장 |

### 파이프라인 레지스터

```
┌─────┐   ┌─────────┐   ┌─────────┐   ┌──────────┐   ┌─────────┐
│ IF  │──▶│ IF/ID   │──▶│ ID/EX   │──▶│ EX/MEM   │──▶│ MEM/WB  │
└─────┘   │Register │   │Register │   │Register  │   │Register │
          └─────────┘   └─────────┘   └──────────┘   └─────────┘

파이프라인 레지스터: 각 단계 사이의 데이터를 임시 저장
- 클럭마다 데이터가 다음 단계로 전달
```

### 명령어별 파이프라인 사용

```
명령어 유형별 단계 사용:

R-type (add, sub):
IF ─▶ ID ─▶ EX ─▶ --- ─▶ WB

Load (lw):
IF ─▶ ID ─▶ EX ─▶ MEM ─▶ WB

Store (sw):
IF ─▶ ID ─▶ EX ─▶ MEM ─▶ ---

Branch (beq):
IF ─▶ ID ─▶ EX ─▶ --- ─▶ ---
```

---

## 3. 파이프라인 성능

### 이상적인 속도 향상

```
속도 향상 = 파이프라인 단계 수 (이상적)

5단계 파이프라인 → 최대 5배 속도 향상

실제로는:
- 파이프라인 채우기/비우기 시간
- 해저드로 인한 스톨
- 단계 간 불균형
```

### 처리량 계산

```
처리량 (Throughput) = 명령어 수 / 시간

비파이프라인:
- 1 명령어 / 5 사이클

파이프라인 (이상적):
- 1 명령어 / 1 사이클 (풀 파이프라인 상태)

CPI (Cycles Per Instruction):
- 이상적: CPI = 1
- 실제: CPI = 1 + 스톨 사이클
```

### 예제: 100개 명령어 실행

```
비파이프라인:
시간 = 100 × 5 = 500 사이클

5단계 파이프라인:
시간 = 5 + (100 - 1) = 104 사이클
      ↑첫 명령어   ↑나머지 명령어

속도 향상 = 500 / 104 ≈ 4.8배
```

---

## 4. 파이프라인 해저드

### 해저드 유형

```
┌─────────────────────────────────────────────────────────┐
│                   파이프라인 해저드                       │
├─────────────────┬─────────────────┬─────────────────────┤
│   구조적 해저드  │   데이터 해저드  │    제어 해저드      │
│  (Structural)   │    (Data)       │    (Control)        │
├─────────────────┼─────────────────┼─────────────────────┤
│ 하드웨어 자원   │ 데이터 의존성   │ 분기 명령어로       │
│ 충돌           │ 으로 인한 문제  │ 인한 문제           │
└─────────────────┴─────────────────┴─────────────────────┘
```

### 4.1 구조적 해저드

```
문제: 같은 하드웨어 자원을 동시에 사용하려 함

예: 단일 메모리 사용 시
사이클 4:
- 명령어 1: MEM 단계 (데이터 메모리 접근)
- 명령어 4: IF 단계 (명령어 메모리 접근)

    I1: IF─ID─EX─MEM─WB
    I4:          IF ← 충돌!

해결: 하버드 구조 (명령어/데이터 메모리 분리)
```

### 4.2 데이터 해저드

```
세 가지 유형:

1. RAW (Read After Write) - 가장 흔함
   # RAW 해저드: sub가 add의 WB 단계에서 $s0를 기록하기 전에 읽으려 함
   # 대부분의 명령어가 이전 결과를 소비하므로 가장 빈번한 해저드
   add $s0, $t0, $t1    # $s0에 쓰기
   sub $t2, $s0, $t3    # $s0 읽기 ← 아직 안 써짐!

2. WAR (Write After Read)
   # WAR 해저드: 순차 파이프라인에서는 읽기(ID)가 항상 쓰기(WB)보다 앞서므로 드묾
   # 비순차 실행(Out-of-Order, 13장 참고)에서만 실질적 문제가 됨
   sub $t2, $s0, $t3    # $s0 읽기
   add $s0, $t0, $t1    # $s0에 쓰기

3. WAW (Write After Write)
   # WAW 해저드: 다수의 쓰기가 동시에 진행 중인 파이프라인에서만 가능
   # 단순 5단계 파이프라인에서는 명령어 순서대로 쓰기하므로 WAW 발생 불가
   add $s0, $t0, $t1    # $s0에 쓰기
   sub $s0, $t2, $t3    # $s0에 쓰기
```

### RAW 해저드 예시

```
add $s0, $t0, $t1
sub $t2, $s0, $t3

# 문제의 원인: add는 EX 단계(사이클 3)에서 $s0를 계산하지만, 레지스터 파일에
# 기록하는 것은 WB 단계(사이클 5)임. 한편 sub는 EX 단계(사이클 4)에서 $s0를
# ALU 입력으로 필요 — 레지스터 파일에 값이 존재하기 1사이클 전임.
시간:    1    2    3    4    5    6    7
add:    IF   ID   EX  MEM  [WB] ← $s0 기록
sub:         IF   ID  [EX] ← $s0 필요!
                       ↑
                   문제 발생!

$s0는 사이클 5에 기록되는데,
sub는 사이클 4에 $s0가 필요함
```

### 4.3 제어 해저드

```
# 제어 해저드(Control Hazard)가 존재하는 이유: 분기 결과는 EX(사이클 3)까지
# 알 수 없지만, 파이프라인은 분기가 없다고 가정하고 이미 다음 2개 명령어(add,
# sub)를 페치함. 분기가 실제로 일어나면 이 2개는 잘못된 명령어 — 플러시해야
# 하므로 2사이클 낭비. 이것이 "분기 페널티(Branch Penalty)".
beq $t0, $t1, target    # 분기 여부 결정
add $t2, $t3, $t4       # 실행해야 하나?
sub $t5, $t6, $t7       # 실행해야 하나?

시간:    1    2    3    4    5
beq:    IF   ID  [EX] ← 분기 결정
add:         IF   ID   ← 잘못된 명령어?
sub:              IF   ← 잘못된 명령어?

분기 결정 전에 이미 다음 명령어들이 파이프라인에 진입
```

---

## 5. 해저드 해결 기법

### 5.1 스톨링 (Stalling)

```
버블(NOP) 삽입으로 파이프라인 일시 정지

add $s0, $t0, $t1
sub $t2, $s0, $t3

시간:    1    2    3    4    5    6    7    8    9
add:    IF   ID   EX  MEM  WB
        --- stall ---
        --- stall ---
sub:              IF   ID   EX  MEM  WB

2 사이클 스톨 발생 → 성능 저하
```

### 5.2 포워딩/바이패싱

```
ALU 결과를 바로 다음 명령어에 전달

add $s0, $t0, $t1
sub $t2, $s0, $t3

시간:    1    2    3    4    5    6
add:    IF   ID  [EX] MEM  WB
                  │
                  └─────▶ 포워딩
sub:         IF   ID  [EX] MEM  WB
                       ↑
                    $s0 값 사용

스톨 없이 실행 가능!
```

### 포워딩 경로

```
┌─────────────────────────────────────────────────────────┐
│                    포워딩 유닛                           │
│                                                         │
│   EX/MEM.ALUResult ───────────────┐                     │
│                                   ▼                     │
│   MEM/WB.ALUResult ─────────────▶ MUX ──▶ ALU 입력      │
│                                   ▲                     │
│   ID/EX.RegisterRs ───────────────┘                     │
└─────────────────────────────────────────────────────────┘

포워딩 조건:
1. EX/MEM.RegisterRd == ID/EX.RegisterRs
   # EX/MEM인 이유: 생산 명령어가 EX를 막 완료 — ALU 결과가 EX/MEM 파이프라인
   # 레지스터에 있음. 소비 명령어의 EX 시작 전에 전달하여 1사이클 스톨을 방지.
2. MEM/WB.RegisterRd == ID/EX.RegisterRs
   # MEM/WB인 이유: 생산자가 한 단계 더 진행(MEM 완료). 조건 1에 해당하지 않는
   # 경우(예: 중간에 다른 명령어가 있는 경우), 2사이클 전 결과를 잡아냄 —
   # WB까지 기다리는 것보다 여전히 빠름.
```

### 5.3 Load-Use 해저드

```
포워딩으로도 해결 불가능한 경우:

# 포워딩이 실패하는 이유: lw는 MEM 단계 끝에서 데이터를 생산하지만, add는
# 같은 사이클의 EX 단계 시작에서 데이터가 필요. 값이 아직 존재하지 않으므로
# 1사이클 스톨이 불가피. 이것이 컴파일러가 load와 소비자 사이에 무관한 명령어를
# 배치("로드 지연 슬롯 스케줄링(Load Delay Slot Scheduling)")하려는 이유.
lw  $s0, 0($t0)     # 메모리에서 로드
add $t2, $s0, $t3   # 바로 사용

시간:    1    2    3    4    5    6    7
lw:     IF   ID   EX  [MEM] WB
                       │
                       └───▶ 데이터 사용 가능
add:         IF   ID  stall [EX] MEM  WB
                   ↑
              데이터 필요하지만 아직 없음

1 사이클 스톨 필수 (Load-Use Stall)
```

### 5.4 분기 예측

```
정적 예측:
- 항상 Not Taken: 분기 안 함으로 예측
- 항상 Taken: 분기 함으로 예측
- BTFN: 뒤로 가면 Taken, 앞으로 가면 Not Taken

동적 예측:
- 분기 기록을 기반으로 예측
- 다음 레슨에서 상세히 다룸
```

### 5.5 지연 분기 (Delayed Branch)

```
분기 명령어 다음 슬롯에 항상 실행되는 명령어 배치

# 지연 분기가 작동하는 이유: beq 다음 명령어는 분기 결과와 무관하게 항상 실행됨
# (파이프라인이 분기 결정 전에 이미 페치함). NOP으로 낭비하는 대신, 컴파일러가
# 분기 결과와 관계없이 필요한 유용한 명령어를 배치 — 페널티 사이클을 생산적 작업으로 전환.
beq $t0, $t1, target
add $t2, $t3, $t4    # 지연 슬롯 (항상 실행)
...
target:
sub $t5, $t6, $t7

컴파일러가 분기와 무관한 명령어를 지연 슬롯에 배치
```

---

## 6. 연습 문제

### 기초 문제

1. 5단계 파이프라인의 각 단계 이름과 역할은?

2. 100개 명령어를 5단계 파이프라인에서 실행할 때 필요한 사이클 수는? (해저드 없다고 가정)

3. 다음 중 데이터 해저드의 유형이 아닌 것은?
   - (a) RAW
   - (b) RAR
   - (c) WAR
   - (d) WAW

### 해저드 분석

4. 다음 코드에서 데이터 해저드를 찾으시오:
```assembly
add $s0, $t0, $t1   # $s0 생산
sub $s1, $s0, $t2   # $s0 읽기(add 후 1개 명령어 뒤), $s1 생산
and $s2, $s0, $s1   # $s0 읽기(add 후 2개 뒤), $s1 읽기(sub 후 1개 뒤)
# 힌트: 모든 생산자-소비자 쌍을 확인 — 어떤 읽기가 Write-back 전에 일어나는가?
```

5. 포워딩으로 해결할 수 없는 해저드는?
```assembly
lw  $s0, 0($t0)     # MEM 단계 후 데이터 사용 가능
add $t1, $s0, $t2   # EX 시작 시 $s0 필요 — MEM 완료와 같은 사이클
# 힌트: MEM 출력을 다음 명령어의 EX 입력으로 제때 전달할 수 있는가?
```

### 성능 계산

6. 1000개 명령어 중 30%가 분기이고, 분기 예측 실패율이 20%이며, 실패 시 3 사이클 페널티가 있다면 CPI는?

<details>
<summary>정답</summary>

1. IF(인출), ID(해독), EX(실행), MEM(메모리접근), WB(쓰기)

2. 5 + (100 - 1) = 104 사이클

3. (b) RAR - Read After Read는 해저드가 아님

4.
- add → sub: $s0에 대한 RAW
- add → and: $s0에 대한 RAW
- sub → and: $s1에 대한 RAW

5. Load-Use 해저드. lw의 MEM 단계 이후에야 데이터 사용 가능하므로 1 사이클 스톨 필요

6.
- 분기 명령어 수: 1000 × 0.3 = 300
- 예측 실패: 300 × 0.2 = 60
- 페널티 사이클: 60 × 3 = 180
- CPI = 1 + 180/1000 = 1.18

</details>

---

## 다음 단계

- [12_Branch_Prediction.md](./12_Branch_Prediction.md) - 동적 분기 예측 기법

---

## 참고 자료

- Computer Organization and Design, Chapter 4 (Patterson & Hennessy)
- [Pipeline Visualization](https://www.youtube.com/watch?v=eVRdfl4zxfI)
- [MIPS Pipeline Simulator](http://www.cs.umd.edu/~meesh/411/mips-pipe/)


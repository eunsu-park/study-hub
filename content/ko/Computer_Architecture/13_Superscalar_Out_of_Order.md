# 슈퍼스칼라와 비순차 실행

**이전**: [분기 예측](./12_Branch_Prediction.md) | **다음**: [메모리 계층 구조](./14_Memory_Hierarchy.md)

**난이도**: ⭐⭐⭐⭐

**선수 지식**: 파이프라이닝, 분기 예측, CPU 구조 기초

---

## 학습 목표(Learning Objectives)

이 레슨을 마치면 다음을 할 수 있습니다:

1. 슈퍼스칼라 실행(superscalar execution)의 개념과 사이클당 여러 명령어를 발행하는 방식을 설명할 수 있다
2. 비순차 실행(out-of-order execution)의 개념과 성능 향상 이유를 설명할 수 있다
3. 레지스터 리네이밍(register renaming)이 거짓 의존성(WAR, WAW)을 제거하는 방법을 설명할 수 있다
4. 진정한 데이터 의존성(RAW)과 거짓 의존성을 구별할 수 있다
5. Tomasulo 알고리즘을 개념적 수준에서 설명할 수 있다
6. 리오더 버퍼(reorder buffer)가 프로그램 순서를 유지하는 역할을 설명할 수 있다

---

현대 CPU는 여러분이 작성한 순서대로 명령어를 실행하지 않습니다. 비순차·슈퍼스칼라 실행 덕분에 프로세서는 코드에서 순차적으로 보이는 명령어들 중 독립적인 것을 자동으로 찾아 동시에 실행할 수 있습니다. 이것이 단일 CPU 코어가 명시적 병렬화 없이도 높은 성능을 달성하는 방법입니다.

## 목차

1. [명령어 수준 병렬성 (ILP)](#1-명령어-수준-병렬성-ilp)
2. [슈퍼스칼라 프로세서](#2-슈퍼스칼라-프로세서)
3. [비순차 실행의 필요성](#3-비순차-실행의-필요성)
4. [레지스터 리네이밍](#4-레지스터-리네이밍)
5. [Tomasulo 알고리즘](#5-tomasulo-알고리즘)
6. [Reorder Buffer (ROB)](#6-reorder-buffer-rob)
7. [현대 프로세서의 실제 구현](#7-현대-프로세서의-실제-구현)
8. [레지스터 리네이밍 심화](#8-레지스터-리네이밍-심화)
9. [연습 문제](#9-연습-문제)

---

## 1. 명령어 수준 병렬성 (ILP)

### 1.1 ILP의 개념

명령어 수준 병렬성(Instruction-Level Parallelism, ILP)은 프로그램 내에서 동시에 실행 가능한 명령어들의 잠재적 병렬성을 의미합니다.

```
순차 실행 vs 병렬 실행:

순차 실행:
  시간 →
  t1    t2    t3    t4    t5    t6
  ├─────┼─────┼─────┼─────┼─────┼─────┤
  │ I1  │ I2  │ I3  │ I4  │ I5  │ I6  │
  └─────┴─────┴─────┴─────┴─────┴─────┘
  총 6사이클

병렬 실행 (ILP = 2):
  시간 →
  t1    t2    t3
  ├─────┼─────┼─────┤
  │ I1  │ I3  │ I5  │
  │ I2  │ I4  │ I6  │
  └─────┴─────┴─────┘
  총 3사이클
```

### 1.2 데이터 의존성 (Data Dependence)

ILP를 제한하는 가장 중요한 요소는 데이터 의존성입니다.

#### RAW (Read After Write) - 진정한 의존성

```assembly
I1: ADD R1, R2, R3    ; R1 = R2 + R3
I2: SUB R4, R1, R5    ; R4 = R1 - R5  (R1 사용, I1 결과 필요)
```

```
I1 ────────→ I2
   R1 의존성

I2는 I1이 R1에 쓴 후에만 실행 가능
```

#### WAR (Write After Read) - 반의존성

```assembly
I1: ADD R1, R2, R3    ; R2 읽기
I2: SUB R2, R4, R5    ; R2 쓰기 (I1이 R2를 읽은 후에 써야 함)
# 이것이 "거짓(false)" 의존성인 이유: I2의 계산은 I1의 R2 값과 아무 관련이 없음.
# 충돌은 ISA의 레지스터 이름이 제한적이라서 — 컴파일러가 "R2"를 재사용한 것뿐.
# 레지스터 리네이밍(Register Renaming)이 I2에 새 물리 레지스터를 부여하면
# I1과 병렬 실행이 가능해짐.
```

```
I1이 R2를 읽기 전에 I2가 R2를 덮어쓰면 안 됨
→ 레지스터 리네이밍으로 해결 가능
```

#### WAW (Write After Write) - 출력 의존성

```assembly
I1: ADD R1, R2, R3    ; R1 쓰기
I2: SUB R1, R4, R5    ; R1 쓰기 (같은 레지스터에 쓰기)
# 이것이 "거짓(false)" 의존성인 이유: I1과 I2는 완전히 독립적인 결과를 계산함.
# 유일한 제약은 R1의 최종 값이 I2의 결과여야 한다는 것(프로그램 순서상 I2가
# 나중이므로). 리네이밍(Renaming)으로 각각 자신의 물리 레지스터를 받으면 —
# I1은 P10에, I2는 P11에 쓰기 — 동시 실행이 가능해짐.
```

```
I2가 I1보다 먼저 완료되면 최종 R1 값이 틀려짐
→ 레지스터 리네이밍으로 해결 가능
```

### 1.3 의존성 그래프

```
프로그램:
I1: LD   R1, 0(R10)     ; 메모리에서 로드
I2: ADD  R2, R1, R3     ; RAW on R1
I3: LD   R4, 8(R10)     ; 독립적
I4: MUL  R5, R4, R6     ; RAW on R4
I5: ADD  R7, R2, R5     ; RAW on R2, R5
I6: ST   R7, 16(R10)    ; RAW on R7

의존성 그래프:
        I1          I3
         │           │
         ▼           ▼
        I2          I4
         │           │
         └─────┬─────┘
               │
               ▼
              I5
               │
               ▼
              I6

병렬 실행 가능한 그룹:
- 레벨 1: I1, I3 (동시 실행 가능)
- 레벨 2: I2, I4 (동시 실행 가능)
- 레벨 3: I5
- 레벨 4: I6

최소 실행 시간: 4 레벨 (4사이클) vs 순차 실행: 6사이클
ILP = 6/4 = 1.5
```

### 1.4 제어 의존성

```assembly
      BEQ  R1, R2, LABEL    ; 분기 명령어
      ADD  R3, R4, R5       ; 분기 안 취할 때 실행
      ...
LABEL:
      SUB  R6, R7, R8       ; 분기 취할 때 실행
```

```
분기 결과가 나오기 전에는 어떤 명령어를 실행할지 모름
→ 분기 예측으로 해결
```

---

## 2. 슈퍼스칼라 프로세서

### 2.1 슈퍼스칼라의 개념

슈퍼스칼라 프로세서는 매 사이클마다 여러 개의 명령어를 페치, 디코드, 실행할 수 있는 프로세서입니다.

```
스칼라 vs 슈퍼스칼라:

스칼라 파이프라인 (IPC ≤ 1):
┌─────┬─────┬─────┬─────┬─────┐
│ IF  │ ID  │ EX  │ MEM │ WB  │ I1
└─────┴─────┴─────┴─────┴─────┘
      ┌─────┬─────┬─────┬─────┬─────┐
      │ IF  │ ID  │ EX  │ MEM │ WB  │ I2
      └─────┴─────┴─────┴─────┴─────┘

2-way 슈퍼스칼라 (IPC ≤ 2):
┌─────┬─────┬─────┬─────┬─────┐
│ IF  │ ID  │ EX  │ MEM │ WB  │ I1
├─────┼─────┼─────┼─────┼─────┤
│ IF  │ ID  │ EX  │ MEM │ WB  │ I2
└─────┴─────┴─────┴─────┴─────┘
      ┌─────┬─────┬─────┬─────┬─────┐
      │ IF  │ ID  │ EX  │ MEM │ WB  │ I3
      ├─────┼─────┼─────┼─────┼─────┤
      │ IF  │ ID  │ EX  │ MEM │ WB  │ I4
      └─────┴─────┴─────┴─────┴─────┘
```

### 2.2 슈퍼스칼라 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                     4-way 슈퍼스칼라 프로세서                      │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              Instruction Fetch Unit                       │   │
│  │  ┌──────────┐    ┌──────────────────────────────────┐    │   │
│  │  │    PC    │───→│  Instruction Cache (I-Cache)      │    │   │
│  │  └──────────┘    └──────────────────────────────────┘    │   │
│  │                              │                            │   │
│  │                    4개 명령어/사이클                       │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                │                                 │
│                                ▼                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              Instruction Decode Unit                      │   │
│  │  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐         │   │
│  │  │Decoder1│  │Decoder2│  │Decoder3│  │Decoder4│         │   │
│  │  └────────┘  └────────┘  └────────┘  └────────┘         │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                │                                 │
│                                ▼                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    Issue Unit                             │   │
│  │          (의존성 검사 및 실행 유닛 할당)                    │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                │                                 │
│        ┌───────────┬──────────┼──────────┬───────────┐         │
│        ▼           ▼          ▼          ▼           ▼         │
│  ┌──────────┐┌──────────┐┌──────────┐┌──────────┐┌──────────┐  │
│  │  ALU 1   ││  ALU 2   ││  FPU     ││  Load    ││  Store   │  │
│  │          ││          ││          ││  Unit    ││  Unit    │  │
│  └──────────┘└──────────┘└──────────┘└──────────┘└──────────┘  │
│        │           │          │          │           │         │
│        └───────────┴──────────┴──────────┴───────────┘         │
│                                │                                 │
│                                ▼                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              Write-back / Commit                          │   │
│  └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 Issue 정책

#### In-Order Issue

```
명령어가 프로그램 순서대로 실행 유닛에 발행됨

프로그램:
I1: ADD R1, R2, R3
I2: MUL R4, R1, R5    ; I1 의존 (stall)
I3: SUB R6, R7, R8    ; 독립적이지만 I2 뒤에 대기

시간 흐름:
사이클 1: Issue I1
사이클 2: I1 실행 중, I2 대기 (RAW hazard)
사이클 3: Issue I2 (I1 완료 후)
사이클 4: Issue I3

문제: I3는 독립적인데 I2 때문에 지연
```

#### Out-of-Order Issue

```
의존성이 없는 명령어는 순서에 관계없이 발행

프로그램:
I1: ADD R1, R2, R3
I2: MUL R4, R1, R5    ; I1 의존
I3: SUB R6, R7, R8    ; 독립적

시간 흐름:
사이클 1: Issue I1, I3 (동시 발행)
사이클 2: I1 완료, Issue I2
사이클 3: I2 실행

성능 향상: I3가 I2를 기다리지 않음
```

### 2.4 실행 유닛의 다양화

```
현대 프로세서의 실행 유닛 예시:

┌─────────────────────────────────────────────────┐
│           Execution Units (Intel Core)           │
├────────────────┬────────────────────────────────┤
│ Port 0         │ ALU, FP MUL, FP DIV, Branch    │
├────────────────┼────────────────────────────────┤
│ Port 1         │ ALU, FP ADD, LEA               │
├────────────────┼────────────────────────────────┤
│ Port 2         │ Load (Address Gen)             │
├────────────────┼────────────────────────────────┤
│ Port 3         │ Load (Address Gen)             │
├────────────────┼────────────────────────────────┤
│ Port 4         │ Store Data                     │
├────────────────┼────────────────────────────────┤
│ Port 5         │ ALU, Vector Shuffle, Branch    │
├────────────────┼────────────────────────────────┤
│ Port 6         │ ALU, Branch                    │
├────────────────┼────────────────────────────────┤
│ Port 7         │ Store (Address Gen)            │
└────────────────┴────────────────────────────────┘

총: 8개 포트, 사이클당 최대 8개 마이크로 연산 실행 가능
```

---

## 3. 비순차 실행의 필요성

### 3.1 순차 실행의 한계

```
프로그램:
I1: LD   R1, 0(R10)     ; 캐시 미스 - 100 사이클 소요
I2: ADD  R2, R1, R3     ; I1 의존
I3: LD   R4, 8(R10)     ; 독립적 - 캐시 히트 4 사이클
I4: MUL  R5, R4, R6     ; I3 의존
I5: ADD  R7, R8, R9     ; 완전히 독립적

순차 실행 (In-Order):
사이클 1-100: I1 실행 (캐시 미스 대기)
사이클 101:   I2 실행
사이클 102-105: I3 실행
사이클 106:   I4 실행
사이클 107:   I5 실행

총: 107 사이클

비순차 실행 (Out-of-Order):
사이클 1:     I1 시작 (캐시 미스)
사이클 2-5:   I3 실행 (I1과 병렬)
사이클 6:     I4 실행
사이클 7:     I5 실행
...
사이클 100:   I1 완료
사이클 101:   I2 실행

총: 101 사이클

성능 향상: 107/101 = 1.06x (단순 예시)
실제로는 더 큰 차이 발생
```

### 3.2 OoO 실행의 3단계

```
┌─────────────────────────────────────────────────────────────┐
│              Out-of-Order Execution Pipeline                 │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   In-Order       Out-of-Order       In-Order                │
│   Front-end      Execution          Back-end                │
│                                                              │
│  ┌─────────┐    ┌─────────────┐    ┌─────────────┐         │
│  │ Fetch   │    │ Issue/      │    │ Commit/     │         │
│  │ Decode  │───→│ Execute     │───→│ Retire      │         │
│  │ Rename  │    │ (비순차)     │    │ (순차)       │         │
│  └─────────┘    └─────────────┘    └─────────────┘         │
│                                                              │
│  프로그램 순서    데이터 흐름 순서    프로그램 순서            │
│                                                              │
└─────────────────────────────────────────────────────────────┘

1단계: Front-end (In-Order)
- 명령어 페치, 디코드
- 레지스터 리네이밍
- 명령어를 Issue Queue에 삽입

2단계: Execution (Out-of-Order)
- 피연산자가 준비된 명령어부터 실행
- 데이터 의존성에 따라 실행 순서 결정
- 여러 실행 유닛에서 병렬 실행

3단계: Back-end (In-Order)
- 프로그램 순서대로 결과 커밋
- 정확한 예외 처리 보장
- 아키텍처 레지스터 갱신
```

---

## 4. 레지스터 리네이밍

### 4.1 리네이밍의 필요성

```
프로그램:
I1: ADD R1, R2, R3    ; R1 쓰기
I2: MUL R4, R1, R5    ; R1 읽기 (RAW)
I3: ADD R1, R6, R7    ; R1 쓰기 (WAW with I1)
I4: SUB R8, R1, R9    ; R1 읽기 (RAW with I3)

문제:
- I3는 I1, I2와 독립적으로 실행 가능해야 함
- 하지만 R1을 공유하므로 WAW 의존성 발생
- I3가 I1보다 먼저 완료되면 I2가 잘못된 값 읽음
```

### 4.2 리네이밍 동작

```
Architectural Registers: R1-R8 (프로그래머가 보는 레지스터)
Physical Registers: P1-P64 (실제 하드웨어 레지스터)

리네이밍 전:
I1: ADD R1, R2, R3
I2: MUL R4, R1, R5
I3: ADD R1, R6, R7
I4: SUB R8, R1, R9

리네이밍 후:
I1: ADD P10, P2, P3    ; R1 → P10
I2: MUL P11, P10, P5   ; R4 → P11, R1 → P10
I3: ADD P12, P6, P7    ; R1 → P12 (새로운 물리 레지스터!)
I4: SUB P13, P12, P9   ; R8 → P13, R1 → P12

결과:
- I1과 I3의 WAW 의존성 제거 (다른 물리 레지스터 사용)
- I2는 P10 읽음 (I1의 결과)
- I4는 P12 읽음 (I3의 결과)
- I1과 I3는 병렬 실행 가능!
```

### 4.3 Register Alias Table (RAT)

```
┌─────────────────────────────────────────────────────────┐
│              Register Alias Table (RAT)                  │
├─────────────────────────────────────────────────────────┤
│  Architectural Reg  │  Physical Reg  │  Valid           │
├─────────────────────┼────────────────┼──────────────────┤
│        R0           │      P0        │    1             │
│        R1           │      P12       │    0 (pending)   │
│        R2           │      P2        │    1             │
│        R3           │      P3        │    1             │
│        R4           │      P11       │    0 (pending)   │
│        R5           │      P5        │    1             │
│        R6           │      P6        │    1             │
│        R7           │      P7        │    1             │
│        R8           │      P13       │    0 (pending)   │
│        ...          │      ...       │    ...           │
└─────────────────────┴────────────────┴──────────────────┘

Free List: P14, P15, P16, ...  (사용 가능한 물리 레지스터)
```

### 4.4 리네이밍 알고리즘

```
리네이밍 과정 (명령어: ADD Rd, Rs1, Rs2):

1. 소스 레지스터 리네이밍:
   - RAT에서 Rs1, Rs2에 대응하는 물리 레지스터 조회

2. 목적지 레지스터 리네이밍:
   - Free List에서 새로운 물리 레지스터 할당
   - RAT에서 Rd의 매핑을 새 물리 레지스터로 갱신

3. 의존성 정보 기록:
   - 소스 물리 레지스터가 아직 생성 중인지 확인
   - 생산자 명령어에 대한 링크 설정

예시:
명령어: ADD R1, R2, R3

Before:
  RAT[R1] = P5, RAT[R2] = P2, RAT[R3] = P3
  Free List: P10, P11, P12, ...

리네이밍:
  1. Rs1(R2) → P2, Rs2(R3) → P3
  2. Rd(R1) → P10 (새 할당)
  3. RAT[R1] = P10

After:
  RAT[R1] = P10, RAT[R2] = P2, RAT[R3] = P3
  Free List: P11, P12, ...

리네이밍된 명령어: ADD P10, P2, P3
```

---

## 5. Tomasulo 알고리즘

### 5.1 배경

1967년 IBM 360/91의 부동소수점 유닛을 위해 Robert Tomasulo가 개발한 알고리즘입니다. 현대 비순차 실행 프로세서의 기초가 됩니다.

### 5.2 핵심 구성 요소

```
┌─────────────────────────────────────────────────────────────────┐
│                  Tomasulo Architecture                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                   Instruction Queue                       │   │
│  └──────────────────────────────────────────────────────────┘   │
│                              │                                   │
│                              ▼                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                   Issue Logic                             │   │
│  │            (Reservation Station 할당)                     │   │
│  └──────────────────────────────────────────────────────────┘   │
│                              │                                   │
│            ┌─────────────────┴─────────────────┐                │
│            ▼                                   ▼                │
│  ┌──────────────────────┐          ┌──────────────────────┐    │
│  │  Reservation Stations │          │  Reservation Stations│    │
│  │      (Add/Sub)        │          │      (Mul/Div)       │    │
│  ├──────────────────────┤          ├──────────────────────┤    │
│  │ RS1: Op Vj Vk Qj Qk  │          │ RS4: Op Vj Vk Qj Qk  │    │
│  │ RS2: Op Vj Vk Qj Qk  │          │ RS5: Op Vj Vk Qj Qk  │    │
│  │ RS3: Op Vj Vk Qj Qk  │          │ RS6: Op Vj Vk Qj Qk  │    │
│  └──────────┬───────────┘          └──────────┬───────────┘    │
│             │                                  │                │
│             ▼                                  ▼                │
│  ┌──────────────────────┐          ┌──────────────────────┐    │
│  │      FP Adder        │          │     FP Multiplier    │    │
│  │    (2 cycles)        │          │     (10 cycles)      │    │
│  └──────────┬───────────┘          └──────────┬───────────┘    │
│             │                                  │                │
│             └─────────────────┬────────────────┘                │
│                               │                                  │
│                               ▼                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                   Common Data Bus (CDB)                   │   │
│  │               (결과 브로드캐스트)                           │   │
│  └──────────────────────────────────────────────────────────┘   │
│                               │                                  │
│                               ▼                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                   Register File                           │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 Reservation Station 구조

```
┌─────────────────────────────────────────────────────────────┐
│              Reservation Station Entry                       │
├──────┬──────┬──────┬──────┬──────┬──────┬──────┬───────────┤
│ Busy │  Op  │  Vj  │  Vk  │  Qj  │  Qk  │  A   │   Dest    │
├──────┼──────┼──────┼──────┼──────┼──────┼──────┼───────────┤
│  1   │ ADD  │ 3.5  │  -   │  -   │ RS4  │  -   │    F2     │
└──────┴──────┴──────┴──────┴──────┴──────┴──────┴───────────┘

필드 설명:
- Busy: 엔트리 사용 중 여부
- Op: 수행할 연산
- Vj, Vk: 소스 피연산자 값 (이미 사용 가능한 경우)
- Qj, Qk: 값을 생산할 Reservation Station (아직 준비 안 된 경우)
- A: 메모리 주소 (Load/Store용)
- Dest: 결과가 저장될 레지스터
```

### 5.4 동작 과정

```
3단계 처리:

1. Issue (발행)
   - Instruction Queue에서 명령어 가져옴
   - 적절한 Reservation Station 할당
   - 피연산자 값 또는 생산자 RS 태그 기록

2. Execute (실행)
   - 모든 피연산자가 준비되면 실행 시작
   - Qj = 0 AND Qk = 0 일 때 실행 가능
   - 실행 유닛에서 연산 수행

3. Write Result (결과 쓰기)
   - CDB를 통해 결과 브로드캐스트
   - 대기 중인 RS들이 결과 수신
   - Register File 갱신
```

### 5.5 예제: Tomasulo 실행 추적

```
프로그램:
I1: LD   F6, 34(R2)
I2: LD   F2, 45(R3)
I3: MUL  F0, F2, F4
I4: SUB  F8, F6, F2
I5: DIV  F10, F0, F6
I6: ADD  F6, F8, F2

초기 상태:
  F4 = 2.5 (사용 가능)
  Load: 2사이클, Mul: 10사이클, Add/Sub: 2사이클, Div: 40사이클

=== 사이클 1 ===
Issue I1: LD F6, 34(R2)
  Load1: Busy=1, A=34+R2, Dest=F6
  Register[F6]: Qi=Load1

=== 사이클 2 ===
Issue I2: LD F2, 45(R3)
  Load2: Busy=1, A=45+R3, Dest=F2
  Register[F2]: Qi=Load2
Execute I1: 메모리 접근 시작

=== 사이클 3 ===
Issue I3: MUL F0, F2, F4
  Mult1: Busy=1, Op=MUL, Vk=2.5, Qj=Load2, Dest=F0
  Register[F0]: Qi=Mult1
Execute I2: 메모리 접근 시작
Write I1: CDB에 F6 값 브로드캐스트
  Load1: Busy=0
  Register[F6]: Qi=0, Value=M[34+R2]

=== 사이클 4 ===
Issue I4: SUB F8, F6, F2
  Add1: Busy=1, Op=SUB, Vj=M[34+R2], Qk=Load2, Dest=F8
Write I2: CDB에 F2 값 브로드캐스트
  Mult1: Vj=M[45+R3], Qj=0  (값 수신)
  Add1: Vk=M[45+R3], Qk=0   (값 수신)

=== 사이클 5 ===
Issue I5: DIV F10, F0, F6
  Mult2: Busy=1, Op=DIV, Vk=M[34+R2], Qj=Mult1, Dest=F10
Execute I3: MUL 시작 (Vj, Vk 준비됨)
Execute I4: SUB 시작 (Vj, Vk 준비됨)

=== 사이클 6 ===
Issue I6: ADD F6, F8, F2
  Add2: Busy=1, Op=ADD, Vk=M[45+R3], Qj=Add1, Dest=F6
  Register[F6]: Qi=Add2

=== 사이클 7 ===
Write I4: CDB에 F8 값 브로드캐스트
  Add2: Vj=(F6-F2), Qj=0  (값 수신)

=== 사이클 8 ===
Execute I6: ADD 시작

... (계속)

=== 사이클 15 ===
Write I3: MUL 완료 (사이클 5+10)
  Mult2: Vj=(F2*F4), Qj=0  (값 수신)

=== 사이클 16 ===
Execute I5: DIV 시작

=== 사이클 56 ===
Write I5: DIV 완료 (사이클 16+40)
```

---

## 6. Reorder Buffer (ROB)

### 6.1 ROB의 필요성

```
문제: 비순차 실행 시 정확한 예외 처리 불가

예시:
I1: LD   R1, 0(R2)     ; 페이지 폴트 발생 가능
I2: ADD  R3, R4, R5    ; I1보다 먼저 완료

만약 I2가 먼저 완료되고 I1에서 페이지 폴트:
- I2의 결과가 이미 R3에 기록됨
- 예외 처리 후 프로그램 재시작 시 상태 불일치

해결: Reorder Buffer
- 결과를 임시 저장
- 프로그램 순서대로 커밋
- 예외 시 커밋되지 않은 결과 폐기
```

### 6.2 ROB 구조

```
┌─────────────────────────────────────────────────────────────┐
│                    Reorder Buffer                            │
├─────┬─────────┬──────────┬─────────┬────────┬──────────────┤
│Entry│  Busy   │  State   │  Dest   │ Value  │ Instruction  │
├─────┼─────────┼──────────┼─────────┼────────┼──────────────┤
│  1  │    1    │ Commit   │   F6    │  10.5  │ LD F6,34(R2) │
│  2  │    1    │ Commit   │   F2    │   5.0  │ LD F2,45(R3) │
│  3  │    1    │ Execute  │   F0    │   -    │ MUL F0,F2,F4 │
│  4  │    1    │ Write    │   F8    │   5.5  │ SUB F8,F6,F2 │
│  5  │    1    │ Issue    │  F10    │   -    │ DIV F10,F0,F6│
│  6  │    1    │ Issue    │   F6    │   -    │ ADD F6,F8,F2 │
│  7  │    0    │   -      │   -     │   -    │      -       │
│  8  │    0    │   -      │   -     │   -    │      -       │
└─────┴─────────┴──────────┴─────────┴────────┴──────────────┘
      ↑                                                ↑
    Head                                             Tail
  (Commit)                                         (Issue)

State:
- Issue: 발행됨, 실행 대기
- Execute: 실행 중
- Write: 실행 완료, 결과 기록됨
- Commit: 커밋 준비 완료
```

### 6.3 ROB와 Tomasulo 통합

```
┌─────────────────────────────────────────────────────────────────┐
│            Modern Out-of-Order Processor                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                  Instruction Fetch/Decode                   │ │
│  └────────────────────────────────────────────────────────────┘ │
│                              │                                   │
│                              ▼                                   │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                    Register Rename                          │ │
│  │              (RAT + Physical Register File)                 │ │
│  └────────────────────────────────────────────────────────────┘ │
│                              │                                   │
│                              ▼                                   │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │              Reorder Buffer (ROB) Allocation               │ │
│  │                  (Entry 할당, 순서 추적)                     │ │
│  └────────────────────────────────────────────────────────────┘ │
│                              │                                   │
│                              ▼                                   │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │              Issue Queue / Reservation Stations             │ │
│  │                  (의존성 대기, 발행 제어)                     │ │
│  └────────────────────────────────────────────────────────────┘ │
│                              │                                   │
│         ┌────────────────────┼────────────────────┐             │
│         ▼                    ▼                    ▼             │
│  ┌────────────┐      ┌────────────┐      ┌────────────┐        │
│  │ Execution  │      │ Execution  │      │   Memory   │        │
│  │  Unit 1    │      │  Unit 2    │      │   Unit     │        │
│  └─────┬──────┘      └─────┬──────┘      └─────┬──────┘        │
│        │                   │                   │                │
│        └───────────────────┼───────────────────┘                │
│                            │                                    │
│                            ▼                                    │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │              Write Back to ROB                              │ │
│  │              (결과를 ROB에 기록)                              │ │
│  └────────────────────────────────────────────────────────────┘ │
│                            │                                    │
│                            ▼                                    │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │              Commit (In-Order)                              │ │
│  │     (ROB Head부터 순서대로 아키텍처 레지스터 갱신)            │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 6.4 커밋 과정

```
Commit 규칙:
1. ROB Head의 명령어만 커밋 가능
2. 명령어가 완료 상태여야 함
3. 이전 명령어가 모두 커밋되어야 함
4. 예외가 없어야 함

예외 발생 시:
┌──────────────────────────────────────────────────┐
│  I1  │  I2  │  I3  │  I4  │  I5  │  I6  │       │
│ Done │ Done │ Done │ Exc! │ Done │ Done │       │
└──────────────────────────────────────────────────┘
   ↑
 Head

I4에서 예외 발생:
1. I1, I2, I3 커밋 완료
2. I4에서 예외 감지
3. I5, I6 결과 폐기 (아직 커밋 안 됨)
4. I4 주소에서 예외 핸들러로 점프
5. 정확한 예외 상태 유지
```

### 6.5 분기 예측 실패 복구

```
분기 예측 실패 시 복구:

ROB 상태:
┌────────────────────────────────────────────────────┐
│  I1  │  I2  │  BR  │  I4  │  I5  │  I6  │         │
│ Done │ Done │Mis-P│ Done │ Done │ Done │         │
└────────────────────────────────────────────────────┘
   ↑           ↑
 Head        분기

BR에서 분기 예측 실패 확인:
1. I1, I2 커밋
2. BR에서 예측 실패 감지
3. I4, I5, I6 플러시 (투기적 실행 결과)
4. RAT를 BR 시점으로 복원 (체크포인트 또는 ROB 역순회)
5. 올바른 분기 대상으로 페치 재시작

복구 메커니즘:
- 체크포인트: 분기마다 RAT 스냅샷 저장
- 점진적 복구: ROB를 역순회하며 RAT 복원
```

---

## 7. 현대 프로세서의 실제 구현

### 7.1 Intel Core 아키텍처 (Arrow Lake — Lion Cove P-core)

Arrow Lake(2024)는 Intel의 타일 기반 아키텍처를 도입하여 P-core와 E-core를 별도의 컴퓨트 타일로 분리합니다. Lion Cove P-core는 Intel 최초로 8-wide 디코드에 도달하여 Apple의 광폭 설계와의 격차를 좁혔습니다.

```
┌─────────────────────────────────────────────────────────────────┐
│          Intel Arrow Lake — Lion Cove P-core (2024)              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Front-end (In-Order)                                           │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  - 분기 예측: 개선된 TAGE 유사, ~12K BTB                   │ │
│  │  - L1 I-Cache: 64KB, 8-way                                 │ │
│  │  - Decode: 8-wide (Raptor Cove의 6-wide에서 확장)          │ │
│  │  - Micro-op Cache: ~4K micro-ops                           │ │
│  │  - 할당: 8 micro-ops/cycle                                 │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  Out-of-Order Engine                                            │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  - ROB: 576 entries (Raptor Cove의 512에서 확장)           │ │
│  │  - 스케줄러: 192 entries (Raptor Cove 대비 2배)            │ │
│  │  - Physical Registers: 280 정수 + 332 벡터                 │ │
│  │  - Load Buffer: 192 entries                                │ │
│  │  - Store Buffer: 128 entries                               │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  Execution Units (12 Ports)                                     │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  Port 0: ALU, FMA, FP Div                                  │ │
│  │  Port 1: ALU, FMA, AES                                     │ │
│  │  Port 2: ALU, Branch                                       │ │
│  │  Port 3: ALU, Branch                                       │ │
│  │  Port 4: Load AGU                                          │ │
│  │  Port 5: Load AGU                                          │ │
│  │  Port 6: Store AGU                                         │ │
│  │  Port 7: Store AGU                                         │ │
│  │  Port 8: Store Data                                        │ │
│  │  Port 9: Store Data                                        │ │
│  │  Port 10: ALU                                              │ │
│  │  Port 11: ALU                                              │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  Memory Subsystem                                               │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  - L1 D-Cache: 48KB, 12-way, 5 cycles                      │ │
│  │  - L2 Cache: 3MB/core, 12-way, ~17 cycles                  │ │
│  │  - L3 Cache: 최대 36MB 공유, ~45 cycles                     │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  성능 지표                                                       │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  - 이론적 최대: 8 micro-ops 실행/cycle                      │ │
│  │  - 실제 IPC: 워크로드에 따라 ~3-5                           │ │
│  │  - 파이프라인 깊이: ~20 단계                                │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

> **참고**: Skylake(2015)는 4-wide 디코드, 224 엔트리 ROB 기준을 확립한 획기적인 마이크로아키텍처로, Intel이 약 10년간 반복 개선하였습니다. Arrow Lake는 타일 기반 분리와 대폭 확장된 프론트엔드/백엔드 구조로 대대적인 아키텍처 도약을 나타냅니다.

### 7.2 ARM Cortex-A77 아키텍처

```
┌─────────────────────────────────────────────────────────────────┐
│                 ARM Cortex-A77 Microarchitecture                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Front-end                                                      │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  - Fetch: 4 instructions/cycle                             │ │
│  │  - Decode: 4-wide                                          │ │
│  │  - Macro-op Cache: 1.5K entries                            │ │
│  │  - 분기 예측: TAGE 기반                                     │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  Out-of-Order Engine                                            │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  - ROB: 160 entries                                        │ │
│  │  - Dispatch: 6 micro-ops/cycle                             │ │
│  │  - Issue Queue: 120 entries                                │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
│  Execution Units (10 pipelines)                                 │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │  - 2x Branch                                               │ │
│  │  - 3x Integer ALU                                          │ │
│  │  - 2x Integer Multi-Cycle                                  │ │
│  │  - 2x FP/NEON                                              │ │
│  │  - 2x Load + 1x Store                                      │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 7.3 성능 비교

```
┌──────────────────────────────────────────────────────────────────────┐
│       현대 고성능 프로세서 비교 (2025년 기준)                           │
├───────────────┬────────────────┬────────────────┬────────────────────┤
│     특성       │ Intel Arrow    │  AMD Zen 5     │  Apple M4 P-core   │
│               │ Lake(Lion Cove)│  (Nirvana)     │                    │
├───────────────┼────────────────┼────────────────┼────────────────────┤
│  Decode Width │     8-wide     │  8-wide(2×4)   │     10-wide        │
├───────────────┼────────────────┼────────────────┼────────────────────┤
│  ROB Size     │   576 entry    │   448 entry    │    ~650 entry      │
├───────────────┼────────────────┼────────────────┼────────────────────┤
│  Issue Width  │    12 ports    │   12 ports     │    ~16 ports       │
├───────────────┼────────────────┼────────────────┼────────────────────┤
│  L1 I-Cache   │     64KB       │     32KB       │     192KB          │
├───────────────┼────────────────┼────────────────┼────────────────────┤
│  L1 D-Cache   │     48KB       │     48KB       │     128KB          │
├───────────────┼────────────────┼────────────────┼────────────────────┤
│  L2 Cache     │     3MB        │     1MB        │     16MB           │
├───────────────┼────────────────┼────────────────┼────────────────────┤
│ 실제 IPC (avg)│     ~3-5       │     ~3-5       │      ~5-6          │
├───────────────┼────────────────┼────────────────┼────────────────────┤
│  주요 특징     │  타일 기반     │  네이티브      │  통합 메모리        │
│               │  분리 아키텍처  │  AVX-512       │  아키텍처           │
└───────────────┴────────────────┴────────────────┴────────────────────┘
```

### 7.4 ILP의 한계

```
ILP 활용의 제한 요소:

1. 진정한 데이터 의존성 (RAW)
   - 리네이밍으로 해결 불가
   - 실행 시간이 길어지면 의존 체인이 성능 결정

2. 제어 의존성
   - 분기 예측 정확도 한계 (~95-97%)
   - 예측 실패 시 파이프라인 플러시

3. 메모리 의존성
   - Load-Store 의존성 탐지 어려움
   - 메모리 명령어 재정렬 제한

4. 윈도우 크기 제한
   - ROB, Issue Queue 크기 한계
   - 멀리 떨어진 ILP 활용 불가

실제 프로그램의 ILP:

┌────────────────────────────────────────────────────┐
│  프로그램 유형       │  평균 ILP   │  제한 요소      │
├────────────────────────────────────────────────────┤
│  정수 연산 (SPEC INT)│   1.5-2.5  │  의존성 체인    │
│  부동소수점 (SPEC FP)│   2.0-4.0  │  메모리 대역폭  │
│  미디어 처리         │   3.0-6.0  │  SIMD 활용도   │
│  데이터베이스        │   1.0-2.0  │  분기 예측     │
│  웹 브라우저         │   1.5-2.5  │  제어 흐름     │
└────────────────────────────────────────────────────┘
```

---

## 8. 레지스터 리네이밍 심화(Register Renaming: Deep Dive)

4장에서 레지스터 리네이밍의 개념을 소개했지만, 이 섹션에서는 구체적인 시뮬레이션을 통한 상세 워크스루와 하드웨어 메커니즘을 깊이 있게 살펴봅니다.

### 8.1 WAR과 WAW: 거짓 의존성(False Dependency) 문제

거짓 의존성은 ISA가 제한된 수의 아키텍처 레지스터(예: x86-64의 16개, ARM/RISC-V의 32개)를 가지기 때문에 발생합니다. 프로그래머와 컴파일러가 같은 레지스터 이름을 재사용하면서 인위적인 순서 제약이 생깁니다:

```
레지스터 부족이 거짓 의존성을 만드는 예시:

I1: MUL R1, R2, R3      ; R1 = R2 * R3          (R1 생산)
I2: ADD R4, R1, R5      ; R4 = R1 + R5          (RAW: I1의 R1 읽기 ← 진짜 의존성)
I3: SUB R1, R6, R7      ; R1 = R6 - R7          (WAW: I1처럼 R1 쓰기)
                                                  (WAR: I2가 읽는 R1 쓰기)
I4: ADD R8, R1, R9      ; R8 = R1 + R9          (RAW: I3의 R1 읽기 ← 진짜 의존성)
I5: MUL R4, R10, R11    ; R4 = R10 * R11        (WAW: I2처럼 R4 쓰기)

리네이밍 없이:
- I3는 I2가 R1을 읽을 때까지 대기해야 함 (WAR) — 하지만 I3의 계산은 독립적!
- I5는 I2가 완료될 때까지 대기해야 함 (R4에 대한 WAW) — 하지만 I5는 독립적!
- I2→I1과 I4→I3만이 진정한 데이터 의존성

리네이밍 후 I3와 I5가 I1, I2와 병렬 실행 가능.
```

### 8.2 Register Alias Table (RAT) 상세

RAT는 레지스터 리네이밍의 핵심 부기(bookkeeping) 구조체입니다. 각 아키텍처 레지스터를 현재의 물리 레지스터에 매핑합니다:

```
레지스터 리네이밍 하드웨어 구조:

┌─────────────────────────────────────────────────────────────────┐
│                   Register Renaming Hardware                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────┐                                            │
│  │   RAT (매핑)      │  Arch Reg → Physical Reg                  │
│  │   R0 → P0         │  모든 WRITE(목적지)에서 갱신              │
│  │   R1 → P7         │                                           │
│  │   R2 → P2         │  모든 READ(소스)에서 조회                 │
│  │   ...             │                                           │
│  └──────────────────┘                                            │
│                                                                  │
│  ┌──────────────────┐                                            │
│  │  Free List (FIFO) │  할당되지 않은 물리 레지스터 풀            │
│  │  [P14, P15, P16,  │  결과를 쓰는 각 명령어마다 새              │
│  │   P17, P18, ...]  │  물리 레지스터 할당                       │
│  └──────────────────┘                                            │
│                                                                  │
│  ┌──────────────────┐                                            │
│  │  Physical Reg File │  실제 저장 공간 (현대 x86 프로세서에서    │
│  │  P0: 42            │  정수 레지스터 180개 이상)                │
│  │  P1: 17            │                                           │
│  │  P2: 99            │  아키텍처 집합보다 훨씬 큼                │
│  │  ...               │  (x86-64는 아키텍처 레지스터 16개뿐)     │
│  └──────────────────┘                                            │
│                                                                  │
│  물리 레지스터는 이전 매핑이 더 이상 필요 없을 때 해제됨          │
│  (매핑을 덮어쓴 명령어가 커밋된 후)                              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 8.3 상세 리네이밍 추적 (5개 명령어)

5개 명령어의 리네이밍을 단계별로 추적하며, 각 명령어 후의 RAT 상태를 보여줍니다:

```
초기 상태:
  RAT: R1→P1(val=10), R2→P2(val=20), R3→P3(val=30),
       R4→P4(val=40), R5→P5(val=50), R6→P6(val=60)
  Free List: [P20, P21, P22, P23, P24, ...]

─── 명령어 1: ADD R1, R2, R3  (R1 = R2 + R3) ───

  소스 리네이밍:
    R2 → RAT 조회 → P2 (값 20, 준비됨)
    R3 → RAT 조회 → P3 (값 30, 준비됨)
  목적지 리네이밍:
    R1 → Free List에서 P20 할당
    이전 매핑: R1→P1 (나중에 해제를 위해 P1 기록)
    RAT 갱신: R1→P20

  리네이밍 결과: ADD P20, P2, P3
  RAT: R1→P20, R2→P2, R3→P3, R4→P4, R5→P5, R6→P6
  Free List: [P21, P22, P23, P24, ...]

─── 명령어 2: MUL R4, R1, R5  (R4 = R1 * R5) ───

  소스 리네이밍:
    R1 → RAT 조회 → P20 (아직 준비 안 됨 — I1이 끝나지 않음)
    R5 → RAT 조회 → P5 (값 50, 준비됨)
  목적지 리네이밍:
    R4 → P21 할당
    이전 매핑: R4→P4
    RAT 갱신: R4→P21

  리네이밍 결과: MUL P21, P20, P5     ← P20을 기다림
  RAT: R1→P20, R2→P2, R3→P3, R4→P21, R5→P5, R6→P6
  Free List: [P22, P23, P24, ...]

─── 명령어 3: SUB R1, R6, R2  (R1 = R6 - R2) ───

  소스 리네이밍:
    R6 → RAT 조회 → P6 (값 60, 준비됨)
    R2 → RAT 조회 → P2 (값 20, 준비됨)
  목적지 리네이밍:
    R1 → P22 할당 (새로운 물리 레지스터!)
    이전 매핑: R1→P20
    RAT 갱신: R1→P22

  리네이밍 결과: SUB P22, P6, P2
  RAT: R1→P22, R2→P2, R3→P3, R4→P21, R5→P5, R6→P6

  핵심 통찰: I3는 P22에 쓰지, P20에 쓰지 않습니다.
  → I2는 여전히 P20(I1의 결과)을 읽음 — WAR 제거!
  → I1은 P20에, I3는 P22에 쓰기 — WAW 제거!
  → I3는 I1과 병렬 실행 가능!

─── 명령어 4: ADD R5, R1, R4  (R5 = R1 + R4) ───

  소스 리네이밍:
    R1 → RAT 조회 → P22 (I3의 결과, 아직 준비 안 됨)
    R4 → RAT 조회 → P21 (I2의 결과, 아직 준비 안 됨)
  목적지 리네이밍:
    R5 → P23 할당
    RAT 갱신: R5→P23

  리네이밍 결과: ADD P23, P22, P21    ← P22와 P21 둘 다 대기
  RAT: R1→P22, R2→P2, R3→P3, R4→P21, R5→P23, R6→P6

─── 명령어 5: MUL R2, R1, R3  (R2 = R1 * R3) ───

  소스 리네이밍:
    R1 → P22, R3 → P3
  목적지 리네이밍:
    R2 → P24 할당
    RAT 갱신: R2→P24

  리네이밍 결과: MUL P24, P22, P3

최종 RAT: R1→P22, R2→P24, R3→P3, R4→P21, R5→P23, R6→P6
Free List: [P25, P26, ...]

리네이밍된 프로그램 요약:
  I1: ADD P20, P2, P3
  I2: MUL P21, P20, P5     (I1에 대한 진짜 의존성, P20 경유)
  I3: SUB P22, P6, P2      (I1, I2와 독립적!)
  I4: ADD P23, P22, P21    (I2, I3에 대한 진짜 의존성)
  I5: MUL P24, P22, P3     (I3에만 의존)

노출된 병렬성:
  사이클 1: I1, I3 병렬 실행 (의존성 없음)
  사이클 2: I5 시작 가능 (I3에만 의존)
  사이클 2+: I1 완료 후 I2 시작
  이후:     I2와 I3 모두 완료 후 I4 시작
```

### 8.4 Tomasulo 알고리즘과의 연결

레지스터 리네이밍과 Tomasulo 알고리즘은 같은 문제(거짓 의존성 제거)를 다른 방식으로 해결합니다:

```
Tomasulo (1967):                    현대 리네이밍 (1990년 이후):
  - RS 태그로 리네이밍                - 명시적 RAT + 물리 레지스터
  - 태그 = Reservation Station ID     - 태그 = 물리 레지스터 번호
  - 암시적 리네이밍                   - 파이프라인에 명시적 리네이밍 단계
  - CDB를 통해 결과 브로드캐스트       - 물리 레지스터 파일에 결과 기록

현대 프로세서는 두 가지를 모두 결합:
  1. RAT가 명시적 리네이밍 수행 (프론트엔드)
  2. Issue Queue (RS에서 발전)가 의존성 추적
  3. Physical Register File이 값 저장
  4. 바이패스 네트워크(CDB에서 발전)로 결과 전달
```

### 8.5 물리 레지스터 해제(Physical Register Freeing)

핵심 질문: 물리 레지스터는 언제 Free List로 반환될 수 있을까요?

```
규칙: 물리 레지스터 Pold는 다음 조건에서 해제 가능:
  1. 매핑을 덮어쓴 명령어 (Pold → Pnew)가 커밋(COMMIT)됨
  2. AND 더 오래된 인플라이트(in-flight) 명령어 중 Pold를 필요로 하는 것이 없음

실제:
  I1: ADD R1, R2, R3  → R1이 P20에 매핑됨 (이전 매핑 P1)
      I1이 커밋될 때 P1 해제 가능
      (I1 이전에 P1을 사용한 모든 명령어도 이미 커밋되었으므로)

이것이 ROB + 리네이밍이 함께 작동하는 이유:
  - ROB가 프로그램 순서와 커밋 지점 추적
  - 커밋 시: 덮어쓴 매핑의 이전 물리 레지스터 해제
  - 플러시 시 (예측 실패): 이전 매핑 복원, 새 레지스터 해제
```

### 8.6 Python 시뮬레이션: 레지스터 리네이밍

```python
"""
Register Renaming Simulator
RAT가 거짓 의존성을 제거하는 과정을 보여줍니다.
"""
from collections import deque

class RegisterRenamer:
    def __init__(self, num_arch_regs=8, num_phys_regs=32):
        self.num_arch = num_arch_regs
        self.num_phys = num_phys_regs

        # RAT: 아키텍처 레지스터 이름 -> 물리 레지스터 번호
        # 초기에 Ri -> Pi (항등 매핑)
        self.rat = {f"R{i}": f"P{i}" for i in range(num_arch_regs)}

        # Free list: 할당 가능한 물리 레지스터
        self.free_list = deque(f"P{i}" for i in range(num_arch_regs, num_phys_regs))

        # 커밋 시 해제를 위한 이전 매핑 추적
        self.old_mappings = []  # (instruction_id, old_phys_reg)

    def rename_instruction(self, inst_id, op, rd, rs1, rs2=None):
        """명령어 하나를 리네이밍합니다. 리네이밍된 명령어를 반환합니다."""
        # 1단계: 소스 레지스터 리네이밍 (현재 매핑 조회)
        phys_rs1 = self.rat[rs1]
        phys_rs2 = self.rat[rs2] if rs2 else None

        # 2단계: 목적지를 위한 새 물리 레지스터 할당
        if not self.free_list:
            raise RuntimeError("Out of physical registers! Pipeline stall.")
        old_phys = self.rat[rd]
        new_phys = self.free_list.popleft()

        # 3단계: RAT 갱신
        self.rat[rd] = new_phys
        self.old_mappings.append((inst_id, old_phys))

        # 리네이밍된 명령어 문자열 생성
        if phys_rs2:
            renamed = f"{op} {new_phys}, {phys_rs1}, {phys_rs2}"
        else:
            renamed = f"{op} {new_phys}, {phys_rs1}"

        return {
            "id": inst_id,
            "original": f"{op} {rd}, {rs1}" + (f", {rs2}" if rs2 else ""),
            "renamed": renamed,
            "dest_old": old_phys,
            "dest_new": new_phys,
        }

    def print_rat(self):
        """현재 RAT 상태를 출력합니다."""
        entries = [f"{arch}->{phys}" for arch, phys in sorted(self.rat.items())]
        print(f"  RAT: {', '.join(entries)}")
        print(f"  Free: [{', '.join(list(self.free_list)[:6])}{'...' if len(self.free_list) > 6 else ''}]")


def main():
    renamer = RegisterRenamer(num_arch_regs=8, num_phys_regs=20)

    # WAR과 WAW 해저드가 있는 프로그램
    instructions = [
        # (op, dest, src1, src2)
        ("ADD", "R1", "R2", "R3"),   # I1: R1 = R2 + R3
        ("MUL", "R4", "R1", "R5"),   # I2: R4 = R1 * R5  (R1에 대한 RAW)
        ("SUB", "R1", "R6", "R7"),   # I3: R1 = R6 - R7  (WAW I1, WAR I2)
        ("ADD", "R5", "R1", "R4"),   # I4: R5 = R1 + R4  (R1, R4에 대한 RAW)
        ("MUL", "R2", "R1", "R3"),   # I5: R2 = R1 * R3
    ]

    print("=" * 60)
    print("Register Renaming Simulation")
    print("=" * 60)
    print("\nInitial state:")
    renamer.print_rat()

    results = []
    for i, (op, rd, rs1, rs2) in enumerate(instructions):
        inst_id = f"I{i+1}"
        print(f"\n--- {inst_id}: {op} {rd}, {rs1}, {rs2} ---")
        result = renamer.rename_instruction(inst_id, op, rd, rs1, rs2)
        results.append(result)
        print(f"  Renamed: {result['renamed']}")
        print(f"  ({rd}: {result['dest_old']} -> {result['dest_new']})")
        renamer.print_rat()

    # 리네이밍 후 의존성 분석
    print("\n" + "=" * 60)
    print("Dependency Analysis After Renaming")
    print("=" * 60)

    print("\nRenamed program:")
    for r in results:
        print(f"  {r['id']}: {r['renamed']}")

    print("\nTrue dependencies only (RAW):")
    print("  I2 depends on I1 (reads P8, produced by I1)")
    print("  I4 depends on I3 (reads P10) and I2 (reads P9)")
    print("  I5 depends on I3 (reads P10)")
    print("\nFalse dependencies eliminated:")
    print("  I1 vs I3: WAW on R1 -> now P8 vs P10 (independent!)")
    print("  I2 vs I3: WAR on R1 -> I2 reads P8, I3 writes P10 (independent!)")
    print("\nParallel execution possible: I1 || I3, then I2 || I5")


if __name__ == "__main__":
    main()
```

---

## 9. 연습 문제

### 기초 문제

1. 다음 데이터 의존성의 유형을 분류하시오:
   ```assembly
   I1: ADD R1, R2, R3
   I2: SUB R4, R1, R5
   I3: MUL R1, R6, R7
   I4: DIV R8, R1, R9
   ```

2. 3-way 슈퍼스칼라 프로세서에서 이론적 최대 IPC는 얼마인가?

3. 레지스터 리네이밍이 해결할 수 있는 의존성 유형은?
   - (a) RAW
   - (b) WAR
   - (c) WAW
   - (d) Control

### 중급 문제

4. 다음 프로그램에 레지스터 리네이밍을 적용하시오:
   ```assembly
   I1: ADD R1, R2, R3
   I2: MUL R4, R1, R5
   I3: ADD R1, R6, R7
   I4: SUB R8, R1, R4
   ```
   (물리 레지스터 P10부터 사용)

5. ROB가 필요한 이유 3가지를 설명하시오.

6. Tomasulo 알고리즘에서 CDB(Common Data Bus)의 역할은?

### 심화 문제

7. 다음 상황에서 Tomasulo 알고리즘의 Reservation Station 상태를 추적하시오:
   ```assembly
   I1: LD   F2, 0(R1)     ; 3 사이클
   I2: MUL  F4, F2, F0    ; 5 사이클
   I3: ADD  F6, F4, F2    ; 2 사이클
   ```
   (초기: F0 = 2.0, RS 3개 (Load1, Mult1, Add1), 사이클 1~10 추적)

8. 분기 예측 실패 시 ROB를 사용한 복구 과정을 설명하시오.

9. Intel Arrow Lake의 Lion Cove P-core는 576 ROB 엔트리를 가지고 있습니다(Skylake의 224에서 증가). ROB를 더 크거나 작게 만들면 어떤 영향이 있으며, 더 큰 ROB를 향한 추세의 이유는 무엇일까요?

<details>
<summary>정답</summary>

1. 의존성 분류:
   - I1→I2: RAW (R1)
   - I1→I3: WAW (R1)
   - I2→I3: WAR (R1 - I2가 읽고 I3가 씀)
   - I3→I4: RAW (R1)

2. 3-way 슈퍼스칼라의 이론적 최대 IPC = 3

3. (b) WAR, (c) WAW
   - RAW는 진정한 의존성이므로 해결 불가
   - Control은 분기 예측으로 해결

4. 레지스터 리네이밍:
   ```assembly
   I1: ADD P10, P2, P3    ; R1 → P10
   I2: MUL P11, P10, P5   ; R4 → P11
   I3: ADD P12, P6, P7    ; R1 → P12 (새 레지스터)
   I4: SUB P13, P12, P11  ; R8 → P13
   ```
   I1과 I3는 이제 병렬 실행 가능

5. ROB 필요 이유:
   - 정확한 예외 처리 (순서대로 커밋)
   - 분기 예측 실패 복구
   - 정확한 인터럽트 처리

6. CDB 역할:
   - 실행 완료된 결과를 모든 RS에 브로드캐스트
   - 대기 중인 명령어들이 피연산자 수신
   - 레지스터 파일 갱신

7. Tomasulo 실행 추적:
   ```
   사이클 1: Issue I1 → Load1
   사이클 2: Execute I1, Issue I2 → Mult1 (Qj=Load1)
   사이클 3: Execute I1 계속, Issue I3 → Add1 (Qj=Mult1, Qk=Load1)
   사이클 4: Write I1, Mult1: Vj 업데이트, Add1: Vk 업데이트
   사이클 5: Execute I2 시작
   ...
   사이클 9: Write I2, Add1: Vj 업데이트
   사이클 10: Execute I3 시작
   사이클 11-12: Execute I3 완료
   ```

8. 분기 예측 실패 복구:
   - ROB에서 분기 이후 명령어들의 결과 무효화
   - RAT를 분기 시점 상태로 복원
   - 올바른 분기 대상으로 페치 재시작
   - 파이프라인 플러시

9. ROB 크기 트레이드오프:
   - 더 크면: 더 많은 ILP 활용 가능, 긴 메모리 지연 허용, 넓은 발행 유닛에 충분한 명령어 공급
   - 더 작으면: 면적/전력 감소, 예측 오류 시 복구 시간 단축
   - 더 큰 ROB 추세: 넓은 디코드(8-wide+)는 실행 유닛을 바쁘게 유지하기 위해 더 많은 비행 중 명령어가 필요하며, DRAM 메모리 지연(~100+ 사이클)은 독립적인 작업을 찾기 위한 큰 윈도우를 필요로 함

</details>

---

## 다음 단계

- [14_Memory_Hierarchy.md](./14_Memory_Hierarchy.md) - 메모리 시스템의 계층 구조와 지역성 원리

---

## 참고 자료

- Computer Architecture: A Quantitative Approach (Hennessy & Patterson)
- [Intel Optimization Manual](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)
- [WikiChip - Microarchitectures](https://en.wikichip.org/wiki/WikiChip)
- [Agner Fog's microarchitecture](https://www.agner.org/optimize/)
- Tomasulo, R.M. "An Efficient Algorithm for Exploiting Multiple Arithmetic Units" (1967)

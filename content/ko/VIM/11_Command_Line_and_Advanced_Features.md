# 명령줄과 고급 기능

**이전**: [버퍼, 창, 탭](./10_Buffers_Windows_and_Tabs.md) | **다음**: [설정과 Vimrc](./12_Configuration_and_Vimrc.md)

---

## 학습 목표

이 레슨을 마치면 다음을 할 수 있습니다:

1. 범위(Range), 카운트(Count), 특수 주소를 활용한 Ex 명령을 사용할 수 있다
2. `:!`와 `:read`로 외부 셸 명령을 통해 텍스트를 필터링할 수 있다
3. 코드 섹션을 접기(Fold) 위해 폴드(Fold)를 열고 닫을 수 있다
4. 프로젝트 작업의 연속성을 위해 편집 세션(Session)을 저장하고 복원할 수 있다
5. 추가 생산성 기능(약어, 자동완성, 맞춤법 검사)을 사용할 수 있다

---

Vim의 명령줄 모드는 `ex` 라인 에디터의 직계 후손입니다. 이 계보 덕분에 Vim은 텍스트에 대한 일괄 작업을 위한 강력한 명령 언어를 갖추고 있습니다 — 일반 모드 편집으로는 번거로울 작업들입니다. 폴드(Fold)와 세션(Session) 같은 기능과 결합하면, 이러한 도구들은 Vim을 대규모 코드베이스 관리에 적합하게 만들어 줍니다.

## 목차

1. [Ex 명령과 범위](#1-ex-명령과-범위)
2. [셸 통합](#2-셸-통합)
3. [폴드](#3-폴드)
4. [세션과 뷰](#4-세션과-뷰)
5. [자동완성](#5-자동완성)
6. [약어](#6-약어)
7. [맞춤법 검사](#7-맞춤법-검사)
8. [기타 팁](#8-기타-팁)
9. [요약](#9-요약)

---

## 1. Ex 명령과 범위

### 범위 문법

모든 Ex 명령은 작업할 줄을 지정하는 범위(Range)를 받을 수 있습니다:

```
:[range]command [arguments]
```

| 범위 | 의미 |
|-------|---------|
| `.` | 현재 줄 |
| `$` | 마지막 줄 |
| `%` | 파일 전체 (`1,$`의 축약) |
| `1,10` | 1번째 줄부터 10번째 줄까지 |
| `.,$` | 현재 줄부터 파일 끝까지 |
| `.,.+5` | 현재 줄과 다음 5줄 |
| `'a,'b` | 마크 a와 b 사이 |
| `'<,'>` | 비주얼 선택 영역 |
| `/pat1/,/pat2/` | 패턴에 매칭되는 줄 사이 |

### 유용한 Ex 명령

| 명령 | 동작 |
|---------|--------|
| `:[range]d` | 줄 삭제 |
| `:[range]y` | 줄 복사(Yank) |
| `:[range]m {address}` | 줄을 주소로 이동 |
| `:[range]co {address}` | 줄을 주소로 복사 |
| `:[range]t {address}` | `:co`와 동일 |
| `:[range]p` | 줄 출력 (화면에 표시) |
| `:[range]w {file}` | 범위를 파일에 쓰기 |

### 줄 주소 지정 예시

```vim
:10d                " 10번 줄 삭제
:10,20d             " 10-20번 줄 삭제
:10m20              " 10번 줄을 20번 줄 아래로 이동
:10,20m$            " 10-20번 줄을 파일 끝으로 이동
:10t20              " 10번 줄을 20번 줄 아래로 복사
:10,20t0            " 10-20번 줄을 파일 처음으로 복사

" 현재 줄을 5줄 아래로 이동:
:m+5

" 현재 줄을 맨 위로 이동:
:m0
```

### 상대 주소 지정

```vim
:+3d                " 커서 아래 3번째 줄 삭제
:-2d                " 커서 위 2번째 줄 삭제
:.,+4d              " 현재 줄과 다음 4줄 삭제

" 패턴과 함께 사용:
:/function/d        " "function"이 포함된 다음 줄 삭제
:/start/,/end/d     " "start"부터 "end"까지 삭제
```

### `:normal` 명령

명령줄에서 노멀 모드(Normal-mode) 명령을 실행합니다:

```vim
:10,20normal A;           " 10-20번 줄 끝에 ';' 추가
:%normal I// ;            " 모든 줄을 //로 주석 처리
:'<,'>normal @a           " 비주얼 선택 영역에서 매크로 'a' 실행
:g/pattern/normal dd      " 노멀 모드로 특정 줄 삭제
```

---

## 2. 셸 통합

### 셸 명령 실행

| 명령 | 동작 |
|---------|--------|
| `:!{cmd}` | 셸 명령 실행 후 출력 표시 |
| `:!!` | 마지막 셸 명령 반복 |
| `:r !{cmd}` | 명령 출력을 버퍼로 읽어오기 |
| `:.!{cmd}` | 현재 줄을 명령으로 필터링 |
| `:[range]!{cmd}` | 범위를 명령으로 필터링 |

### 예시

```vim
:!ls -la                   " 파일 목록 표시
:!python %                 " 현재 파일 실행 (% = 파일명)
:!git status               " git 상태 확인

" 명령 출력 삽입:
:r !date                   " 커서 아래에 현재 날짜 삽입
:r !ls                     " 디렉토리 목록 삽입

" 현재 파일 정보 활용:
:!echo %                   " 현재 파일명 출력
:!python %                 " 현재 Python 파일 실행
:!wc %                     " 현재 파일의 단어 수 세기
```

### 명령을 통한 텍스트 필터링

필터 연산자 `!`는 텍스트를 외부 명령으로 보내고 출력으로 교체합니다:

```vim
" 5-10번 줄 정렬
:5,10!sort

" 파일 전체 정렬
:%!sort

" 비주얼로 선택한 줄 정렬
:'<,'>!sort

" JSON 포맷 정리
:%!python -m json.tool

" 마크다운을 HTML로 변환
:%!pandoc

" 중복 줄 제거
:%!sort -u

" '='을 기준으로 열 정렬
:'<,'>!column -t -s '='
```

### 노멀 모드 필터

노멀 모드에서 `!`는 모션(Motion)을 받는 연산자입니다:

```
!}sort      → 커서부터 다음 빈 줄까지 정렬
!Gsort      → 커서부터 파일 끝까지 정렬
!!sort      → 현재 줄 정렬 (!! = 현재 줄 필터링)
```

---

## 3. 폴드

폴드(Fold)는 텍스트 섹션을 접어서 세부 내용을 숨기고 전체 구조를 볼 수 있게 합니다.

### 폴드 방식

```vim
set foldmethod=manual    " 수동으로 폴드 생성
set foldmethod=indent    " 들여쓰기 기반 폴드
set foldmethod=syntax    " 문법 기반 폴드 (언어 인식)
set foldmethod=marker    " {{{ 와 }}} 마커에서 폴드
set foldmethod=expr      " 커스텀 폴드 표현식
```

### 기본 폴드 명령

| 명령 | 동작 |
|---------|--------|
| `zf{motion}` | 폴드 생성 (수동 방식) |
| `zo` | 커서 아래 폴드 열기 |
| `zc` | 커서 아래 폴드 닫기 |
| `za` | 폴드 토글 (열기 ↔ 닫기) |
| `zR` | 파일의 모든 폴드 열기 |
| `zM` | 파일의 모든 폴드 닫기 |
| `zd` | 커서 아래 폴드 삭제 |
| `zE` | 모든 폴드 삭제 |

### 비주얼 선택으로 폴드 만들기

```
V{줄 선택}zf    → 비주얼 선택으로 폴드 생성
```

### 폴드 레벨

| 명령 | 동작 |
|---------|--------|
| `zm` | 더 많이 접기 (폴드 레벨 1 감소) |
| `zr` | 덜 접기 (폴드 레벨 1 증가) |
| `:set foldlevel=N` | 특정 폴드 레벨 설정 |

### 예시: 들여쓰기 기반 폴딩

```python
class MyClass:           # ── 레벨 0 (접히지 않음)
    def method_one(self):    # ── 레벨 1
        for item in items:       # ── 레벨 2
            process(item)            # ── 레벨 3

    def method_two(self):    # ── 레벨 1
        return result
```

`foldmethod=indent` 설정 시:
- `zM`: 모두 접기
- `zr`: 레벨 1 펼치기 (메서드 시그니처가 있는 클래스 본문)
- `zr` 다시: 레벨 2 펼치기 (메서드 본문)

### 수동 섹션을 위한 마커

```vim
" 코드에서:
" Section 1 {{{
code here...
" }}}

" Section 2 {{{
more code...
" }}}

set foldmethod=marker    " {{{ / }}} 쌍에서 폴드
```

---

## 4. 세션과 뷰

### 세션(Session)

세션은 열린 버퍼, 창 레이아웃, 탭, 커서 위치, 설정 등 모든 것을 저장합니다.

```vim
:mksession              " 세션을 Session.vim에 저장
:mksession! project.vim " 특정 파일에 저장 (! 는 덮어쓰기)
:source Session.vim     " 세션 복원
```

명령줄에서:
```bash
vim -S Session.vim      " 세션으로 Vim 열기
vim -S project.vim      " 특정 세션 열기
```

### 뷰(View)

뷰는 단일 창의 상태(폴드, 커서, 로컬 옵션)를 저장합니다:

```vim
:mkview              " 현재 창의 뷰 저장
:loadview            " 뷰 복원
```

### 자동 세션 저장

```vim
" 자동 세션 관리를 위해 .vimrc에 추가:
autocmd VimLeave * mksession! ~/.vim/sessions/last.vim
```

---

## 5. 자동완성

Vim은 플러그인 없이 내장 자동완성 기능을 제공합니다.

### 삽입 모드 자동완성

| 키 | 완성 유형 |
|-----|----------------|
| `Ctrl-n` | 다음 단어 매칭 (일반) |
| `Ctrl-p` | 이전 단어 매칭 (일반) |
| `Ctrl-x Ctrl-f` | 파일명 자동완성 |
| `Ctrl-x Ctrl-l` | 전체 줄 자동완성 |
| `Ctrl-x Ctrl-k` | 사전 단어 자동완성 |
| `Ctrl-x Ctrl-o` | 옴니 자동완성(Omni completion) (언어 인식) |

### 일반 자동완성

`Ctrl-n`과 `Ctrl-p`는 다음 위치에서 찾은 단어를 기반으로 완성합니다:
- 현재 버퍼
- 열린 다른 버퍼
- 태그(Tag) 파일
- 포함된 파일

```python
# "cal" 입력 후 Ctrl-n:
calculate_total     ← 버퍼에서 매칭
calculate_tax
calendar
```

### 자동완성 메뉴 탐색

| 키 | 동작 |
|-----|--------|
| `Ctrl-n` | 다음 항목 |
| `Ctrl-p` | 이전 항목 |
| `Ctrl-y` | 선택 확인 |
| `Ctrl-e` | 자동완성 취소 |

---

## 6. 약어

약어(Abbreviation)는 삽입 모드에서 입력 시 텍스트를 자동으로 확장합니다.

### 약어 만들기

```vim
:ab teh the              " 'teh'를 'the'로 자동 수정
:ab @@ user@example.com  " '@@'를 이메일로 확장
:ab #b #!/bin/bash       " '#b'를 셔뱅(shebang)으로 확장
```

### 삽입 모드 전용

```vim
:iab rtfm Read The Fine Manual
```

### 약어 제거

```vim
:una teh              " 약어 제거
:abc                  " 모든 약어 삭제
```

---

## 7. 맞춤법 검사

```vim
:set spell             " 맞춤법 검사 활성화
:set spelllang=en_us   " 언어 설정
:set nospell           " 맞춤법 검사 비활성화
```

### 맞춤법 탐색

| 명령 | 동작 |
|---------|--------|
| `]s` | 다음 틀린 단어 |
| `[s` | 이전 틀린 단어 |
| `z=` | 맞춤법 제안 표시 |
| `zg` | 단어를 올바른 것으로 표시 (사전에 추가) |
| `zw` | 단어를 틀린 것으로 표시 |
| `zug` | `zg` 실행 취소 |

---

## 8. 기타 팁

### 명령줄 히스토리

| 키 | 동작 |
|-----|--------|
| `q:` | 명령줄 히스토리 창 열기 |
| `q/` | 검색 히스토리 창 열기 |
| `Ctrl-f` | 히스토리 창으로 전환 (`:` 프롬프트에서) |

### 명령 출력 리디렉션

```vim
:redir @a          " 출력을 레지스터 a로 리디렉션 시작
:ls                " 명령 출력이 레지스터 a에 저장됨
:redir END         " 리디렉션 중지
"ap                " 캡처된 출력 붙여넣기

" 또는 파일로 리디렉션:
:redir > output.txt
:ls
:redir END
```

### 차이(Diff) 모드

```bash
vim -d file1 file2     # 차이 모드로 파일 열기
```

```vim
:diffsplit file2       " 다른 파일과 분할하여 차이 비교
:diffthis              " 현재 창을 차이 비교 대상으로 표시
:diffoff               " 차이 모드 끄기
]c                     " 다음 변경 사항으로 이동
[c                     " 이전 변경 사항으로 이동
do                     " Diff obtain (다른 창에서 변경사항 가져오기)
dp                     " Diff put (다른 창으로 변경사항 보내기)
```

### 암호화

```vim
:X                     " 현재 파일에 암호화 키 설정
:set key=              " 암호화 제거 (빈 키)
```

---

## 9. 요약

| 카테고리 | 주요 명령 |
|----------|-------------|
| Ex 범위 | `.`, `$`, `%`, `1,10`, `/pat1/,/pat2/` |
| 줄 작업 | `:d`, `:m`, `:t`, `:normal` |
| 셸 | `:!cmd`, `:r !cmd`, `:[range]!cmd` |
| 폴드 | `zo`/`zc`/`za`, `zR`/`zM`, `zf` |
| 세션 | `:mksession`, `:source`, `vim -S` |
| 자동완성 | `Ctrl-n`/`Ctrl-p`, `Ctrl-x Ctrl-f/l/o` |
| 약어 | `:ab`, `:iab`, `:una` |
| 맞춤법 | `:set spell`, `]s`/`[s`, `z=`, `zg` |
| 차이 | `vim -d`, `]c`/`[c`, `do`/`dp` |

---

## 연습 문제

### 연습 1: Ex 범위 문법

검색/치환 없이 줄 작업만으로 각 작업을 수행하는 Ex 명령을 작성하세요:

1. 5번 줄부터 12번 줄 삭제
2. 20–25번 줄을 파일 끝으로 이동
3. 10번 줄을 50번 줄 바로 뒤에 복사
4. 현재 줄과 아래 3줄 삭제
5. 마크 `a`와 `b` 사이의 모든 줄을 파일 맨 위(0번 줄)로 이동

<details>
<summary>정답 보기</summary>

1. `:5,12d`
2. `:20,25m$` — `$`는 마지막 줄 주소
3. `:10t50` — `:t`(`:co`와 동일)는 복사; 목적지는 50번 줄 뒤
4. `:.,+3d` — `.`은 현재 줄, `+3`은 3줄 아래
5. `:'a,'bm0` — `'a,'b`는 마크 사이의 범위, `m0`은 1번 줄 앞(맨 위)으로 이동

</details>

### 연습 2: 셸 필터링

파일에 한 줄로 된 읽기 어려운 JSON 블롭이 있고, 또 알파벳 순으로 정렬해야 할 20줄 섹션이 있습니다.

1. Python의 내장 도구로 파일 전체를 보기 좋게 들여쓰기된 JSON으로 포맷하는 명령은?
2. 30–50번 줄만 제자리에서 정렬하는 명령은?
3. 커서 위치에 현재 날짜와 시간을 삽입하려면? 어떤 명령을 사용합니까?
4. `:!sort`와 `:%!sort`의 차이점은?

<details>
<summary>정답 보기</summary>

1. `:%!python -m json.tool` — 파일 전체를 Python의 JSON 포맷터로 파이프하여 버퍼 내용을 보기 좋게 들여쓰기된 형태로 교체합니다.

2. `:30,50!sort` — 30–50번 줄을 시스템 `sort` 명령으로 파이프하고 해당 줄들을 정렬된 출력으로 교체합니다.

3. `:r !date` — `:r` 명령은 출력을 버퍼로 읽어오고; `!date`는 셸 `date` 명령을 실행합니다. 결과가 커서 아래에 삽입됩니다.

4. `:!sort`는 `sort`를 셸 명령으로 실행하고 결과를 임시로 표시합니다(버퍼를 수정하지 않음). `:%!sort`는 버퍼 전체를 `sort`로 파이프하여 버퍼 내용을 정렬된 출력으로 **교체**합니다. `%`가 파일 전체에 대한 필터 작업을 만들어 줍니다.

</details>

### 연습 3: 폴드 활용

Python 파일이 있고 코드 탐색을 위해 폴드 기능을 사용하려 합니다.

1. Python 함수와 클래스를 들여쓰기를 기반으로 자동으로 접어주는 `foldmethod`는?
2. 모든 폴드가 닫힌 상태(`zM` 실행 후)에서, 한 단계만 열어 클래스 본문은 보이지만 메서드 본문은 숨기려면?
3. 비주얼로 선택한 줄 블록에 수동 폴드를 만드는 키 순서는?
4. 코드에 `{{{`와 `}}}`로 폴드 마커를 설정했을 때 활성화해야 하는 `foldmethod` 설정은?

<details>
<summary>정답 보기</summary>

1. `set foldmethod=indent` — 폴드가 들여쓰기 수준으로 결정되어 Python의 들여쓰기 기반 구조와 잘 맞습니다.

2. `zr` — "덜 접기(fold less)"는 폴드 레벨을 1 증가시켜 중첩 한 단계를 더 보여줍니다. `zM`(모두 닫기) 후 `zr`을 한 번 누르면 레벨 1 폴드가 열립니다. `:set foldlevel=1`로도 가능합니다.

3. `V`로 줄 단위 비주얼 선택 후 `zf` — 선택된 줄들에 수동 폴드가 생성됩니다.

4. `set foldmethod=marker` — 이 설정으로 Vim은 `{{{`를 폴드 시작으로, `}}}`를 폴드 끝으로 인식합니다. 코드의 주석에 이 마커를 삽입하면 됩니다.

</details>

### 연습 4: `:normal` 명령

각 명령이 무엇을 하는지 설명하고, 주어진 작업을 수행하는 명령을 작성하세요:

1. `:%normal A;` — 이 명령은 무엇을 합니까?
2. `:'<,'>normal I# ` — 이 명령은 무엇을 합니까?
3. `function`이라는 단어를 포함한 모든 줄 끝에 ` // TODO` 텍스트를 추가하는 명령을 작성하세요.

<details>
<summary>정답 보기</summary>

1. `:%normal A;` — 파일의 모든 줄(`%`)에서 노멀 모드 `A;`(`줄 끝에 ';' 추가`)를 실행합니다. 모든 줄 끝에 세미콜론을 추가합니다 — 세미콜론이 필요한 JavaScript 파일에 유용합니다.

2. `:'<,'>normal I# ` — 비주얼 선택 영역의 모든 줄에서 `I# `(`줄 시작에 '# ' 삽입`)을 실행합니다. 선택된 모든 줄을 `#` 접두사로 주석 처리합니다(Python/셸 스타일).

3. `:g/function/normal A // TODO`
   - `:g/function/` — "function"이 포함된 모든 줄에서 다음 명령 실행
   - `normal A // TODO` — 노멀 모드에서 `A`로 줄 끝 삽입 모드 진입 후 ` // TODO` 입력

</details>

### 연습 5: 약어와 생산성 기능

1. 삽입 모드에서만 `addr`을 `0x00000000`으로 확장하는 약어를 만드세요.
2. `pritn`을 `print`로 자동 수정하는 약어를 작성하세요.
3. 문서 작성 중 오타를 찾으려 합니다. 맞춤법 검사를 활성화하고 첫 번째 오타 단어로 이동하는 명령 순서는?
4. 오타 단어를 발견한 후 수정 제안을 보고 첫 번째 제안을 수락하려면?

<details>
<summary>정답 보기</summary>

1. `:iab addr 0x00000000` — `:iab`는 삽입 모드 전용 약어를 만듭니다. 삽입 모드에서 `addr` 뒤에 공백이나 구두점을 입력하면 확장됩니다.

2. `:ab pritn print` — `:ab`는 일반 약어를 만듭니다(삽입 모드에서 동작). `pritn` 뒤에 단어가 아닌 문자를 입력하면 `print`로 자동 수정됩니다.

3. `:set spell` 후 `]s` — `:set spell`로 맞춤법 검사 활성화(오타 단어가 하이라이트됨), `]s`로 다음 오타 단어로 이동합니다.

4. `z=`를 눌러 제안 목록을 표시합니다. 각 제안에는 번호가 있습니다. 번호를 입력하고 `Enter`를 눌러 수락합니다. 첫 번째 제안을 빠르게 수락하려면: `1z=`.

</details>

---

**이전**: [버퍼, 창, 탭](./10_Buffers_Windows_and_Tabs.md) | **다음**: [설정과 Vimrc](./12_Configuration_and_Vimrc.md)

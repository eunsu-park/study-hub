# 연산자와 조합성(Operators and Composability)

**이전**: [모션과 내비게이션](./04_Motions_and_Navigation.md) | **다음**: [텍스트 객체](./06_Text_Objects.md)

---

## 학습 목표

이 레슨을 완료하면 다음을 할 수 있습니다:

1. Vim의 연산자(operator) + 모션(motion) 문법과 Vim이 "언어"인 이유 설명
2. 연산자(`d`, `c`, `y`, `>`, `<`, `gU`, `gu`)를 모든 모션과 조합
3. 연산자에 카운트(count)를 사용하여 정밀 편집
4. 도트 명령어(`.`)를 마스터하여 변경 사항을 효율적으로 반복
5. 반복 가능성을 중심으로 편집 계획 수립

---

> **비유 — 동사 + 명사 문법**: Vim 명령어는 하나의 언어입니다. 연산자는 **동사**(무엇을 할지)이고 모션은 **명사**(무엇에 적용할지)입니다. 영어에서 "delete" + "word"를 합쳐 "delete a word"라고 말하듯이, Vim에서는 `d` + `w`를 입력하면 정확히 그 작업을 수행합니다: `dw`. 동사 5개와 명사 10개를 익히면 50개의 명령어를 별도로 암기하지 않고도 50가지 작업을 할 수 있습니다.

이것은 이 가이드 전체에서 가장 중요한 레슨입니다. 연산자 + 모션 문법은 Vim을 단순한 키 바인딩의 집합에서 조합 가능한 편집 언어로 변환시킵니다. 이 개념이 이해되는 순간, 편집 속도가 급격히 빨라질 것입니다.

## 목차

1. [Vim의 문법](#1-vim의-문법)
2. [연산자 (동사)](#2-연산자-동사)
3. [연산자와 모션 조합](#3-연산자와-모션-조합)
4. [카운트와 함께 사용하는 연산자](#4-카운트와-함께-사용하는-연산자)
5. [연산자 이중 입력 단축키](#5-연산자-이중-입력-단축키)
6. [도트 명령어](#6-도트-명령어)
7. [연산자 중심으로 사고하기](#7-연산자-중심으로-사고하기)
8. [요약](#8-요약)

---

## 1. Vim의 문법

Vim의 모든 편집 명령어는 다음 공식을 따릅니다:

```
[count] operator [count] motion
```

예시:

| 명령어 | 분해 | 영어 |
|--------|------|------|
| `dw` | `d` + `w` | **d**elete a **w**ord (단어 삭제) |
| `d3w` | `d` + `3w` | delete 3 words (단어 3개 삭제) |
| `3dw` | `3` × (`d` + `w`) | delete a word, 3 times (단어 삭제를 3번) |
| `y$` | `y` + `$` | **y**ank to end of line (줄 끝까지 복사) |
| `c2e` | `c` + `2e` | **c**hange 2 word-ends (단어 끝 2개까지 변경) |
| `>j` | `>` + `j` | indent current + next line (현재 줄 + 다음 줄 들여쓰기) |
| `gUw` | `gU` + `w` | uppercase a word (단어를 대문자로) |

핵심 장점: **새로 배운 모션은 알고 있는 모든 연산자와 함께 동작하고**, 그 반대도 마찬가지입니다. 학습이 덧셈이 아닌 곱셈으로 이루어집니다.

---

## 2. 연산자 (동사)

### 핵심 연산자

| 연산자 | 동작 | 기억법 |
|--------|------|--------|
| `d` | 삭제 (레지스터에 복사됨) | **d**elete |
| `c` | 변경 (삭제 후 입력 모드 진입) | **c**hange |
| `y` | 복사(yank) | **y**ank |
| `>` | 오른쪽 들여쓰기 | |
| `<` | 왼쪽 들여쓰기 | |
| `=` | 자동 들여쓰기 | |
| `gU` | 대문자로 변환 | |
| `gu` | 소문자로 변환 | |
| `g~` | 대소문자 토글 | |
| `gq` | 텍스트 포맷 (textwidth에 맞게 줄 바꿈) | |
| `!` | 외부 명령어로 필터링 | |

### 연산자의 동작 방식

1. 연산자 키를 누름 — Vim이 모션을 기다림
2. 모션을 누름 — Vim이 해당 모션의 범위에 연산자를 적용
3. 결과: 텍스트가 수정되고 일반 모드(Normal mode)로 돌아옴 (`c`의 경우 입력 모드(Insert mode))

---

## 3. 연산자와 모션 조합

### 삭제(`d`) 조합

| 명령어 | 동작 |
|--------|------|
| `dw` | 다음 단어 시작까지 삭제 |
| `de` | 단어 끝까지 삭제 |
| `db` | 단어 시작까지 뒤로 삭제 |
| `d$` 또는 `D` | 줄 끝까지 삭제 |
| `d0` | 줄 시작까지 삭제 |
| `d^` | 첫 번째 비공백 문자까지 삭제 |
| `dG` | 파일 끝까지 삭제 |
| `dgg` | 파일 시작까지 삭제 |
| `dj` | 현재 줄 + 아래 줄 삭제 |
| `d}` | 다음 단락까지 삭제 |
| `df)` | `)` 포함 앞까지 삭제 |
| `dt"` | `"` 바로 앞까지 삭제 |
| `d/pattern` | 패턴의 다음 매칭까지 삭제 |

### 복사(`y`) 조합

| 명령어 | 동작 |
|--------|------|
| `yw` | 다음 단어 시작까지 복사 |
| `ye` | 단어 끝까지 복사 |
| `y$` | 줄 끝까지 복사 |
| `y0` | 줄 시작까지 복사 |
| `yG` | 파일 끝까지 복사 |
| `ygg` | 파일 시작까지 복사 |
| `yf;` | `;` 포함 앞까지 복사 |

### 변경(`c`) 조합

| 명령어 | 동작 |
|--------|------|
| `cw` | 다음 단어까지 변경 (삭제 후 입력 모드) |
| `ce` | 단어 끝까지 변경 |
| `c$` 또는 `C` | 줄 끝까지 변경 |
| `c0` | 줄 시작까지 변경 |
| `cf"` | `"` 포함 앞까지 변경 |
| `ct)` | `)` 바로 앞까지 변경 |

### 들여쓰기(`>`, `<`) 조합

| 명령어 | 동작 |
|--------|------|
| `>j` | 현재 줄 + 다음 줄 들여쓰기 |
| `>}` | 다음 단락까지 들여쓰기 |
| `>>` | 현재 줄 들여쓰기 |
| `<<` | 현재 줄 내어쓰기 |
| `>G` | 여기서 파일 끝까지 들여쓰기 |

### 대소문자 연산자

```
텍스트: hello world

gUw  → HELLO world      (단어 하나를 대문자로)
gUe  → HELLO world      (단어 끝까지 대문자로)
gU$  → HELLO WORLD      (줄 끝까지 대문자로)
guw  → hello world      (단어 하나를 소문자로)
g~w  → HELLO world      (단어 하나의 대소문자 토글)
```

---

## 4. 카운트와 함께 사용하는 연산자

카운트는 연산자 앞, 모션 앞, 또는 둘 다에 붙일 수 있습니다:

```
3dw  =  d3w  =  단어 3개 삭제
2y$  =  줄 끝까지 복사를 2번 (2줄)
5>>  =  5줄 들여쓰기
```

### 실용적인 예시

```
이전: one two three four five six seven
      ^ 커서

d3w  → four five six seven       (단어 3개 삭제)
2dw  → three four five six seven (단어 2개 삭제)
3dd  → (3줄 삭제)                (여러 줄 텍스트에서)
```

---

## 5. 연산자 이중 입력 단축키

연산자를 두 번 누르면 **현재 줄 전체**에 적용됩니다:

| 명령어 | 동작 |
|--------|------|
| `dd` | 현재 줄 삭제 |
| `yy` | 현재 줄 복사 |
| `cc` | 현재 줄 변경 |
| `>>` | 현재 줄 들여쓰기 |
| `<<` | 현재 줄 내어쓰기 |
| `==` | 현재 줄 자동 들여쓰기 |
| `gUU` | 현재 줄 대문자로 |
| `guu` | 현재 줄 소문자로 |
| `g~~` | 현재 줄 대소문자 토글 |

일관적인 규칙입니다: **연산자 + 연산자 = 현재 줄에 적용**.

---

## 6. 도트 명령어

`.`(도트) 명령어는 마지막 **변경(change)**을 반복합니다. "변경"은 텍스트를 수정하는 모든 것입니다: `d`, `c`, `x`, `p`, `>`, 입력 모드 세션 등.

### 기본 사용법

```
시나리오: 여러 줄 삭제
dd     → 첫 번째 줄 삭제
.      → 다음 줄 삭제 (dd 반복)
.      → 다음 줄 삭제
.      → 다음 줄 삭제
```

```
시나리오: 텍스트 전체에서 단어 변경
/word      → "word" 검색
cw         → 변경 (대체 텍스트 입력, Esc 누름)
n          → 다음 발생으로 점프
.          → 변경 반복
n          → 다음 발생
.          → 다시 반복
```

### 도트 명령어를 위한 편집 계획

숙련된 Vim 사용자는 도트 반복 가능성을 극대화하도록 **편집 방식을 설계합니다**:

**덜 최적화된 방식** (도트로 반복하기 어려움):
```
"Hello "를 입력한 후 Esc  → .는 "Hello " 삽입을 반복함
하지만 각 줄 시작에 "Hello "를 추가하려면:
I → "Hello " 입력 → Esc → j → .  (아래로 이동, 반복)
```

**더 나은 방식** (`I`로 줄 시작에 삽입):
```
I          → 줄 시작에 삽입
Hello      → 텍스트 입력
Esc        → 일반 모드로 복귀
j.         → 아래로 이동, 반복 (다음 줄 시작에 "Hello " 추가)
j.         → 다시 반복
```

### 도트 명령어가 기억하는 것

도트 명령어는 **가장 최근의 원자적 변경(atomic change)**을 재실행합니다:
- `dw`를 입력했다면, 도트는 `dw`를 반복
- `cw`로 "new"를 입력하고 `Esc`를 눌렀다면, 도트는 전체 변경을 반복 (단어 삭제 + "new" 삽입)
- `3dd`를 입력했다면, 도트는 `3dd`를 반복 (3줄 삭제)

### 이상적인 Vim 워크플로우

```
1. 변경 수행 (최초 편집)
2. 다음 위치로 이동
3. .을 눌러 반복
4. 2-3 단계 반복
```

이 패턴 — **변경, 이동, 반복** — 이 효율적인 Vim 편집의 핵심입니다.

---

## 7. 연산자 중심으로 사고하기

### 곱셈 효과

`N`개의 연산자와 `M`개의 모션을 알면 `N × M`개의 명령어를 갖게 됩니다:

```
연산자:  d, c, y, >, <, =, gU, gu  → 8개의 연산자
모션:    w, e, b, $, 0, ^, gg, G, }, {, f{c}, t{c}, /{pat}  → 13개 이상의 모션

합계: 8 × 13 = 104개 이상의 고유한 편집 명령어
```

새로운 연산자나 모션을 배울 때마다 능력이 곱해집니다.

### 예시: 새로운 모션 학습

`%`(대응 괄호로 점프)를 배웠다고 가정합니다. 즉시 다음을 사용할 수 있게 됩니다:
- `d%` — 대응 괄호까지 삭제
- `c%` — 대응 괄호까지 변경
- `y%` — 대응 괄호까지 복사
- `>%` — 대응 괄호까지 들여쓰기
- `gU%` — 대응 괄호까지 대문자로

**하나**의 새로운 모션을 배워 다섯 가지 새로운 명령어를 얻었습니다.

---

## 8. 요약

| 개념 | 설명 |
|------|------|
| 문법 | `[count] operator [count] motion` |
| 핵심 연산자 | `d` (삭제), `c` (변경), `y` (복사), `>`/`<` (들여쓰기), `gU`/`gu` (대소문자) |
| 이중 연산자 | `dd`, `yy`, `cc` — 현재 줄에 적용 |
| 도트 명령어(`.`) | 마지막 변경 반복 |
| 카운트 | `3dw` = 단어 3개 삭제 |
| 곱셈 효과 | N개 연산자 × M개 모션 = N×M개 명령어 |
| 이상적인 워크플로우 | 변경 → 이동 → 반복(`.`) |

### 핵심 인사이트

Vim은 암기할 명령어의 집합이 아닙니다 — 배울 **언어**입니다. 문법(연산자 + 모션)을 이해하면, 새로 배우는 모든 단어(연산자나 모션)가 여러분의 어휘력을 기하급수적으로 확장시킵니다.

---

## 연습 문제

### 연습 문제 1: 명령어 분석

아래의 각 Vim 명령어에 대해 연산자, 모션(있다면 카운트 포함)을 식별하고 평이한 말로 무엇을 하는지 설명하세요:

1. `d3w`
2. `gU$`
3. `>G`
4. `ct;`
5. `ygg`

<details>
<summary>정답 보기</summary>

1. `d3w` — 연산자: `d` (삭제), 모션: `3w` (앞으로 단어 3개). **다음 단어 3개를 삭제합니다.**
2. `gU$` — 연산자: `gU` (대문자로), 모션: `$` (줄 끝). **커서에서 줄 끝까지 모두 대문자로 변환합니다.**
3. `>G` — 연산자: `>` (오른쪽 들여쓰기), 모션: `G` (마지막 줄). **커서부터 파일 끝까지 모든 줄을 들여씁니다.**
4. `ct;` — 연산자: `c` (변경), 모션: `t;` (`;` 바로 앞까지). **커서에서 다음 `;` 바로 앞까지(`;` 미포함) 삭제하고 삽입 모드(Insert mode)로 진입합니다.**
5. `ygg` — 연산자: `y` (복사), 모션: `gg` (첫 번째 줄). **커서에서 파일 처음까지 모두 복사합니다.**

</details>

### 연습 문제 2: 올바른 연산자 + 모션 선택

다음 JavaScript 줄이 있습니다 (커서는 `var`의 `v`에 있음):

```javascript
var userName = getUserInput();
```

각 작업을 수행하는 단일 명령어를 작성하세요:

1. 단어 `var`과 그 뒤의 공백을 삭제합니다.
2. `getUserInput`을 다른 것으로 변경합니다 (삭제 후 삽입 모드로 진입).
3. 커서에서 줄 끝까지 복사합니다.
4. `userName`을 대문자로 만듭니다 (커서가 `u`에 있음).

<details>
<summary>정답 보기</summary>

1. `dw` — `var`를 삭제하고 공백으로 이동합니다. 또는 `dW`(전체 WORD와 뒤의 공백 포함 삭제)가 더 깔끔합니다.
2. `getUserInput`의 `g`로 이동 후 `ct(` — `(`까지 변경(괄호 제외 `getUserInput` 삭제 후 삽입 모드 진입, `()` 유지).
3. `y$` — 커서에서 줄 끝까지 복사.
4. `userName`의 `u`에서 `gUe` 또는 `gUw` — 단어 끝/다음 단어 시작까지 대문자로. `gUiw`(텍스트 객체, 레슨 6)가 더 정확합니다.

</details>

### 연습 문제 3: 도트 반복성을 위한 설계

다음 JavaScript 스니펫의 각 줄 끝에 세미콜론을 추가하고 싶습니다:

```
const a = 1
const b = 2
const c = 3
const d = 4
```

가장 도트 반복 가능한 접근 방식을 설명하세요.

<details>
<summary>정답 보기</summary>

**단계별 접근:**
1. 첫 번째 줄에 커서를 놓습니다.
2. `A`를 누릅니다 — 줄 끝으로 이동하고 삽입 모드(Insert mode)로 진입합니다.
3. `;`(세미콜론)을 입력합니다.
4. `Esc`를 누릅니다 — 일반 모드(Normal mode)로 복귀. 이 변경이 기록됩니다: "줄 끝에 `;` 추가".
5. `j`를 누릅니다 — 다음 줄로 이동.
6. `.`을 누릅니다 — 추가 작업을 반복: 끝에 `;` 추가.
7. 각 다음 줄에 `j.`를 반복합니다.

도트 명령어는 `A;Esc` — "줄 끝에 세미콜론 추가" 전체 작업을 재실행합니다.

**더 빠른 방법**: 치환 명령(레슨 8): `:%s/$/;/`을 사용하면 모든 줄에 한 번에 `;`를 추가합니다. 하지만 `A;Esc` + `j.` 방식이 도트 반복 원칙을 잘 보여줍니다.

</details>

### 연습 문제 4: 곱셈 효과

현재 다음을 알고 있습니다:
- 연산자: `d`, `c`, `y`, `>`, `gU`
- 모션: `w`, `e`, `b`, `$`, `0`, `gg`, `G`, `}`, `f{char}`

1. 가능한 연산자+모션 조합은 몇 가지입니까?
2. 방금 `t{char}` 모션을 배웠습니다. 이 하나의 추가로 새로운 명령어는 몇 개가 생깁니까?
3. 방금 `=`(자동 들여쓰기) 연산자를 배웠습니다. 기존 모션과 함께 새로운 명령어는 몇 개가 생깁니까?

<details>
<summary>정답 보기</summary>

1. 5개 연산자 × 9개 모션 = **45개 조합**.
2. `t{char}` 학습으로 모션이 1개 추가됩니다. 이제 5 × 10 = 50개. 증가분은 **5개의 새로운 명령어** (각 연산자마다 하나: `dt{char}`, `ct{char}`, `yt{char}`, `>t{char}`, `gUt{char}`).
3. `=` 학습으로 연산자가 1개 추가됩니다. 이제 6 × 10 = 60개. 증가분은 **10개의 새로운 명령어** (기존 모션마다 하나: `=w`, `=e`, `=b`, `=$`, `=0`, `=gg`, `=G`, `=}`, `=f{char}`, `=t{char}`).

새로운 연산자 하나가 M개의 새로운 명령어를 주고(모션당 하나), 새로운 모션 하나가 N개의 새로운 명령어를 준다는 것을 보여줍니다.

</details>

### 연습 문제 5: 완전한 편집 작업

커서가 1번 줄, 1번 열에 있는 상태에서:

```
hello WORLD
This is a TEST line.
foo BAR baz
```

다음으로 변환하는 정확한 키 시퀀스를 설명하세요:

```
hello world
This is a test line.
foo bar baz
```

(각 줄의 대문자 단어들을 소문자로 변환)

<details>
<summary>정답 보기</summary>

**1번 줄**: 커서가 `h`에 있습니다. `W`를 눌러 `WORLD`로 점프합니다. `gue`로 단어 끝까지 소문자로 → `world`.

**2번 줄**: `j`를 눌러 2번 줄로 이동. `fT`로 `TEST`의 `T`를 찾습니다. `gue` → `test`.

**3번 줄**: `j`를 눌러 3번 줄로 이동. `W`를 눌러 `BAR`로 점프합니다. `gue` → `bar`.

또는 도트 명령어를 활용하면: `WORLD`에서 `gue`를 수행한 후 변경이 기록됩니다. `TEST`로 이동하여 `.`을 누릅니다 — 도트는 "단어 끝까지 소문자로"를 반복합니다. 그 다음 `BAR`로 이동하여 `.`을 다시 누릅니다.

간소화된 시퀀스: `W gue j fT . j W .`

</details>

---

**이전**: [모션과 내비게이션](./04_Motions_and_Navigation.md) | **다음**: [텍스트 객체](./06_Text_Objects.md) — Vim의 정밀 선택 메커니즘을 배웁니다.

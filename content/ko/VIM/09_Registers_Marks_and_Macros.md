# 레지스터, 마크, 매크로(Registers, Marks, and Macros)

**이전**: [검색과 치환](./08_Search_and_Replace.md) | **다음**: [버퍼, 창, 탭](./10_Buffers_Windows_and_Tabs.md)

---

## 학습 목표

이 레슨을 마치면 다음을 할 수 있습니다:

1. 명명 레지스터(Named Register, `"a`-`"z`)를 사용해 여러 클립보드 항목 저장 및 불러오기
2. 특수 레지스터(unnamed, numbered, 시스템 클립보드, 표현식)에 접근하기
3. 마크(Mark)를 설정하고 탐색하여 파일 내 위치 북마크 활용하기
4. 매크로(Macro)를 녹화, 재생, 편집하여 반복 작업 자동화하기
5. 범위와 파일에 걸쳐 매크로를 효율적으로 적용하기

---

> **비유 — 레이블이 붙은 클립보드 서랍**: 책상에 a부터 z까지 레이블이 붙은 26개의 서랍이 있고, 각 서랍에 텍스트 조각을 보관할 수 있다고 상상해 보세요. 무언가를 복사할 때 어느 서랍에 넣을지 선택할 수 있고, 붙여넣을 때는 어느 서랍에서 꺼낼지 고르면 됩니다. 이것이 Vim의 레지스터(Register) 시스템입니다 — 26개의 명명 클립보드와 특수 목적 레지스터들을, 모두 단 하나의 키 입력으로 사용할 수 있습니다.

레지스터(Register), 마크(Mark), 매크로(Macro)는 Vim의 "고급 도구"입니다 — 텍스트를 저장하고 불러오며 자동화할 수 있게 해주어 편집 능력을 비약적으로 향상시킵니다. 많은 Vim 사용자들이 매크로를 생산성을 가장 크게 높여주는 기능으로 꼽습니다.

## 목차

1. [레지스터 — 여러 개의 클립보드](#1-레지스터--여러-개의-클립보드)
2. [특수 레지스터](#2-특수-레지스터)
3. [시스템 클립보드 연동](#3-시스템-클립보드-연동)
4. [마크 — 위치 북마크](#4-마크--위치-북마크)
5. [매크로 — 녹화와 재생](#5-매크로--녹화와-재생)
6. [고급 매크로 기법](#6-고급-매크로-기법)
7. [실용 워크플로우](#7-실용-워크플로우)
8. [요약](#8-요약)

---

## 1. 레지스터 — 여러 개의 클립보드

Vim에서 삭제, 복사(yank), 변경을 수행하면 텍스트가 **레지스터(Register)**에 저장됩니다. 기본적으로는 이름 없는 레지스터(`""`)가 사용되지만, 원하는 명명 레지스터를 지정할 수 있습니다.

### 명명 레지스터 사용

레지스터를 지정하려면 명령 앞에 `"`와 레지스터 문자를 붙입니다:

```
"ayy     → 현재 줄을 레지스터 a에 복사
"ap      → 레지스터 a의 내용 붙여넣기
"bdd     → 줄을 삭제하여 레지스터 b에 저장
"bp      → 레지스터 b의 내용 붙여넣기
"cy3w    → 단어 3개를 레지스터 c에 복사
```

### 대문자로 추가(Uppercase Appends)

대문자를 사용하면 레지스터를 덮어쓰는 대신 **추가(Append)**합니다:

```
"ayy     → 줄을 레지스터 a에 복사 (덮어쓰기)
jj
"Ayy     → 이 줄을 레지스터 a에 추가 (이제 2줄이 됨)
"ap      → 두 줄 모두 붙여넣기
```

### 레지스터 보기

```vim
:registers         " 모든 레지스터 표시
:reg               " 단축 형식
:reg a b c         " 특정 레지스터 표시
```

출력 형식:

```
--- Registers ---
""   last deleted or yanked text
"0   last yank (not delete)
"1   last delete
"a   contents of register a
"b   contents of register b
"+   system clipboard
```

---

## 2. 특수 레지스터

| 레지스터 | 이름 | 내용 |
|----------|------|----------|
| `""` | 이름 없는(Unnamed) | 마지막 삭제, 변경, 또는 복사 |
| `"0` | 복사 레지스터(Yank) | 마지막 복사만 (삭제 제외) |
| `"1`-`"9` | 번호 지정(Numbered) | 마지막 9개 삭제 (1=가장 최근) |
| `"-` | 소규모 삭제(Small delete) | 한 줄 미만의 마지막 삭제 |
| `"+` | 시스템 클립보드(System clipboard) | 시스템 클립보드 (아래 참고) |
| `"*` | 기본 선택(Primary selection) | X11 기본 선택 영역 (Linux) |
| `".` | 마지막 삽입(Last insert) | 마지막 입력 모드 세션의 텍스트 |
| `"%` | 현재 파일(Current file) | 현재 파일 이름 |
| `"#` | 대체 파일(Alternate file) | 이전에 편집한 파일 이름 |
| `":` | 마지막 명령(Last command) | 마지막 명령줄 명령 |
| `"/` | 마지막 검색(Last search) | 마지막 검색 패턴 |
| `"=` | 표현식(Expression) | 표현식 평가 (아래 참고) |
| `"_` | 블랙홀(Black hole) | 텍스트 버림 (진짜 삭제) |

### 이름 없는 레지스터 문제

`dd`로 텍스트를 삭제하면 이름 없는 레지스터(`""`)로 들어가 기존 내용을 덮어씁니다. 이 때문에:

```
yy       → 줄 복사 ("" 및 "0에 저장)
jjdd     → 줄 삭제 (""는 덮어씀, "0은 유지!)
p        → 삭제된 줄이 붙여넣어짐 (복사한 것이 아님!)
```

**해결책**: `"0p`를 사용해 마지막으로 복사한 내용 붙여넣기 (삭제 무시):

```
yy       → 줄 복사
jjdd     → 줄 삭제 ("0에 영향 없음)
"0p      → 복사(yank)한 줄 붙여넣기 ("0에서)
```

### 블랙홀 레지스터(Black Hole Register)

`"_`를 사용하면 어떤 레지스터에도 영향을 주지 않고 삭제할 수 있습니다:

```
"_dd     → 줄 삭제, 어디에도 저장 안 됨
"_dw     → 단어 삭제, 레지스터 변경 없음
```

복사(yank) 레지스터를 덮어쓰지 않고 텍스트를 삭제할 때 유용합니다.

### 표현식 레지스터(Expression Register)

입력 모드(Insert mode)나 명령줄 모드(Command-line mode)에서 `Ctrl-r =`로 표현식을 평가합니다:

```
입력 모드에서:
Ctrl-r = 2 + 3 Enter    → "5" 삽입
Ctrl-r = system('date')  → 현재 날짜 삽입
```

---

## 3. 시스템 클립보드 연동

### `+`와 `*` 레지스터

| 레지스터 | macOS | Linux (X11) | Windows |
|----------|-------|-------------|---------|
| `"+` | 시스템 클립보드 | 클립보드 (Ctrl-C/V) | 클립보드 |
| `"*` | `"+`와 동일 | 기본 선택 영역 (마우스 선택) | `"+`와 동일 |

### 시스템 클립보드로 복사 / 시스템 클립보드에서 붙여넣기

```
"+yy     → 줄을 시스템 클립보드에 복사
"+p      → 시스템 클립보드에서 붙여넣기

"+y      → (비주얼 모드에서) 선택 영역을 클립보드에 복사
"+P      → 커서 앞에 클립보드에서 붙여넣기
```

### 클립보드 옵션

모든 복사/삭제 작업이 자동으로 시스템 클립보드를 사용하게 하려면:

```vim
set clipboard=unnamedplus    " y/d/c에 + 레지스터 사용
```

이 설정을 적용하면 `yy`와 `p`가 시스템 클립보드와 직접 연동됩니다.

### 클립보드 지원 확인

```bash
vim --version | grep clipboard
# +clipboard (지원됨) 또는 -clipboard (지원 안 됨) 확인
```

클립보드가 지원되지 않는 경우 전체 Vim 빌드를 설치하세요:
```bash
# macOS (Homebrew vim에는 클립보드 지원 포함)
brew install vim

# Ubuntu
sudo apt install vim-gtk3    # 또는 vim-gtk
```

---

## 4. 마크 — 위치 북마크

마크(Mark)는 [4번 레슨](./04_Motions_and_Navigation.md)에서 소개되었지만, 여기서는 더 자세히 다룹니다.

### 로컬 마크(Local Marks, `a-z`)

파일 내 특정 위치 북마크:

```
ma       → 현재 위치에 마크 'a' 설정
'a       → 마크 'a'가 있는 줄로 이동
`a       → 마크 'a'의 정확한 위치로 이동
```

### 전역 마크(Global Marks, `A-Z`)

파일 간 북마크 — 어느 파일에서든 사용 가능:

```
mA       → 현재 위치에 전역 마크 'A' 설정
'A       → 마크 'A'로 이동 (필요 시 파일 열기)
```

### 마크 목록 보기

```vim
:marks         " 모든 마크 표시
:marks aB      " 특정 마크 표시
```

### 유용한 마크 패턴

```
" 큰 이동 전 위치 표시
ma           → 현재 위치 북마크
/function    → 검색 (멀리 이동)
'a           → 이전 위치로 돌아오기

" 중요한 코드 위치 표시
mf           → 함수 정의 표시
mt           → 테스트 파일 위치 표시
'f           → 함수로 이동
't           → 테스트로 이동

" 파일 간 탐색을 위한 전역 마크 사용
mM           → 메인 파일 표시
mT           → 테스트 파일 표시
'M           → 어디서든 메인 파일로 이동
```

### 마크 삭제

```vim
:delmarks a      " 마크 a 삭제
:delmarks a-d    " 마크 a부터 d까지 삭제
:delmarks!       " 모든 소문자 마크 삭제
```

---

## 5. 매크로 — 녹화와 재생

매크로(Macro)는 자동 재생을 위해 키 입력 시퀀스를 녹화합니다.

### 매크로 녹화

```
qa       → 레지스터 'a'에 녹화 시작
...      → 편집 작업 수행
q        → 녹화 중지
```

### 매크로 재생

```
@a       → 레지스터 'a'의 매크로 재생
@@       → 마지막으로 재생한 매크로 재실행
5@a      → 매크로 'a'를 5번 재생
```

### 단계별 예제

작업: 각 줄 끝에 세미콜론 추가.

```
Line 1: let x = 1
Line 2: let y = 2
Line 3: let z = 3
```

```
qa           → 레지스터 a에 녹화 시작
A;           → 줄 끝에 세미콜론 추가 (A는 끝에서 입력 모드 진입)
Esc          → 일반 모드로 복귀
j            → 다음 줄로 이동
q            → 녹화 중지

@a           → 다음 줄에 적용
@@           → 그 다음 줄에 적용 (또는 2@a)
```

결과:
```
Line 1: let x = 1;
Line 2: let y = 2;
Line 3: let z = 3;
```

### 신뢰할 수 있는 매크로의 핵심

**예측 가능한 위치에서 시작하고 끝내세요.** 좋은 매크로 패턴:

1. **위치 설정**: 알려진 위치로 이동 (`0`, `^`, `gg` 등)
2. **편집**: 편집 작업 수행
3. **이동**: 다음 반복을 위한 위치로 이동 (`j`, `n` 등)

```
qa              → 녹화 시작
0               → 줄 시작으로 이동 (예측 가능한 위치)
f"              → 첫 번째 따옴표 찾기
ci"new text     → 따옴표 내부 내용 변경
Esc             → 일반 모드로 복귀
j               → 다음 줄로 이동
q               → 중지
```

---

## 6. 고급 매크로 기법

### 범위에 매크로 적용

```vim
:5,10normal @a       " 5-10번째 줄에 매크로 'a' 적용
:%normal @a          " 모든 줄에 매크로 'a' 적용
:'<,'>normal @a      " 비주얼 선택 영역에 적용
```

### 재귀 매크로(Recursive Macros)

매크로가 자기 자신을 호출하여 오류(예: 파일 끝) 발생 시 자동으로 멈추는 루프를 만들 수 있습니다:

```
qqq              → 레지스터 q 초기화 (아무것도 녹화 안 함)
qq               → q에 녹화 시작
...edits...      → 편집 작업
j                → 다음 줄로 이동
@q               → 자기 자신 호출 (재귀)
q                → 녹화 중지
@q               → 재귀 매크로 시작
```

마지막 줄을 넘어가려 할 때처럼 오류가 발생하면 매크로가 자동으로 중지됩니다.

### 매크로 편집

매크로는 레지스터에 텍스트로 저장됩니다. 다음과 같이 편집할 수 있습니다:

```
" 매크로를 버퍼에 붙여넣기
"ap              → 레지스터 a 붙여넣기

" 텍스트 편집 (키 입력 그대로임)
... 변경 작업 ...

" 레지스터에 다시 복사
"ayy             → 수정된 텍스트를 레지스터 a에 다시 복사
```

또는 `let`을 사용합니다:
```vim
:let @a = "Iprefix: \<Esc>j"    " 레지스터 a를 직접 설정
```

### 매크로에 추가하기(Appending to a Macro)

대문자 레지스터를 사용하여 추가합니다:

```
qa...q           → 레지스터 a에 매크로 녹화
qA...q           → 매크로 a에 추가 단계 붙이기
```

---

## 7. 실용 워크플로우

### 워크플로우 1: 멀티 클립보드

```
" 나중에 사용할 다양한 내용 복사:
"ayy             → 줄을 레지스터 a에 복사 (함수 시그니처)
"byy             → 다른 줄을 레지스터 b에 복사 (import 구문)
"cyy             → 또 다른 줄을 레지스터 c에 복사 (변수)

" 필요한 곳에 붙여넣기:
"ap              → 함수 시그니처 붙여넣기
"bp              → import 구문 붙여넣기
"cp              → 변수 붙여넣기
```

### 워크플로우 2: 코드 변환을 위한 매크로

작업: 이름 목록을 특정 형식으로 변환.

```
변환 전:
john doe
jane smith
bob wilson

목표:
name: "John Doe",
name: "Jane Smith",
name: "Bob Wilson",
```

```
qa               → 녹화 시작
I                → 줄 시작에서 입력 모드 진입
name: "          → 접두사 입력
Esc              → 입력 모드 종료
~                → 'j'의 대소문자 전환 → 'J'
w~               → 다음 단어로 이동, 'd' 전환 → 'D'
A",              → 끝에 추가
Esc              → 입력 모드 종료
j0               → 다음 줄, 줄 시작으로
q                → 녹화 중지
2@a              → 나머지 2줄에 적용
```

### 워크플로우 3: 코드 탐색을 위한 마크

```
" 기능 구현 작업 중:
mI               → 인터페이스(Interface) 정의 표시 (전역 마크)
mF               → 함수(Function) 구현 표시
mT               → 테스트(Test) 파일 표시

" 이동:
'I               → 인터페이스 확인
'F               → 구현으로 이동
'T               → 테스트 실행/확인
```

---

## 8. 요약

### 레지스터(Registers)

| 레지스터 | 용도 | 예제 |
|----------|-------|---------|
| `"a`-`"z` | 명명 저장 | `"ayy`, `"ap` |
| `"A`-`"Z` | 명명 레지스터에 추가 | `"Ayy` |
| `""` | 이름 없는 (기본) | `yy`, `p` |
| `"0` | 마지막 복사(yank) | `"0p` |
| `"1`-`"9` | 삭제 히스토리 | `"1p` |
| `"+` | 시스템 클립보드 | `"+yy`, `"+p` |
| `"_` | 블랙홀 | `"_dd` |
| `"=` | 표현식 | `Ctrl-r =` |

### 마크(Marks)

| 마크 | 범위 | 예제 |
|------|-------|---------|
| `a`-`z` | 파일 로컬 | `ma`, `` `a `` |
| `A`-`Z` | 전역 (파일 간) | `mA`, `'A` |
| `` ` `` | 마지막 이동 위치 | ``` `` ``` |
| `.` | 마지막 편집 위치 | `` `. `` |

### 매크로(Macros)

| 동작 | 명령 |
|--------|---------|
| 녹화 | `q{a-z}` ... `q` |
| 재생 | `@{a-z}` |
| 마지막 재생 반복 | `@@` |
| N번 재생 | `{N}@{a-z}` |
| 범위에 적용 | `:{range}normal @{a-z}` |
| 매크로 편집 | 붙여넣기 → 편집 → 다시 복사 |

---

## 연습 문제

### 연습 문제 1: 이름 없는 레지스터 문제

다음 시나리오가 있습니다:

1. `yy`로 줄을 복사합니다.
2. 여러 줄 아래로 이동합니다.
3. `dd`로 불필요한 줄을 삭제합니다.
4. `p`를 눌러 붙여넣습니다.

붙여넣어지는 것은 복사(yank)한 줄입니까, 삭제한 줄입니까? 원래 복사한 줄을 붙여넣으려면 어떻게 해야 합니까?

<details>
<summary>정답 보기</summary>

**붙여넣어지는 것**: **삭제된** 줄입니다. `dd` 명령이 삭제된 내용을 이름 없는 레지스터 `""`에 써서 복사된 내용을 덮어씁니다.

**원래 복사한 줄을 붙여넣는 방법**: `"0p`를 사용합니다 — 복사 레지스터(`"0`)는 복사 작업(`y`, `yy`)에 의해서만 업데이트되며, 삭제 작업(`d`, `dd`)에는 영향받지 않습니다. 따라서 `"0`에는 `dd` 이후에도 원래 복사한 줄이 유지됩니다.

이것은 Vim 초보자에게 가장 흔한 놀라움 중 하나입니다. 해결책은 복사(yank)한 내용을 붙여넣을 때(삭제한 것이 아닌) 항상 `"0p`를 사용하는 것입니다.

</details>

### 연습 문제 2: 다중 레지스터 복사/붙여넣기

Python 파일을 편집하면서 나중에 사용할 코드 스니펫 세 개를 복사하고 싶습니다. 명명 레지스터 `a`, `b`, `c`를 사용한 완전한 워크플로우를 설명하세요.

<details>
<summary>정답 보기</summary>

**명명 레지스터에 복사:**
1. 첫 번째 스니펫(예: 함수 시그니처)으로 이동 후 `"ayy` 누르기 — 레지스터 `a`에 복사.
2. 두 번째 스니펫(예: import 구문)으로 이동 후 `"byy` 누르기 — 레지스터 `b`에 복사.
3. 세 번째 스니펫(예: 설정 상수)으로 이동 후 `"cyy` 누르기 — 레지스터 `c`에 복사.

**레지스터 확인:**
- `:reg a b c`를 입력하여 세 레지스터의 내용을 검사합니다.

**나중에 붙여넣기:**
- `"ap` — 함수 시그니처 붙여넣기.
- `"bp` — import 구문 붙여넣기.
- `"cp` — 설정 상수 붙여넣기.

명명 레지스터는 Vim 세션 전체에 유지되므로, 다른 많은 편집 후에도 어느 위치에서든 원하는 순서로 붙여넣을 수 있습니다.

</details>

### 연습 문제 3: 매크로 녹화 및 적용

다음 형식이 필요한 항목 목록이 있습니다:

```
apple
banana
cherry
date
elderberry
```

각 줄을 `- "apple",` 형식으로 변환하고 싶습니다.

레지스터 `q`에 매크로를 녹화하고 5줄 모두에 적용하세요. 매크로의 각 키 입력을 작성하세요.

<details>
<summary>정답 보기</summary>

**매크로 녹화:**
```
qq         → 레지스터 q에 녹화 시작
0          → 줄 시작으로 이동 (예측 가능한 위치)
I- "       → 줄 시작에 삽입: - "
Esc        → 일반 모드(Normal mode)로 복귀
A",        → 줄 끝에 추가: ",
Esc        → 일반 모드(Normal mode)로 복귀
j          → 다음 줄로 이동 (다음 반복을 위해 이동)
q          → 녹화 중지
```

**모든 줄에 적용:**
- 1번 줄에 커서를 놓습니다.
- `@q`를 한 번 실행하면 1번 줄을 처리하고 2번 줄로 이동합니다.
- `4@q`를 눌러 나머지 4줄에 적용합니다.

**결과:**
```
- "apple",
- "banana",
- "cherry",
- "date",
- "elderberry",
```

</details>

### 연습 문제 4: 블랙홀 레지스터와 복사 레지스터

다음 작업을 해야 합니다:
1. `important_function()`을 나중에 붙여넣기 위해 복사합니다.
2. 복사본을 잃지 않고 불필요한 줄들을 삭제합니다.
3. 마지막에 `important_function()`을 붙여넣습니다.

블랙홀 레지스터를 사용한 완전한 워크플로우를 설명하세요.

<details>
<summary>정답 보기</summary>

**1단계**: `important_function()` 줄로 이동하고 `yy`를 누릅니다 — `""`와 `"0`에 복사됩니다.

**2단계**: 각 불필요한 줄로 이동하여 `"_dd`를 누릅니다 — 줄을 삭제하지만 `""`가 아닌 블랙홀 레지스터 `"_`로 보냅니다. `"0`의 복사된 내용은 그대로 유지됩니다.

**3단계**: 목적지로 이동하고 `"0p`를 누릅니다 (또는 `"_dd`를 사용했다면 그냥 `p` — `"_dd`는 `""`를 덮어쓰지 않으므로 이름 없는 레지스터에는 1단계의 복사 내용이 여전히 있습니다).

**이것이 중요한 이유**: `"_dd`를 사용하면 삭제 작업이 이름 없는 레지스터를 덮어쓰지 않습니다. 따라서 블랙홀 삭제 후 일반 `p`를 눌러도 원래 복사한 내용을 얻을 수 있습니다.

</details>

### 연습 문제 5: 매크로 편집

레지스터 `a`에 각 줄 시작에 `console.log("debug");`를 추가하는 매크로를 녹화했습니다. 녹화 후 인라인이 아닌 새 줄을 추가하기로 했습니다. 처음부터 다시 녹화하지 않고 매크로를 편집하는 방법은?

<details>
<summary>정답 보기</summary>

**방법 1: 붙여넣기, 편집, 다시 복사**

1. 버퍼의 빈 줄을 엽니다.
2. `"ap`를 누릅니다 — 매크로의 원시 내용을 붙여넣습니다 (문자처럼 보입니다: `Iconsole.log("debug");\<Esc>j`).
3. 텍스트를 편집합니다: `I`(줄 시작에 삽입 의미)를 찾아 그 앞에 `O`(위에 새 줄 열기)를 추가하거나 필요에 맞게 수정합니다.
4. 편집 후 `V`로 그 줄을 비주얼로 선택합니다.
5. `"ay`를 누릅니다 — 수정된 줄을 레지스터 `a`에 다시 복사합니다.
6. 이제 `@a`는 수정된 매크로를 실행합니다.

**방법 2: `:let`으로 설정**

```vim
:let @a = "Oconsole.log(\"debug\");\<Esc>j"
```

`:let @a = "..."` 명령은 레지스터를 직접 설정합니다. Escape 키에는 `\<Esc>`, 문자열 내부의 따옴표에는 `\"`를 사용합니다.

</details>

---

**이전**: [검색과 치환](./08_Search_and_Replace.md) | **다음**: [버퍼, 창, 탭](./10_Buffers_Windows_and_Tabs.md)

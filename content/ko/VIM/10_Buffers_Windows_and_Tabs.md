# 버퍼, 창, 탭

**이전**: [레지스터, 마크, 매크로](./09_Registers_Marks_and_Macros.md) | **다음**: [명령줄과 고급 기능](./11_Command_Line_and_Advanced_Features.md)

---

## 학습 목표

이 레슨을 마치면 다음을 할 수 있습니다:

1. Vim에서 버퍼(Buffer), 창(Window), 탭(Tab)의 관계를 설명할 수 있다
2. 여러 버퍼를 관리할 수 있다 (열기, 목록 조회, 전환, 삭제)
3. 화면을 여러 창으로 분할(수평, 수직)하고 창 간에 이동할 수 있다
4. 창 레이아웃 묶음으로서 탭을 활용할 수 있다
5. 효율적인 다중 파일 워크플로우를 구성할 수 있다

---

실제 프로젝트를 작업할 때는 여러 파일을 동시에 편집해야 합니다. Vim은 세 가지 개념으로 이를 처리합니다: **버퍼(Buffer)**(메모리에 올라간 파일), **창(Window)**(뷰포트), **탭(Tab)**(창들의 집합). 이를 올바르게 이해하는 것이 중요합니다 — 많은 Vim 사용자들이 브라우저 탭처럼 동작할 것으로 기대하며 탭을 잘못 사용하곤 합니다.

## 목차

1. [개념 모델](#1-개념-모델)
2. [버퍼 — 메모리의 파일](#2-버퍼--메모리의-파일)
3. [창 — 뷰포트](#3-창--뷰포트)
4. [탭 — 창 레이아웃](#4-탭--창-레이아웃)
5. [인수 목록](#5-인수-목록)
6. [실용적인 다중 파일 워크플로우](#6-실용적인-다중-파일-워크플로우)
7. [요약](#7-요약)

---

## 1. 개념 모델

```
┌─── Tab 1 ──────────────────────┐  ┌─── Tab 2 ─────────┐
│  ┌─Window 1──┐ ┌─Window 2──┐  │  │  ┌─Window 1───┐   │
│  │           │ │           │  │  │  │            │   │
│  │ Buffer A  │ │ Buffer B  │  │  │  │ Buffer A   │   │
│  │ (file.py) │ │ (test.py) │  │  │  │ (file.py)  │   │
│  │           │ │           │  │  │  │            │   │
│  └───────────┘ └───────────┘  │  │  └────────────┘   │
└────────────────────────────────┘  └────────────────────┘
```

- **버퍼(Buffer)**: 메모리에 올라간 파일. 버퍼는 많이 열 수 있지만, 전부 화면에 표시될 필요는 없습니다.
- **창(Window)**: 버퍼를 표시하는 뷰포트. 여러 창이 동일한 버퍼를 보여줄 수 있습니다.
- **탭(Tab)**: 창들의 집합 (레이아웃). 브라우저 탭과는 다릅니다.

**핵심 인사이트**: 버퍼가 기본 단위입니다. 파일 작업은 버퍼 중심으로 이루어지며, 창과 탭은 버퍼를 보는 다양한 방법에 불과합니다.

---

## 2. 버퍼 — 메모리의 파일

### 파일을 버퍼로 열기

```vim
:e filename       " 파일 편집 (열기)
:e .              " 현재 디렉토리에서 파일 탐색기 열기
:e **/*.py        " 와일드카드로 파일 열기 (wildmenu 사용 시)
```

### 버퍼 목록 조회

```vim
:ls               " 모든 버퍼 목록 표시
:buffers          " :ls와 동일
```

출력 예시:
```
  1 %a   "app.py"              line 42
  2 #    "test_app.py"         line 1
  3      "utils.py"            line 15
```

| 기호 | 의미 |
|--------|---------|
| `%` | 현재 버퍼 (현재 창에 표시 중) |
| `#` | 대체 버퍼(Alternate buffer) (이전 버퍼) |
| `a` | 활성(Active) (로드되어 화면에 표시 중) |
| `h` | 숨김(Hidden) (로드되었지만 표시되지 않음) |
| `+` | 수정됨 (저장되지 않은 변경사항 있음) |

### 버퍼 전환

| 명령 | 동작 |
|---------|--------|
| `:bn` 또는 `:bnext` | 다음 버퍼 |
| `:bp` 또는 `:bprev` | 이전 버퍼 |
| `:b {N}` | 번호 N인 버퍼로 전환 |
| `:b {name}` | 이름 일부로 버퍼 전환 |
| `:b#` 또는 `Ctrl-^` | 현재 버퍼와 대체 버퍼 간 토글 |
| `:bf` | 첫 번째 버퍼 |
| `:bl` | 마지막 버퍼 |

### 이름 일부 매칭

`:b`는 부분 매칭과 탭 자동완성을 지원합니다:

```vim
:b app       " "app"이 포함된 버퍼로 전환 (예: app.py)
:b test<Tab> " 버퍼 이름 탭 자동완성
```

### 버퍼 닫기

| 명령 | 동작 |
|---------|--------|
| `:bd` 또는 `:bdelete` | 현재 버퍼 삭제 (닫기) |
| `:bd {N}` | 번호 N인 버퍼 삭제 |
| `:bd {name}` | 이름으로 버퍼 삭제 |
| `:%bd` | 모든 버퍼 삭제 |
| `:bd!` | 강제 삭제 (저장되지 않은 변경사항 버림) |

### 숨김 버퍼(Hidden Buffer)

기본적으로 Vim은 수정된 버퍼에서 전환하지 못하도록 합니다. `hidden`을 설정하면 허용됩니다:

```vim
set hidden         " 저장되지 않은 버퍼에서도 전환 허용
```

다중 버퍼 워크플로우에서는 거의 필수적인 설정입니다.

---

## 3. 창 — 뷰포트

### 분할 창 만들기

| 명령 | 동작 |
|---------|--------|
| `:sp` 또는 `Ctrl-w s` | 수평 분할 (같은 버퍼) |
| `:vsp` 또는 `Ctrl-w v` | 수직 분할 (같은 버퍼) |
| `:sp {file}` | 새 파일로 수평 분할 |
| `:vsp {file}` | 새 파일로 수직 분할 |
| `:new` | 빈 버퍼로 수평 분할 |
| `:vnew` | 빈 버퍼로 수직 분할 |

### 시각적 레이아웃

```
:sp (수평 분할)             :vsp (수직 분할)

┌──────────────────┐        ┌─────────┬─────────┐
│    Window 1      │        │         │         │
│    (buffer A)    │        │ Window 1│ Window 2│
├──────────────────┤        │(buff A) │(buff A) │
│    Window 2      │        │         │         │
│    (buffer A)    │        │         │         │
└──────────────────┘        └─────────┴─────────┘
```

### 창 간 이동

모든 창 명령은 `Ctrl-w` 접두사를 사용합니다:

| 명령 | 동작 |
|---------|--------|
| `Ctrl-w h` | 왼쪽 창으로 이동 |
| `Ctrl-w j` | 아래 창으로 이동 |
| `Ctrl-w k` | 위 창으로 이동 |
| `Ctrl-w l` | 오른쪽 창으로 이동 |
| `Ctrl-w w` | 다음 창으로 순환 |
| `Ctrl-w W` | 이전 창으로 순환 |
| `Ctrl-w p` | 이전에 사용한 창으로 이동 |

### 창 크기 조절

| 명령 | 동작 |
|---------|--------|
| `Ctrl-w =` | 모든 창을 동일한 크기로 |
| `Ctrl-w _` | 현재 창 높이 최대화 |
| `Ctrl-w \|` | 현재 창 너비 최대화 |
| `Ctrl-w +` | 높이를 1줄 늘리기 |
| `Ctrl-w -` | 높이를 1줄 줄이기 |
| `Ctrl-w >` | 너비를 1열 늘리기 |
| `Ctrl-w <` | 너비를 1열 줄이기 |
| `{N}Ctrl-w _` | 높이를 N줄로 설정 |
| `{N}Ctrl-w \|` | 너비를 N열로 설정 |

### 창 이동

| 명령 | 동작 |
|---------|--------|
| `Ctrl-w r` | 창 위치 회전 (위치 교환) |
| `Ctrl-w R` | 역방향으로 회전 |
| `Ctrl-w x` | 인접한 창과 교환 |
| `Ctrl-w H` | 창을 맨 왼쪽으로 이동 (전체 높이) |
| `Ctrl-w J` | 창을 맨 아래로 이동 (전체 너비) |
| `Ctrl-w K` | 창을 맨 위로 이동 (전체 너비) |
| `Ctrl-w L` | 창을 맨 오른쪽으로 이동 (전체 높이) |

### 창 닫기

| 명령 | 동작 |
|---------|--------|
| `:q` 또는 `Ctrl-w q` | 현재 창 닫기 |
| `:only` 또는 `Ctrl-w o` | 현재 창을 제외한 모든 창 닫기 |
| `:qa` | 모든 창 닫고 종료 |

---

## 4. 탭 — 창 레이아웃

Vim의 탭은 브라우저 탭과 다릅니다. 각 탭은 **창 레이아웃** — 분할 창들의 집합입니다. 동일한 프로젝트에서 서로 다른 작업이나 관점에 따라 사용합니다.

### 탭 만들기와 닫기

| 명령 | 동작 |
|---------|--------|
| `:tabnew` | 빈 버퍼로 새 탭 열기 |
| `:tabnew {file}` | 새 탭에서 파일 열기 |
| `:tabe {file}` | `:tabnew {file}`과 동일 |
| `:tabclose` | 현재 탭 닫기 |
| `:tabonly` | 다른 모든 탭 닫기 |

### 탭 간 이동

| 명령 | 동작 |
|---------|--------|
| `gt` | 다음 탭으로 이동 |
| `gT` | 이전 탭으로 이동 |
| `{N}gt` | N번 탭으로 이동 |
| `:tabn` | 다음 탭 |
| `:tabp` | 이전 탭 |
| `:tabfirst` | 첫 번째 탭 |
| `:tablast` | 마지막 탭 |

### 탭 목록 조회

```vim
:tabs         " 모든 탭과 해당 창 목록 표시
```

### 탭을 언제 사용할까

**적절한 사용 예**:
- 관심사 분리: 코드 탭 + 테스트 탭 + 문서 탭
- 파일 비교: 각 탭에서 다른 배치로 파일 표시
- 임시 작업 공간: 탭을 열고, 작업 후 닫기

**안티패턴(Anti-pattern)**: 파일 탭으로 사용하기 (파일 하나당 탭 하나). 그런 용도에는 **버퍼**를 사용하세요 — 더 효율적이고 Vim은 버퍼 기반 워크플로우를 중심으로 설계되어 있습니다.

---

## 5. 인수 목록

인수 목록(Argument List)은 Vim 실행 시 전달된 파일 목록이지만, 동적으로 수정할 수 있습니다.

### 기본 사용법

```bash
vim *.py         # 모든 .py 파일 열기 (인수 목록이 됨)
```

```vim
:args            " 현재 인수 목록 표시
:args *.js       " 모든 .js 파일로 인수 목록 설정
:next            " 인수 목록의 다음 파일
:prev            " 이전 파일
:first           " 첫 번째 파일
:last            " 마지막 파일
```

### 인수 목록 전체에 명령 적용

```vim
" 인수 목록의 모든 파일에서 치환:
:argdo %s/old/new/ge | update

" 인수 목록의 모든 파일에서 매크로 실행:
:argdo normal @a | update
```

### 버퍼 동등 명령: `:bufdo`

```vim
:bufdo %s/old/new/ge | update    " 열린 모든 버퍼에서 치환
```

---

## 6. 실용적인 다중 파일 워크플로우

### 워크플로우 1: 두 파일 분할 (소스 + 테스트)

```vim
:e app.py            " 소스 파일 열기
:vsp test_app.py     " 테스트 파일로 수직 분할
Ctrl-w l             " 테스트 창으로 전환
" ... 테스트 편집 ...
Ctrl-w h             " 소스 창으로 돌아가기
" ... 소스 편집 ...
```

### 워크플로우 2: 버퍼 기반 이동

```vim
set hidden           " 숨김 버퍼 활성화

:e models.py         " 파일 1 열기
:e views.py          " 파일 2 열기
:e urls.py           " 파일 3 열기

:ls                  " 모든 버퍼 보기
:b mod<Tab>          " models.py로 전환 (탭 자동완성)
Ctrl-^               " 마지막 두 버퍼 간 토글
:bn                  " 다음 버퍼
:bp                  " 이전 버퍼
```

### 워크플로우 3: 탭 작업 공간

```vim
" 탭 1: 메인 코드 (분할 뷰)
:e main.py
:vsp utils.py

" 탭 2: 테스트
:tabnew test_main.py
:vsp test_utils.py

" 탭 3: 설정
:tabnew config.yaml

" 이동:
gt / gT              " 탭 간 전환
Ctrl-w h/l           " 탭 내에서 창 전환
```

### 권장 키 매핑

```vim
" 빠른 버퍼 이동
nnoremap <leader>b :ls<CR>:b<Space>

" 빠른 창 이동
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" 버퍼 전환
nnoremap [b :bprev<CR>
nnoremap ]b :bnext<CR>
```

---

## 7. 요약

### 버퍼

| 명령 | 동작 |
|---------|--------|
| `:e {file}` | 파일 열기 |
| `:ls` | 버퍼 목록 |
| `:bn`, `:bp` | 다음/이전 버퍼 |
| `:b {name}` | 이름으로 전환 |
| `Ctrl-^` | 대체 버퍼 토글 |
| `:bd` | 버퍼 닫기 |

### 창

| 명령 | 동작 |
|---------|--------|
| `:sp`, `:vsp` | 수평/수직 분할 |
| `Ctrl-w h/j/k/l` | 창 이동 |
| `Ctrl-w =` | 크기 균등화 |
| `Ctrl-w _`, `Ctrl-w \|` | 높이/너비 최대화 |
| `Ctrl-w q` | 창 닫기 |
| `Ctrl-w o` | 나머지 모두 닫기 |

### 탭

| 명령 | 동작 |
|---------|--------|
| `:tabnew {file}` | 새 탭 |
| `gt`, `gT` | 다음/이전 탭 |
| `{N}gt` | N번 탭으로 이동 |
| `:tabclose` | 탭 닫기 |

### 개념 모델 다시 보기

```
버퍼(Buffer) = 메모리의 파일 (데이터)
창(Window)  = 버퍼를 보는 뷰포트 (뷰)
탭(Tab)     = 창 배치 (레이아웃)
```

**버퍼**를 기본 파일 관리 도구로 사용하세요. **창**은 여러 항목을 동시에 볼 때 사용하세요. **탭**은 독립적인 작업 공간이 필요할 때만 최소한으로 사용하세요.

---

## 연습 문제

### 연습 1: 버퍼 vs 창 vs 탭

아래 각 시나리오를 분류하세요: 버퍼(Buffer), 창(Window), 탭(Tab) 중 무엇을 올바르게 혹은 잘못 사용하고 있는지 설명하세요.

1. 개발자가 파일마다 탭을 하나씩 엽니다 — `app.py`를 탭 1에, `models.py`를 탭 2에, `views.py`를 탭 3에.
2. 개발자가 `:e`로 모든 파일을 열고 `:bn`/`:bp`와 `Ctrl-^`로 파일 간을 이동합니다.
3. 개발자가 `:vsp`로 `app.py`와 `test_app.py`를 같은 탭에서 나란히 표시합니다.
4. 개발자가 탭을 두 개 만들어: 탭 1에는 소스+테스트 분할 뷰를, 탭 2에는 문서를 표시합니다.

<details>
<summary>정답 보기</summary>

1. **잘못된 사용** — 이것은 전형적인 안티패턴입니다. Vim의 탭은 창 레이아웃이지 파일 홀더가 아닙니다. 파일마다 탭을 하나씩 열면 낭비이고 버퍼 시스템을 무력화합니다. 각 파일을 `:e`로 버퍼로 열고 `:bn`/`:bp` 또는 `:b {name}`으로 이동하세요.

2. **올바른 사용** — 이것이 의도된 버퍼 워크플로우입니다. `Ctrl-^`는 최근 두 버퍼 사이를 빠르게 전환하므로 소스 파일과 테스트 파일 사이를 왔다 갔다 할 때 이상적입니다.

3. **올바른 사용** — 창(splits)은 정확히 여러 버퍼를 동시에 보기 위한 것입니다. `:vsp`로 수직 분할을 만들면 두 파일을 동시에 볼 수 있습니다.

4. **올바른 사용** — 서로 다른 "작업 공간"이나 관심사(코드 레이아웃 vs 문서 레이아웃)에 탭을 사용하는 것은 Vim 탭의 정당한 사용입니다.

</details>

### 연습 2: 버퍼 목록 읽기

`:ls`를 실행하면 다음이 표시됩니다:

```
  1 %a   "main.py"        line 10
  2 #    "utils.py"       line 1
  3  h   "config.py"      line 5
  4  h+  "README.md"      line 1
```

다음 질문에 답하세요:

1. 현재 활성 창에 표시 중인 파일은?
2. 지금 `Ctrl-^`를 누르면 어떻게 됩니까?
3. 저장되지 않은 변경사항이 있는 버퍼는?
4. 메모리에는 로드되어 있지만 화면에는 표시되지 않는 버퍼는 몇 개입니까?

<details>
<summary>정답 보기</summary>

1. **`main.py`** — `%` 기호가 현재 버퍼(현재 창에 표시 중)를 나타내며, `a`는 활성(화면에 표시 중)을 의미합니다.

2. **`utils.py`로 전환** — `Ctrl-^`(`：b#`과 동일)는 대체 버퍼(Alternate buffer)인 `#`로 토글합니다. `utils.py`가 대체 버퍼입니다.

3. **`README.md`** — `+` 플래그는 저장되지 않은 변경사항이 있음을 나타냅니다. 버퍼 4(`README.md`)는 `h+`로 표시 — 숨겨져 있고 수정된 상태입니다.

4. **버퍼 2개**: `config.py`(버퍼 3)와 `README.md`(버퍼 4), 둘 다 `h`(숨김 — 로드되었지만 어떤 창에도 표시되지 않음)로 표시됩니다.

</details>

### 연습 3: 창 이동 순서

다음 창 레이아웃이 있고 커서는 창 A에 있습니다:

```
┌──────────────┬──────────────┐
│   Window A   │   Window B   │
│   (main.py)  │  (test.py)   │
├──────────────┴──────────────┤
│          Window C           │
│         (utils.py)          │
└─────────────────────────────┘
```

각 작업에 필요한 정확한 키 입력 순서를 작성하세요:

1. 창 A에서 창 B로 이동
2. 창 B에서 창 C로 이동
3. 창 C에서 창 A로 이동
4. 창 C의 높이를 최대화
5. 모든 창을 동일한 크기로 복원

<details>
<summary>정답 보기</summary>

1. `Ctrl-w l` — A에서 B로 오른쪽 이동
2. `Ctrl-w j` — B에서 C로 아래 이동
3. `Ctrl-w k` — C에서 위로 이동; A와 B가 모두 위에 있으므로 바로 위에 있는 창으로 이동합니다. 또는 `Ctrl-w w`로 창 순환
4. `Ctrl-w _` — 현재 창의 높이를 최대화
5. `Ctrl-w =` — 모든 창 크기를 균등화

</details>

### 연습 4: `:bufdo`로 다중 파일 이름 변경

Python 파일 5개를 열었고 모든 파일에서 변수 `user_id`를 `account_id`로 이름을 변경해야 합니다. 5개 파일이 모두 현재 버퍼로 로드되어 있습니다.

1. 열린 모든 버퍼에서 이 이름 변경을 수행하고 각 파일을 저장하는 단일 명령은?
2. 이 명령을 실행하기 전에 `set hidden`이 필요한 이유는?
3. `%s/old/new/ge`의 `e` 플래그는 무엇을 하며, 여기서 왜 유용합니까?

<details>
<summary>정답 보기</summary>

1. `:bufdo %s/user_id/account_id/ge | update`
   - `:bufdo`는 로드된 모든 버퍼에서 명령 실행
   - `%s/user_id/account_id/ge`는 모든 발생(`g`)을 치환하고 찾지 못해도 에러 억제(`e`)
   - `| update`는 수정된 버퍼만 저장

2. `set hidden`이 없으면 Vim은 저장되지 않은 변경사항이 있는 버퍼에서 전환을 거부합니다. `:bufdo`는 모든 버퍼를 순회해야 하는데, `hidden`이 설정되지 않은 상태에서 수정된 버퍼가 있으면 명령이 에러와 함께 중단됩니다. `set hidden`을 설정하면 Vim이 수정된 버퍼를 화면에 표시하지 않고도 백그라운드에서 로드 상태로 유지할 수 있습니다.

3. `e` 플래그는 패턴을 찾지 못했을 때 `"Pattern not found"` 에러 메시지를 억제합니다. `e`가 없으면 `:bufdo`는 `user_id`가 없는 첫 번째 버퍼에서 중단되어 나머지 버퍼들이 처리되지 않습니다.

</details>

### 연습 5: 탭 작업 공간 설계

`app.py`, `models.py`, `views.py`, `test_app.py`, `test_models.py`, `README.md` 파일들로 웹 프로젝트 작업을 시작합니다.

Vim 명령으로 탭 + 창 레이아웃을 설계하세요. 요구사항:
- 탭 1: 소스 코드 (`app.py`와 `models.py`를 나란히 표시)
- 탭 2: 테스트 (`test_app.py`와 `test_models.py`를 나란히 표시)
- 탭 3: 문서 (`README.md` 단독 표시)

처음부터 이 레이아웃을 설정하는 Vim 명령 순서를 작성하세요.

<details>
<summary>정답 보기</summary>

```vim
" 탭 1: 소스 코드 나란히 표시
:e app.py
:vsp models.py

" 탭 2: 테스트 나란히 표시
:tabnew test_app.py
:vsp test_models.py

" 탭 3: 문서
:tabnew README.md

" 탭 1로 돌아가기
:tabfirst
" 또는: 1gt
```

설정 후 `gt` / `gT`로 탭 간 전환하고, 탭 내 분할 창 사이는 `Ctrl-w h` / `Ctrl-w l`로 이동합니다.

참고: `app.py`, `models.py` 등은 모든 탭에서 버퍼로 접근 가능합니다 — 다시 열 필요가 없습니다. 탭은 단지 해당 버퍼들에 대한 다른 **뷰**를 제공할 뿐입니다.

</details>

---

**이전**: [레지스터, 마크, 매크로](./09_Registers_Marks_and_Macros.md) | **다음**: [명령줄과 고급 기능](./11_Command_Line_and_Advanced_Features.md)

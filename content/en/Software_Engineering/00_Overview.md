# Software Engineering

A comprehensive guide to software engineering as a discipline — covering the processes, methodologies, management techniques, and professional practices that transform individual programming skills into the ability to build large-scale, reliable, and maintainable software systems. This topic bridges the gap between writing code and engineering software.

## What You'll Learn

This topic focuses on the **engineering discipline** of software, not language-specific code:

- **Foundations**: What software engineering is, its history, and why it matters
- **Process Models**: Waterfall, agile, spiral, and iterative development approaches
- **Requirements**: How to capture, specify, and manage what software must do
- **Design and Modeling**: UML, architectural thinking, and design documentation
- **Planning and Estimation**: How to estimate effort, plan projects, and manage risk
- **Quality**: Testing strategies, verification, validation, and quality assurance
- **Configuration and Release**: Version control, change management, and CI/CD
- **Project Management**: Scheduling, teams, communication, and stakeholder management
- **Maintenance**: Evolution, legacy systems, and technical debt management
- **Process Improvement**: Capability maturity, metrics, and process assessment
- **Professional Practice**: Documentation, ethics, team dynamics, and career

> **Note**: This topic covers process-level and management-level practices. For code-level practices (clean code, design patterns, testing at the unit level), see the **Programming** topic. For distributed system architecture and scalability, see the **System_Design** topic.

## Lessons

| # | Title | Description |
|---|-------|-------------|
| 01 | [What Is Software Engineering](01_What_Is_Software_Engineering.md) | Definition, scope, history, software characteristics, professional roles |
| 02 | [Software Development Life Cycle](02_Software_Development_Life_Cycle.md) | Waterfall, V-Model, spiral, incremental, RAD, prototyping, model selection |
| 03 | [Agile and Iterative Development](03_Agile_and_Iterative_Development.md) | Agile Manifesto, Scrum, Kanban, XP, Lean, scaling agile, metrics |
| 04 | [Requirements Engineering](04_Requirements_Engineering.md) | Elicitation, functional vs non-functional, use cases, user stories, traceability |
| 05 | [Software Modeling and UML](05_Software_Modeling_and_UML.md) | UML diagrams, class, sequence, activity, state, use case diagrams |
| 06 | [Estimation and Planning](06_Estimation_and_Planning.md) | Story points, Planning Poker, COCOMO, function points, scheduling, risk |
| 07 | [Software Quality Assurance](07_Software_Quality_Assurance.md) | Quality models, SQA activities, reviews, audits, defect metrics |
| 08 | [Verification and Validation](08_Verification_and_Validation.md) | V&V strategies, testing levels, test planning, static vs dynamic analysis |
| 09 | [Configuration Management](09_Configuration_Management.md) | Version control strategy, branching, change management, release management |
| 10 | [Project Management](10_Project_Management.md) | Scheduling, WBS, critical path, risk management, stakeholder communication |
| 11 | [Software Maintenance and Evolution](11_Software_Maintenance_and_Evolution.md) | Maintenance types, legacy systems, refactoring at scale, technical debt |
| 12 | [Process Improvement](12_Process_Improvement.md) | CMMI, ISO 15504, metrics, retrospectives, continuous improvement |
| 13 | [DevOps and CI/CD](13_DevOps_and_CICD.md) | DevOps culture, pipelines, infrastructure as code, monitoring, SRE |
| 14 | [Technical Documentation](14_Technical_Documentation.md) | Architecture docs, ADRs, API docs, runbooks, documentation as code |
| 15 | [Team Dynamics and Communication](15_Team_Dynamics_and_Communication.md) | Team structures, Conway's Law, communication patterns, code review culture |
| 16 | [Ethics and Professionalism](16_Ethics_and_Professionalism.md) | ACM/IEEE codes, intellectual property, privacy, AI ethics, career growth |

## Prerequisites

- **Basic programming knowledge**: Experience writing code in at least one language
- **Familiarity with version control**: Basic Git usage (see the **Git** topic)
- **Exposure to a software project**: Having worked on any software project, even a personal one

No deep expertise is required. This topic is accessible to developers transitioning to larger teams or to those wanting to understand the discipline behind software production.

## Learning Path

The lessons are organized into four progressive tiers:

**Tier 1 — Foundations (Lessons 1–3)**
Understand what software engineering is, how development processes are structured, and how agile methods work in practice. These lessons provide the conceptual foundation for everything else.

**Tier 2 — Building Software (Lessons 4–8)**
Learn how to gather requirements, model systems, plan and estimate work, assure quality, and rigorously verify that software meets its goals.

**Tier 3 — Managing Software (Lessons 9–12)**
Configuration management, project management, software evolution, and process improvement. These are skills that matter most as projects grow larger and teams expand.

**Tier 4 — Modern Practice and Professionalism (Lessons 13–16)**
DevOps, documentation, team dynamics, and ethics — the practices that define mature engineering organizations and professional engineers.

## Example Code

Illustrative scripts and configuration files for CI/CD pipelines, project planning tools, and process automation are available in `examples/Software_Engineering/`.

## Related Topics

- **Programming**: Code-level practices — clean code, design patterns, TDD, refactoring, architecture patterns
- **System_Design**: Large-scale distributed system design, scalability, reliability, observability
- **Git**: Version control mechanics and workflows
- **Docker**: Containerization and deployment
- **MLOps**: ML-specific development and operational practices
- **Database_Theory**: Data management, transactions, and database design

---

**License**: Content licensed under CC BY-NC 4.0

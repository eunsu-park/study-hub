#!/bin/bash
# Exercises for Lesson 06: Advanced Git Commands
# Topic: Git
# Solutions to practice problems from the lesson.

# === Exercise 1: Stash Round-trip ===
# Problem: Modify two tracked files, stash them, create a new commit,
# restore the stash, and inspect stash diffs.
exercise_1() {
    echo "=== Exercise 1: Stash Round-trip ==="
    echo ""
    echo "Solution commands:"
    echo ""
    echo "  # Setup: Ensure you are in a repo with at least one commit"
    echo "  # and have two tracked files (e.g., README.md and app.js)"
    echo ""
    echo "  # Step 1: Modify two tracked files WITHOUT staging"
    echo "  echo 'work in progress line' >> README.md"
    echo "  echo '// TODO: refactor this' >> app.js"
    echo ""
    echo "  # Step 2: Stash the changes with a descriptive message"
    echo "  # Why: -m adds a message so you can identify this stash later"
    echo "  git stash push -m 'wip: exercise 1'"
    echo ""
    echo "  # Confirm the working directory is now clean"
    echo "  git status"
    echo "  # Output: 'nothing to commit, working tree clean'"
    echo ""
    echo "  # Step 3: Create a new commit on the current branch"
    echo "  echo 'unrelated change' > temp.txt"
    echo "  git add temp.txt"
    echo "  git commit -m 'chore: add temp file for exercise'"
    echo ""
    echo "  # Step 4: Before restoring, inspect the stash diff"
    echo "  # Why: -p shows the full patch so you know what you are restoring"
    echo "  git stash show -p stash@{0}"
    echo ""
    echo "  # Step 5: Restore the stash"
    echo "  # Why: pop applies AND removes the stash entry in one step"
    echo "  git stash pop"
    echo "  # If a conflict occurs (e.g., the new commit also modified README.md):"
    echo "  #   1. Open the conflicting file(s)"
    echo "  #   2. Resolve the conflict markers"
    echo "  #   3. git add <resolved-file>"
    echo "  #   4. The stash is consumed (dropped) after pop, even with conflicts"
    echo ""
    echo "  # Verify: the two modified files should have their WIP changes back"
    echo "  git diff"
}

# === Exercise 2: Interactive Rebase Cleanup ===
# Problem: Create 5 commits (2 features, 2 typo-fixes, 1 debug), then use
# interactive rebase to squash/fixup into 2 clean commits and drop the debug commit.
exercise_2() {
    echo "=== Exercise 2: Interactive Rebase Cleanup ==="
    echo ""
    echo "Solution commands:"
    echo ""
    echo "  # Step 1: Create a new branch with 5 commits"
    echo "  git switch -c exercise/rebase-cleanup"
    echo ""
    echo "  echo 'Feature A code' > feature_a.txt"
    echo "  git add feature_a.txt"
    echo "  git commit -m 'feat: implement feature A'"
    echo ""
    echo "  echo 'Fixed typo in A' >> feature_a.txt"
    echo "  git add feature_a.txt"
    echo "  git commit -m 'fix: typo in feature A'"
    echo ""
    echo "  echo 'Feature B code' > feature_b.txt"
    echo "  git add feature_b.txt"
    echo "  git commit -m 'feat: implement feature B'"
    echo ""
    echo "  echo 'console.log(debug)' > debug.txt"
    echo "  git add debug.txt"
    echo "  git commit -m 'debug: add console.log for testing'"
    echo ""
    echo "  echo 'Fixed typo in B' >> feature_b.txt"
    echo "  git add feature_b.txt"
    echo "  git commit -m 'fix: typo in feature B'"
    echo ""
    echo "  # Step 2: Start interactive rebase for the last 5 commits"
    echo "  git rebase -i HEAD~5"
    echo ""
    echo "  # Step 3: In the editor, rearrange and set actions:"
    echo "  # pick   <hash1>  feat: implement feature A"
    echo "  # fixup  <hash2>  fix: typo in feature A       <- squash into feature A"
    echo "  # pick   <hash3>  feat: implement feature B"
    echo "  # drop   <hash4>  debug: add console.log       <- remove debug commit"
    echo "  # fixup  <hash5>  fix: typo in feature B       <- squash into feature B"
    echo ""
    echo "  # Why fixup instead of squash?"
    echo "  # fixup merges the changes and DISCARDS the commit message (cleaner)"
    echo "  # squash merges changes and COMBINES commit messages (gives you a chance to edit)"
    echo ""
    echo "  # Step 4: Save and close the editor. Git replays the commits."
    echo ""
    echo "  # Step 5: Verify the result"
    echo "  git log --oneline"
    echo "  # Expected: exactly 2 commits"
    echo "  # <hash>  feat: implement feature B"
    echo "  # <hash>  feat: implement feature A"
}

# === Exercise 3: Cherry-pick a Hotfix ===
# Problem: Create a bug fix on a feature branch, then cherry-pick
# just that commit to main.
exercise_3() {
    echo "=== Exercise 3: Cherry-pick a Hotfix ==="
    echo ""
    echo "Solution commands:"
    echo ""
    echo "  # Step 1: Switch to feature branch and create a critical bug fix"
    echo "  git switch feature"
    echo "  echo 'critical fix applied' > security_patch.txt"
    echo "  git add security_patch.txt"
    echo "  git commit -m 'fix: critical security patch'"
    echo ""
    echo "  # Step 2: Note the commit hash"
    echo "  git log --oneline -1"
    echo "  # Output: abc1234 fix: critical security patch"
    echo ""
    echo "  # Step 3: Switch to main and cherry-pick that specific commit"
    echo "  # Why: Cherry-pick copies a single commit without merging the entire feature branch"
    echo "  git switch main"
    echo "  git cherry-pick abc1234    # Replace with your actual hash"
    echo ""
    echo "  # Step 4: Confirm the fix is on main"
    echo "  git log --oneline -3"
    echo "  # The security patch commit should appear on main"
    echo ""
    echo "  # Step 5: Confirm the rest of feature branch is NOT on main"
    echo "  git log --oneline main..feature"
    echo "  # Should show the feature branch commits that were NOT cherry-picked"
    echo ""
    echo "Key takeaway:"
    echo "  Cherry-pick is ideal for hotfixes: you get exactly the commit(s) you need"
    echo "  on main without pulling in incomplete feature work."
}

# === Exercise 4: reset vs revert Decision ===
# Problem: Demonstrate when to use reset (local) vs revert (pushed),
# and why reset is inappropriate for shared history.
exercise_4() {
    echo "=== Exercise 4: reset vs revert Decision ==="
    echo ""
    echo "Solution commands:"
    echo ""
    echo "  # Step 1: Create three commits on a local-only branch"
    echo "  git switch -c exercise/reset-vs-revert"
    echo "  echo 'commit A' > a.txt && git add a.txt && git commit -m 'A: add a.txt'"
    echo "  echo 'commit B' > b.txt && git add b.txt && git commit -m 'B: add b.txt'"
    echo "  echo 'commit C' > c.txt && git add c.txt && git commit -m 'C: add c.txt'"
    echo ""
    echo "  # Step 2: Use --soft reset to undo commit C"
    echo "  # Why: --soft moves HEAD back but keeps changes staged (ready to re-commit)"
    echo "  git reset --soft HEAD~1"
    echo "  git status"
    echo "  # c.txt is in the staging area (Changes to be committed)"
    echo "  # The file content is preserved -- only the commit was undone"
    echo ""
    echo "  # Step 3: Re-commit, then use --hard reset"
    echo "  git commit -m 'C: add c.txt (re-committed)'"
    echo "  git reset --hard HEAD~1"
    echo "  # c.txt is GONE -- both the commit and the file changes are deleted"
    echo "  ls c.txt 2>/dev/null || echo 'c.txt does not exist -- hard reset removed it'"
    echo ""
    echo "  # Step 4: Push the branch, make another commit D, then use revert"
    echo "  git push -u origin exercise/reset-vs-revert"
    echo "  echo 'commit D' > d.txt && git add d.txt && git commit -m 'D: add d.txt'"
    echo "  git push"
    echo ""
    echo "  # Now undo D with revert (NOT reset)"
    echo "  # Why: revert creates a NEW commit that undoes D, preserving shared history"
    echo "  git revert HEAD"
    echo "  git push"
    echo ""
    echo "Why reset is inappropriate for pushed commits:"
    echo ""
    echo "  git reset rewrites history by moving the branch pointer backward."
    echo "  If others have already pulled commit D, their history includes D."
    echo "  If you reset and force-push, their local repo diverges from remote,"
    echo "  causing confusion, duplicated commits, and merge conflicts."
    echo ""
    echo "  git revert is safe for shared branches because it ADDS a new commit"
    echo "  that undoes the changes, keeping the timeline intact for everyone."
    echo ""
    echo "  Rule of thumb:"
    echo "    - Local-only commits -> reset (clean history)"
    echo "    - Pushed/shared commits -> revert (safe undo)"
}

# === Exercise 5: Recover with reflog ===
# Problem: Simulate lost commits via hard reset, then recover them
# using reflog. Bonus: recover a deleted branch.
exercise_5() {
    echo "=== Exercise 5: Recover with reflog ==="
    echo ""
    echo "Solution commands:"
    echo ""
    echo "  # Step 1: Create a branch with two commits"
    echo "  git switch -c exercise/reflog-recovery"
    echo "  echo 'important work 1' > work1.txt && git add . && git commit -m 'Add work 1'"
    echo "  echo 'important work 2' > work2.txt && git add . && git commit -m 'Add work 2'"
    echo ""
    echo "  # Step 2: Simulate disaster -- hard reset loses both commits"
    echo "  git reset --hard HEAD~2"
    echo "  # Both commits appear to be gone!"
    echo "  git log --oneline -3"
    echo "  # work1.txt and work2.txt are gone from the working directory"
    echo ""
    echo "  # Step 3: Use reflog to find the lost commits"
    echo "  # Why: reflog records EVERY movement of HEAD, even across resets"
    echo "  git reflog"
    echo "  # Look for entries like:"
    echo "  # abc1234 HEAD@{1}: reset: moving to HEAD~2"
    echo "  # def5678 HEAD@{2}: commit: Add work 2       <- This is what we want"
    echo "  # ghi9012 HEAD@{3}: commit: Add work 1"
    echo ""
    echo "  # Step 4: Recover to the state before the reset"
    echo "  # Why: This moves HEAD back to the commit that includes both work files"
    echo "  git reset --hard def5678    # Use the SHA from reflog for 'Add work 2'"
    echo ""
    echo "  # Verify: both files are back"
    echo "  ls work1.txt work2.txt"
    echo "  git log --oneline -3"
    echo ""
    echo "  # === Bonus: Recover a deleted branch ==="
    echo ""
    echo "  # Step 5: Delete a branch"
    echo "  git switch main"
    echo "  git branch -D exercise/reflog-recovery"
    echo "  # The branch is gone!"
    echo ""
    echo "  # Step 6: Find the branch tip in reflog"
    echo "  git reflog | head -20"
    echo "  # Look for: '<sha> HEAD@{N}: checkout: moving from exercise/reflog-recovery to main'"
    echo "  # The <sha> just before that checkout is the branch tip"
    echo ""
    echo "  # Step 7: Recreate the branch at its original tip"
    echo "  git branch exercise/reflog-recovery <sha>"
    echo "  git switch exercise/reflog-recovery"
    echo "  git log --oneline -3    # All commits are back!"
    echo ""
    echo "Key takeaway:"
    echo "  Git almost never truly deletes data. The reflog is your safety net."
    echo "  By default, reflog entries are kept for 90 days."
    echo "  As long as you act within that window, 'lost' work can be recovered."
}

# Run all exercises
exercise_1
echo ""
exercise_2
echo ""
exercise_3
echo ""
exercise_4
echo ""
exercise_5
echo ""
echo "All exercises completed!"
